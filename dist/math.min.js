!function webpackUniversalModuleDefinition(t,e){"object"==typeof exports&&"object"==typeof module?module.exports=e():"function"==typeof define&&define.amd?define([],e):"object"==typeof exports?exports.math=e():t.math=e()}("undefined"!=typeof self?self:this,(function(){return function(t){var e={};function __webpack_require__(r){if(e[r])return e[r].exports;var n=e[r]={i:r,l:!1,exports:{}};return t[r].call(n.exports,n,n.exports,__webpack_require__),n.l=!0,n.exports}return __webpack_require__.m=t,__webpack_require__.c=e,__webpack_require__.d=function(t,e,r){__webpack_require__.o(t,e)||Object.defineProperty(t,e,{enumerable:!0,get:r})},__webpack_require__.r=function(t){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(t,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(t,"__esModule",{value:!0})},__webpack_require__.t=function(t,e){if(1&e&&(t=__webpack_require__(t)),8&e)return t;if(4&e&&"object"==typeof t&&t&&t.__esModule)return t;var r=Object.create(null);if(__webpack_require__.r(r),Object.defineProperty(r,"default",{enumerable:!0,value:t}),2&e&&"string"!=typeof t)for(var n in t)__webpack_require__.d(r,n,function(e){return t[e]}.bind(null,n));return r},__webpack_require__.n=function(t){var e=t&&t.__esModule?function getDefault(){return t.default}:function getModuleExports(){return t};return __webpack_require__.d(e,"a",e),e},__webpack_require__.o=function(t,e){return Object.prototype.hasOwnProperty.call(t,e)},__webpack_require__.p="",__webpack_require__(__webpack_require__.s=15)}([function(t,e,r){"use strict";Object.defineProperty(e,"__esModule",{value:!0});var n=0;class Node{constructor(t,e,r){this._id=++n,this.trace=t,this.doc=e,this.tex=r}toString(){return this.toIndentedString(0)}error(t){return Node.error(t,this.trace)}static error(t,e){return e?e.error(t):new Error(t)}static normalizePrecedence(t){if(!1===t)return[0,0];if(!0===t)return[2,0];if("number"==typeof t)return[0,t];if(!(t instanceof Array&&2==t.length))throw console.log(t),Error("wut");return t}shouldConsolidate(t){var e=Node.normalizePrecedence(this.precedence||!1),r=Node.normalizePrecedence(t||!1);return(0!=e[0]||0!=e[1])&&!(e[0]<r[0]||e[0]==r[0]&&e[1]<r[1])}static escapeTeX(t){return t.replace(/&|%|\$|#|_|{|}|~|\^|\\/g,(t=>({"&":"\\&","%":"\\%",$:"\\$","#":"\\#",_:"\\_","{":"\\{","}":"\\}","~":"\\textasciitilde","^":"\\textasciicircum","\\":"\\textbackslash"}[t])))}static parseTeX(t){var e=!1,r=t.replace(/^!<prec=([0-9]+)>/,((t,r)=>(e=1*r,"")));return{precedence:e,code:r}}static makeTeXName(t){var e=new RegExp(`^(?:([a-z])|(${["alpha","beta","gamma","delta","epsilon","zeta","eta","theta","iota","kappa","lambda","mu","nu","xi","omicron","pi","rho","sigma","tau","upsilon","phi","chi","psi","omega"].join("|")}))([0-9]*)$`,"i"),r=t.match(e);return r?(()=>{if(r[1])return r[1];var t=r[2].charCodeAt(0)<="Z".charCodeAt(0),e=r[2].toLowerCase();return t&&(e=e[0].toUpperCase()+e.substring(1)),"\\"+e})()+(r[3]?1==r[3].length?"_"+r[3]:`_{${r[3]}}`:""):1==t.length?Node.escapeTeX(t):`\\mathrm{${Node.escapeTeX(t)}}`}makeTeX(t,e,r){e=e||[],r=r||!1;var n=this.tex;return this.shouldConsolidate(r)&&(n="\\left("+n+"\\right)"),n.replace(/#([0-9]+)/g,((t,r)=>e[1*r-1]||`\\texttt{\\textcolor{red}{\\#${r}}}`)).replace(/<<(.+?)>>/,((e,r)=>`\\href{#${t}}{${r}}`))}}e.default=Node,Node.PREC_FUNEXPR=1e3,Node.PREC_COMMA=1e3,Node.PREC_COLONEQQ=1e5},function(t,e,r){"use strict";var n=this&&this.__importDefault||function(t){return t&&t.__esModule?t:{default:t}};Object.defineProperty(e,"__esModule",{value:!0}),e.EqualsPriority=void 0;const a=n(r(0));!function(t){t[t.ZERO=0]="ZERO",t[t.ONE=1]="ONE",t[t.TWO=2]="TWO",t[t.THREE=3]="THREE",t[t.FOUR=4]="FOUR",t[t.FIVE=5]="FIVE"}(e.EqualsPriority||(e.EqualsPriority={}));class Metaexpr extends a.default{constructor(t,e,r,n){if(super(t,e,r),!n)throw a.default.error("Assertion failed",t);this.type=n}expandMeta(t){return this.expandMetaCache?this.expandMetaCache:this.expandMetaCache=this.expandMetaInternal(t)}equals(t,e){return this===t||!!this.type.equals(t.type)&&(t.getEqualsPriority(e)>this.getEqualsPriority(e)?t.equalsInternal(this,e):this.equalsInternal(t,e))}isProved(t){t=t||[];for(var e=0;e<t.length;e++)if(t[e]==this)return!0;return this.isProvedInternal(t)}getProof(t,e,r,n=!1){return t.has(this)?[{_type:"R",ctr:r.next(),num:t.get(this),expr:this}]:e.has(this)?[{_type:"R",ctr:r.next(),num:e.get(this),expr:this}]:this.getProofInternal(t,e,r,n)}}e.default=Metaexpr},function(t,e,r){"use strict";var n=this&&this.__importDefault||function(t){return t&&t.__esModule?t:{default:t}};Object.defineProperty(e,"__esModule",{value:!0});const a=n(r(0)),i=n(r(12));class ObjectType extends i.default{constructor(t){if(t.origin){if(super(null,t.doc,null,t.origin.isFunctional),this.isBaseType=!!t.base,"string"!=typeof t.name)throw a.default.error("typeof o.name != 'string'",null);if(this.name=t.name,!(t.origin instanceof ObjectType))throw a.default.error("!(o.origin instanceof ObjectType)",null);this.origin=t.origin}else{if(super(null,t.doc,null,t.functional),this.isBaseType=!!t.base,"boolean"!=typeof t.functional)throw a.default.error("typeof o.functional != 'boolean'",null);if(t.functional){if(t.from.map((t=>t instanceof ObjectType)).some((t=>!t)))throw a.default.error("o.from.map(f => f instanceof ObjectType).some(e => !e)",null);if(!(t.to instanceof ObjectType))throw a.default.error("!(o.to instanceof ObjectType)",null);this.from=t.from,this.to=t.to}else{if("string"!=typeof t.name)throw a.default.error("typeof o.name != 'string'",null);this.name=t.name}}}toSimpleString(){if(this.name)return this.name;var t=this.resolve();return`[${t.from.map((t=>t.toSimpleString())).join(", ")} -> ${t.to.toSimpleString()}]`}toIndentedString(t){return this.isSimple?this.name:`${this.name?this.name+": ":""}[${this.resolve().from.join(", ")} -> ${this.resolve().to}]`}toTeXString(t){return this.isSimple||!t&&this.name?`\\href{#type-${this.name}}\\mathsf{${this.name}}`:(this.name?`\\href{#type-${this.name}}\\mathsf{${this.name}}: `:"")+("\\left["+this.resolve().from.map((t=>t.toTeXString())).join(" \\times "))+` \\to ${this.resolve().to.toTeXString()} \\right]`}resolve(){return this.origin?this.origin.resolve():this}equals(t){if(!(t instanceof ObjectType))return!1;if(this.origin)return this.origin.equals(t);if(t.origin)return this.equals(t.origin);if(this.isSimple!=t.isSimple)return!1;if(this.isSimple)return this===t;if(this.from.length!=t.from.length)return!1;for(var e=0;e<this.from.length;e++)if(!this.from[e].equals(t.from[e]))return!1;return this.to.equals(t.to)}}e.default=ObjectType},function(t,e,r){"use strict";var n=this&&this.__importDefault||function(t){return t&&t.__esModule?t:{default:t}};Object.defineProperty(e,"__esModule",{value:!0});const a=n(r(8));class Fun extends a.default{constructor({doc:t,tex:e,annotations:r,sealed:n,rettype:a,name:i,params:s,expr:f},h){if(!i&&!f)throw l.default.error("Anonymous fun cannot be primitive",h);if(a&&f&&!a.equals(f.type))throw l.default.error(`Expression type ${f.type} failed to match the return type ${a} of fun ${i}`,h);if(!a&&!f)throw l.default.error("Cannot guess the return type of a primitive fun",h);if(n&&!f)throw l.default.error("Cannot seal a primitive fun",h);var d=!1;if(e){var c=l.default.parseTeX(e);d=c.precedence,e=c.code}else e=null;super(h,t,e,new((a||f.type)instanceof u.default?u.default:o.default)({functional:!0,from:s.map((t=>t.type)),to:a||f.type})),this.annotations=r,this.sealed=n,this.precedence=d,this.name=i,this.params=s,this.expr=f}isProvedInternal(t){return this.expr&&this.expr.isProved(t)}getEqualsPriority(){return s.EqualsPriority.ONE}equalsInternal(t,e){if((!this.expr||this.sealed)&&(!(t instanceof Fun&&t.expr)||t.sealed))return!1;for(var r=[],n=this.type.resolve().from,a=0;a<n.length;a++)r.push(new h.default({type:n[a],name:"$"+a,selector:null},this.trace));var s=this.expr&&!this.sealed?this.call(r):new i.default({fun:this,args:r},this.trace),o=t instanceof Fun&&t.expr&&!t.sealed?t.call(r):new i.default({fun:t,args:r},this.trace);return s.equals(o,e)}call(t){if(!this.expr)throw Error("Cannot call a primitive fun");if(this.params.length!=t.length)throw Error("Illegal arguments length");for(var e=new Map,r=0;r<this.params.length;r++)e.set(this.params[r],t[r]);return this.expr.substitute(e)}getProofInternal(t,e,r,n=!1){if(this instanceof f.default&&this.name&&!n)return[{_type:"RS",ctr:r.next(),expr:this}];if(!this.expr)return[{_type:"NP",ctr:r.next(),expr:this}];e=new Map(e);var a=r.peek()+1,i=[];return this instanceof f.default&&this.def$s.forEach((n=>{var a=n.expr.getProof(t,e,r);i=i.concat(a);var s=a[a.length-1].ctr;e.set(n,s)})),[{_type:"V",$lines:i,lines:this.expr.getProof(t,e,r),params:this.params,ctr:[a,r.peek()]}]}}e.default=Fun;const i=n(r(7)),s=r(1),o=n(r(9)),l=n(r(0)),u=n(r(2)),f=n(r(6)),h=n(r(10))},function(t,e,r){"use strict";var n=this&&this.__importDefault||function(t){return t&&t.__esModule?t:{default:t}};Object.defineProperty(e,"__esModule",{value:!0});const a=n(r(8)),i=r(1),s=n(r(0));class Variable extends a.default{constructor({doc:t,tex:e,sealed:r,type:n,name:a,expr:i},o){if(super(o,t,e,n),"string"!=typeof a)throw s.default.error("Assertion failed",o);if(r&&!i)throw s.default.error("Cannot seal a primitive fun",o);if(i&&!n.equals(i.type))throw s.default.error(`Expression type ${i.type} failed to match the type ${n} of variable ${a}`,o);this.sealed=r,this.name=a,this.expr=i}isProvedInternal(t){return!1}substitute(t){return t.has(this)?t.get(this):this}expandMetaInternal(t){return this}getEqualsPriority(t){return!this.expr||this.sealed&&!t.canUse(this)?i.EqualsPriority.ZERO:i.EqualsPriority.FOUR}equalsInternal(t,e){return!!this.expr&&(!(this.sealed&&!e.canUse(this))&&this.expr.equals(t,e))}getProofInternal(t,e,r){return[{_type:"NP",ctr:r.next(),expr:this}]}toSimpleString(){return this.type.toSimpleString()+" "+this.name}toIndentedString(t,e){return`${e?this.type+" ":""}${this.name}<${this._id}>`}toTeXString(t,e){return`\\href{#${this instanceof o.default?"id-"+this._id:"def-"+this.name}}{${this.tex||s.default.makeTeXName(this.name)}}${e&&this.expr?"\\coloneqq "+this.expr.toTeXString(s.default.PREC_COLONEQQ):""}`}}e.default=Variable;const o=n(r(10))},function(t,e,r){"use strict";var n=this&&this.__createBinding||(Object.create?function(t,e,r,n){void 0===n&&(n=r),Object.defineProperty(t,n,{enumerable:!0,get:function(){return e[r]}})}:function(t,e,r,n){void 0===n&&(n=r),t[n]=e[r]}),a=this&&this.__setModuleDefault||(Object.create?function(t,e){Object.defineProperty(t,"default",{enumerable:!0,value:e})}:function(t,e){t.default=e}),i=this&&this.__importStar||function(t){if(t&&t.__esModule)return t;var e={};if(null!=t)for(var r in t)"default"!==r&&Object.prototype.hasOwnProperty.call(t,r)&&n(e,t,r);return a(e,t),e},s=this&&this.__importDefault||function(t){return t&&t.__esModule?t:{default:t}};Object.defineProperty(e,"__esModule",{value:!0});const o=i(r(1)),l=s(r(0));class $Variable extends o.default{constructor({name:t,expr:e},r){if(super(r,null,null,e.type),!t||!e)throw l.default.error("Assertion failed",r);this.name=t,this.expr=e}isProvedInternal(t){return this.expr.isProved(t)}substitute(t){return this.expr.substitute(t)}expandMetaInternal(t){return this.expr.expandMeta(t)}getEqualsPriority(){return o.EqualsPriority.FIVE}equalsInternal(t,e){return this.expr.equals(t,e)}getProofInternal(t,e,r){if(!e.has(this))throw Error(this.name+" is not defined");return[{_type:"R",ctr:r.next(),num:e.get(this),expr:this.expr}]}toIndentedString(t,e){return this.name}toTeXString(t,e){return`\\mathtt{${l.default.escapeTeX(this.name)}}`}}e.default=$Variable},function(t,e,r){"use strict";var n=this&&this.__importDefault||function(t){return t&&t.__esModule?t:{default:t}};Object.defineProperty(e,"__esModule",{value:!0});const a=n(r(3));class Schema extends a.default{constructor({doc:t,tex:e,annotations:r,schemaType:n,name:a,params:s,context:o,def$s:l,expr:u},f){if(!u)throw i.default.error("wut",f);if("schema"!=n&&!a)throw i.default.error("wut",f);if(super({doc:t,tex:e,annotations:r,sealed:!1,rettype:null,name:a,params:s,expr:u},f),this.schemaType=n,this.def$s=l||[],this.context=o,"theorem"==n&&!this.isProved())throw i.default.error(`Schema ${a} is marked as a theorem but it is not proved`,f)}isProved(t){if(this.isProvedCache)return!0;if(!t&&"boolean"==typeof this.isProvedCache)return this.isProvedCache;var e=!t||!t.length;t=t||[];var r="axiom"==this.schemaType||super.isProved(t);return e&&(this.isProvedCache=r),r}substitute(t){if(!this.expr)return this;if(this.name)return this;if(this.params.some((e=>t.has(e))))throw Error("Parameter collision");return new Schema({doc:null,tex:null,annotations:this.annotations,schemaType:"schema",name:null,params:this.params,context:this.context,def$s:this.def$s,expr:this.expr.substitute(t)},this.trace)}expandMetaInternal(t){return this.expr?this.type instanceof s.default&&this.name?this:new Schema({doc:null,tex:null,annotations:this.annotations,schemaType:"schema",name:null,params:this.params,context:this.context,def$s:this.def$s,expr:this.expr.expandMeta(t)},this.trace):this}isCallable(t){return!0}toIndentedString(t,e){return[`∫ ${this.name||""}(${this.params.map((e=>e.toIndentedString(t))).join(", ")}) => {`,"\t"+this.expr.expandMeta(!0).toIndentedString(t+1),"}"].join("\n"+"\t".repeat(t))}toTeXString(t,e){if(!this.name)return this.precedence=i.default.PREC_FUNEXPR,[this.shouldConsolidate(t)?"\\left(":"",1==this.params.length?this.params[0].toTeXString(!1):`\\left(${this.params.map((t=>t.toTeXString(i.default.PREC_COMMA))).join(", ")}\\right)`,"\\mapsto ",this.expr.expandMeta(!0).toTeXString(!1),this.shouldConsolidate(t)?"\\right)":""].join("");var r=`schema-${this.isProved()?"p":"np"}-${this.name}`;return e?`\\href{#${r}}{\\mathsf{${i.default.escapeTeX(this.name)}}}\\mathord{\\left(${this.params.map((t=>t.toTeXStringWithId(i.default.PREC_COMMA)+(t.selector?`: \\texttt{@${t.selector}}`:""))).join(", ")}\\right)}:\\\\\\quad`+this.expr.expandMeta(!0).toTeXString(!0):`\\href{#${r}}\\mathsf{${i.default.escapeTeX(this.name)}}`}}e.default=Schema;const i=n(r(0)),s=n(r(2))},function(t,e,r){"use strict";var n=this&&this.__importDefault||function(t){return t&&t.__esModule?t:{default:t}};Object.defineProperty(e,"__esModule",{value:!0});const a=n(r(5)),i=n(r(8)),s=n(r(3)),o=r(1),l=r(13),u=n(r(0)),f=n(r(11)),h=n(r(6)),d=n(r(4));class Funcall extends i.default{constructor({fun:t,args:e},r){if(t.type.isSimple){var n=l.isNameable(t)?t.name:"<anonymous>";throw u.default.error(n+" is not callable",r)}if(!(e instanceof Array)||e.map((t=>t instanceof u.default)).some((t=>!t)))throw u.default.error("Assertion failed",r);var a=t.type.resolve(),i=a.from,s=e.map((t=>t.type));if(i.length!=s.length)throw u.default.error(`Invalid number of arguments (expected ${i.length}): ${s.length}`,r);for(var o=0;o<i.length;o++)if(!i[o].equals(s[o]))throw u.default.error(`Argument #${o+1} has illegal argument type (expected ${i[o]}): ${s[o]}`,r);super(r,null,null,a.to),this.fun=t,this.args=e}isProvedInternal(t){return this.fun.isProved(t)}substitute(t){return new Funcall({fun:this.fun.substitute(t),args:this.args.map((e=>e.substitute(t)))},this.trace)}expandMetaInternal(t){var e=this.fun.expandMeta(t),r=this.args.map((e=>e.expandMeta(t)));return e instanceof s.default&&e.expr&&(!e.name||e instanceof h.default)?e.call(r).expandMeta(t):new Funcall({fun:e,args:r},this.trace)}isExpandable(t){for(var e=this.fun;e instanceof a.default;)e=e.expr;for(;e instanceof d.default&&e.expr;)e=e.expr;return e instanceof Funcall?e.isExpandable(t):e instanceof s.default&&e.isCallable(t)}expandOnce(t){if(!this.isExpandable(t))throw Error("Cannot expand");for(var e=this.fun;e instanceof a.default;)e=e.expr;for(;e instanceof d.default&&e.expr;)e=e.expr;if(e instanceof Funcall)return new Funcall({fun:e.expandOnce(t),args:this.args},this.trace);if(!(e instanceof s.default))throw Error("Something's wrong");return e.call(this.args)}getEqualsPriority(){return o.EqualsPriority.THREE}equalsInternal(t,e){if(!(t instanceof Funcall))return!!this.isExpandable(e)&&this.expandOnce(e).equals(t,e);if(this.fun==t.fun||this.fun.equals(t.fun,e)){for(var r=0;r<this.args.length;r++)if(!this.args[r].equals(t.args[r],e))return!1;return!0}if(this.fun instanceof Funcall&&this.fun.isExpandable(e))return this.expandOnce(e).equals(t,e);if(t.fun instanceof Funcall&&t.fun.isExpandable(e))return this.equals(t.expandOnce(e),e);var n=this.isExpandable(e),a=t.isExpandable(e);if(this.fun==t.fun||!n&&!a){if(this.fun!=t.fun)return!1;if(!n&&!a){for(r=0;r<this.args.length;r++)if(!this.args[r].equals(t.args[r],e))return!1;return!0}if(this.args.every(((r,n)=>this.args[n].equals(t.args[n],e))))return!0}return n?this.expandOnce(e).equals(t,e):this.equals(t.expandOnce(e),e)}getProofInternal(t,e,r){if(t.has(this.fun))return[{_type:"RC",ctr:r.next(),schema:t.get(this.fun),args:this.args,expr:this}];if(e.has(this.fun))return[{_type:"RC",ctr:r.next(),schema:e.get(this.fun),args:this.args,expr:this}];if(this.fun instanceof h.default&&this.fun.name)return[{_type:"RCX",ctr:r.next(),expr:this}];if(!(this.fun instanceof h.default))return[{_type:"NP",ctr:r.next(),expr:this}];var n=this.fun.getProof(t,e,r);return[...n,{_type:"RC",ctr:r.next(),schema:n[n.length-1].ctr,args:this.args,expr:this}]}toIndentedString(t,e){var r=this.args.map((e=>e instanceof d.default?`${e.name}<${e._id}>`:e.toIndentedString(t+1)));return r.join("").length<=50?(r=(r=this.args.map((e=>e instanceof d.default?`${e.name}<${e._id}>`:e.toIndentedString(t)))).join(", "),this.fun instanceof h.default?`${this.fun.name||`(${this.fun})`}(${r})`:[this.fun instanceof s.default&&this.fun.name?this.fun.name:"("+this.fun.toIndentedString(t)+")",`(${r})`].join("")):(r=r.join(",\n"+"\t".repeat(t+1)),this.fun instanceof h.default?[this.fun.name||`(${this.fun.toIndentedString(t)})`,"(","\t"+r,")"].join("\n"+"\t".repeat(t)):[(this.fun instanceof s.default&&"name"in this.fun&&this.fun.name?this.fun.name:"("+this.fun.toIndentedString(t)+")")+"(","\t"+r,")"].join("\n"+"\t".repeat(t)))}toTeXString(t,e){if(this.fun instanceof h.default)return(this.fun.name?`\\href{#schema-${this.fun.isProved()?"p":"np"}-${this.fun.name}}{\\textsf{${u.default.escapeTeX(this.fun.name)}}}`:this.fun.toTeXString(!1))+`\\mathord{\\left(${this.args.map((t=>t.toTeXString(u.default.PREC_COMMA))).join(", ")}\\right)}`;if(this.fun instanceof f.default)return this.fun.funcallToTeXString(this.args,t);var r=this.args.map((t=>t.toTeXString(u.default.PREC_COMMA)));return(!l.isNameable(this.fun)||!this.fun.name||this.fun instanceof d.default?this.fun.toTeXString(!1):u.default.makeTeXName(this.fun.name))+`\\mathord{\\left(${r.join(", ")}\\right)}`}}e.default=Funcall},function(t,e,r){"use strict";var n=this&&this.__importDefault||function(t){return t&&t.__esModule?t:{default:t}};Object.defineProperty(e,"__esModule",{value:!0});const a=n(r(1));class Expr0 extends a.default{}e.default=Expr0},function(t,e,r){"use strict";var n=this&&this.__importDefault||function(t){return t&&t.__esModule?t:{default:t}};Object.defineProperty(e,"__esModule",{value:!0});const a=n(r(0)),i=n(r(2)),s=n(r(12));class MetaType extends s.default{constructor(t){if(super(null,null,null,t.functional),"boolean"!=typeof t.functional)throw a.default.error("typeof o.functional != 'boolean'",null);if(0==t.functional){if(!(t.left instanceof Array))throw a.default.error("left should be an array",null);this.left=t.left,this.right=t.right}else{if(t.from.some((t=>!(t instanceof i.default))))throw a.default.error("o.from.some(f => !(f instanceof ObjectType))",null);if(!(t.to instanceof MetaType))throw a.default.error("!(o.to instanceof MetaType)",null);if(t.to.isFunctional)throw a.default.error("Functional metatype in functional metatype is not supported",null);this.from=t.from,this.to=t.to}}resolve(){return this}toIndentedString(t){return this.isSimple?`[${this.left.join(", ")} |- ${this.right}]`:`[${this.from.join(", ")} -> ${this.to}]`}toTeXString(t,e){throw new Error("Method not implemented.")}equals(t){if(!(t instanceof MetaType))return!1;if(this.isSimple!=t.isSimple)return!1;if(this.isSimple){if(this.left.length!=t.left.length)return!1;for(let e=0;e<this.left.length;e++)if(!this.left[e].equals(t.left[e]))return!1;return!!this.right.equals(t.right)}if(this.from.length!=t.from.length)return!1;for(let e=0;e<this.from.length;e++)if(!this.from[e].equals(t.from[e]))return!1;return this.to.equals(t.to)}}e.default=MetaType},function(t,e,r){"use strict";var n=this&&this.__importDefault||function(t){return t&&t.__esModule?t:{default:t}};Object.defineProperty(e,"__esModule",{value:!0});const a=n(r(4));class Parameter extends a.default{constructor({doc:t,tex:e,type:r,name:n,selector:a},i){super({doc:t,tex:e,sealed:!1,type:r,name:n,expr:null},i),this.selector=a}toTeXStringWithId(t,e){return[`\\htmlId{${"id-"+this._id}}{`,this.toTeXString(t,e),"}"].join("")}}e.default=Parameter},function(t,e,r){"use strict";var n=this&&this.__importDefault||function(t){return t&&t.__esModule?t:{default:t}};Object.defineProperty(e,"__esModule",{value:!0});const a=n(r(3)),i=n(r(0)),s=n(r(2));class ObjectFun extends a.default{constructor({doc:t,tex:e,annotations:r,sealed:n,rettype:a,name:i,params:s,expr:o},l){super({doc:t,tex:e,annotations:r,sealed:n,rettype:a,name:i,params:s,expr:o},l)}substitute(t){if(!this.expr)return this;if(this.name)return this;if(this.params.some((e=>t.has(e))))throw Error("Parameter collision");return new ObjectFun({doc:null,tex:null,annotations:this.annotations,sealed:this.sealed,rettype:null,name:null,params:this.params,expr:this.expr.substitute(t)},this.trace)}expandMetaInternal(t){return this.expr?this.type instanceof s.default&&this.name?this:new ObjectFun({doc:null,tex:null,annotations:this.annotations,sealed:this.sealed,rettype:null,name:null,params:this.params,expr:this.expr.expandMeta(t)},this.trace):this}isCallable(t){return this.expr&&(!this.sealed||t.canUse(this))}toIndentedString(t,e){return this.name?this.name:[`ƒ ${this.name||""}(${this.params.map((e=>e.toIndentedString(t))).join(", ")}) => {`,"\t"+this.expr.toIndentedString(t+1),"}"].join("\n"+"\t".repeat(t))}toTeXString(t,e){return this.name?e?this.expr?this.funcallToTeXString(this.params,i.default.PREC_COLONEQQ)+"\\coloneqq "+this.expr.toTeXString(i.default.PREC_COLONEQQ):this.funcallToTeXString(this.params,t):`\\href{#def-${this.name}}{${i.default.makeTeXName(this.name)}}`:(this.precedence=i.default.PREC_FUNEXPR,[this.shouldConsolidate(t)?"\\left(":"",1==this.params.length?this.params[0].toTeXString(!1):`\\left(${this.params.map((t=>t.toTeXString(i.default.PREC_COMMA))).join(", ")}\\right)`,"\\mapsto ",this.expr.expandMeta(!0).toTeXString(!1),this.shouldConsolidate(t)?"\\right)":""].join(""))}funcallToTeXString(t,e){return t=t.map((t=>t.toTeXString(this.tex?this.precedence:i.default.PREC_COMMA))),this.tex?this.makeTeX("def-"+this.name,t,e):(this.name?`\\href{#def-${this.name}}{${i.default.makeTeXName(this.name)}}`:this.toTeXString(!1))+`\\mathord{\\left(${t.join(", ")}\\right)}`}}e.default=ObjectFun},function(t,e,r){"use strict";var n=this&&this.__importDefault||function(t){return t&&t.__esModule?t:{default:t}};Object.defineProperty(e,"__esModule",{value:!0});const a=n(r(0));class Type extends a.default{constructor(t,e,r,n){super(t,e,r),this.isFunctional=n,this.isSimple=!n}}e.default=Type},function(t,e,r){"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.isNameable=void 0,e.isNameable=function isNameable(t){return"name"in t}},function(t,e,r){"use strict";var n=this&&this.__createBinding||(Object.create?function(t,e,r,n){void 0===n&&(n=r),Object.defineProperty(t,n,{enumerable:!0,get:function(){return e[r]}})}:function(t,e,r,n){void 0===n&&(n=r),t[n]=e[r]}),a=this&&this.__setModuleDefault||(Object.create?function(t,e){Object.defineProperty(t,"default",{enumerable:!0,value:e})}:function(t,e){t.default=e}),i=this&&this.__importStar||function(t){if(t&&t.__esModule)return t;var e={};if(null!=t)for(var r in t)"default"!==r&&Object.prototype.hasOwnProperty.call(t,r)&&n(e,t,r);return a(e,t),e},s=this&&this.__importDefault||function(t){return t&&t.__esModule?t:{default:t}};Object.defineProperty(e,"__esModule",{value:!0});const o=s(r(5)),l=i(r(1)),u=s(r(9)),f=s(r(0)),h=s(r(2));class Tee extends l.default{constructor({left:t,def$s:e,right:r},n){if(!(t instanceof Array&&t.every((t=>t.type instanceof h.default||t.type instanceof u.default))))throw console.log(t),f.default.error("Assertion failed",n);if(e&&!(e instanceof Array&&e.every((t=>t instanceof o.default))))throw f.default.error("Assertion failed",n);if(!(r.type instanceof h.default||r.type instanceof u.default))throw console.log(r),f.default.error("Assertion failed",n);if(r.type.isFunctional)throw f.default.error("RHS of a rule cannot be a schema",n);super(n,null,null,new u.default({functional:!1,left:t.map((t=>t.type)),right:r.type})),this.left=t,this.def$s=e||[],this.right=r,this.precedence=f.default.PREC_COMMA}isProvedInternal(t){return this.right.isProved(t.concat(this.left))}substitute(t){var e=this.left.map((e=>e.substitute(t))),r=this.right.substitute(t);return new Tee({left:e,def$s:null,right:r},this.trace)}expandMetaInternal(t){var e=this.left.map((e=>e.expandMeta(t))),r=this.right.expandMeta(t);return new Tee({left:e,def$s:null,right:r},this.trace)}getEqualsPriority(){return l.EqualsPriority.TWO}equalsInternal(t,e){if(!(t instanceof Tee))throw Error("Assertion failed");if(this.left.length!=t.left.length)throw Error("Assertion failed");for(var r=0;r<this.left.length;r++)if(!this.left[r].equals(t.left[r],e))return!1;return this.right.equals(t.right,e)}getProofInternal(t,e,r){t=new Map(t);var n=r.peek()+1,a=this.left.map((e=>(t.set(e,r.next()),{_type:"H",ctr:r.peek(),expr:e})));return e=new Map(e),[{_type:"T",leftlines:a,rightlines:this.def$s.map((n=>{var a=n.expr.getProof(t,e,r),i=a[a.length-1].ctr;return e.set(n,i),a})).flat(1).concat(this.right.getProof(t,e,r)),ctr:[n,r.peek()]}]}toIndentedString(t,e){return this.left.length?["\t"+this.left.map((e=>e.toIndentedString(t+1))).join(",\n"+"\t".repeat(t+1)),"|-","\t"+this.right.toIndentedString(t+1)].join("\n"+"\t".repeat(t)):"|- "+this.right.toIndentedString(t)}toTeXString(t,e){var r=this.expandMeta(!0);return[this.shouldConsolidate(t)?"\\left(":"",`{${r.left.map((t=>t.toTeXString(f.default.PREC_COMMA))).join(", ")} \\vdash ${r.right.toTeXString(f.default.PREC_COMMA)}}`,this.shouldConsolidate(t)?"\\right)":""].join("")}}e.default=Tee},function(t,e,r){var n;n=r(16).default;var a=r(17).default;t.exports={grammar:n,Program:a}},function(t,e,r){"use strict";r.r(e),e.default='start =\n\t_\n\timports:(i:import _ {return i})*\n\tlines:(a:line _ {return a})*\n\t{return imports.concat(lines)}\n\nline =\n\ttypedef\n\t/ defv\n\t/ defun\n\t/ defschema\n\nevaluable =\n\t_ e:evaluable_internal _ {return e}\n\nevaluable_internal =\n\ttypedef\n\t/ defv\n\t/ defun\n\t/ defschema\n\t/ metaexpr\n\nimport =\n\t\'import\' __\n\tfilename:ident _\n\tsem\n\t{\n\t\treturn {\n\t\t\t_type: \'import\',\n\t\t\tfilename,\n\t\t\tlocation: location()\n\t\t}\n\t}\n\ntypedef =\n\tdoc:(documentation __)?\n\tbase:("base" __)?\n\t"type" __\n\torigin:(o:ftype __ {return o})?\n\tname:ident _ sem\n\t{\n\t\treturn {\n\t\t\t_type: \'typedef\',\n\t\t\tdoc: doc ? doc[0] : null,\n\t\t\tbase: !!base,\n\t\t\torigin,\n\t\t\tname,\n\t\t\tlocation: location()\n\t\t}\n\t}\n\ndefv =\n\tdoc:(documentation __)?\n\ttex:(tex __)?\n\tsealed:(\'sealed\' __)?\n\ttype:type __\n\tname:ident _\n\texpr:(\n\t\t"=" _\n\t\texpr:expr0 _\n\t\tsem\n\t\t{return expr}\n\t\t/ sem {return null}\n\t)\n\t{\n\t\treturn {\n\t\t\t_type: \'defv\',\n\t\t\tisParam: false,\n\t\t\tdoc: doc ? doc[0] : null,\n\t\t\ttex: tex ? tex[0] : null,\n\t\t\tsealed: !!sealed,\n\t\t\ttype,\n\t\t\tname,\n\t\t\texpr,\n\t\t\tlocation: location()\n\t\t}\n\t}\n\ndefparam =\n\ttex:(tex __)? type:type __ name:ident\n\t{\n\t\treturn {\n\t\t\t_type: \'defv\',\n\t\t\tisParam: true,\n\t\t\tdoc: null,\n\t\t\ttex: tex ? tex[0] : null,\n\t\t\ttype,\n\t\t\tname,\n\t\t\tlocation: location()\n\t\t}\n\t}\n\ndefschemaparam =\n\ttex:(tex __)? type:type __ name:ident\n\tselector:(_ \':\' _ \'@\' g:$[a-z0-9_]+ {return g})?\n\t{\n\t\treturn {\n\t\t\t_type: \'defv\',\n\t\t\tisParam: true,\n\t\t\tdoc: null,\n\t\t\ttex: tex ? tex[0] : null,\n\t\t\ttype,\n\t\t\tname,\n\t\t\tselector,\n\t\t\tlocation: location()\n\t\t}\n\t}\n \ndefun =\n\tdoc:(documentation __)?\n\ttex:(tex __)?\n\tsealed:(\'sealed\' __)?\n\trettype:type __\n\tname:ident _\n\tparams:(\n\t\t"(" _\n\t\tp:(\n\t\t\thead:defparam _\n\t\t\ttail:("," _ tv:defparam _ {return tv})*\n\t\t\t{return [head].concat(tail)}\n\t\t)?\n\t\t")" _\n\t\t{return p || []}\n\t)\n\texpr:(\n\t\t"{" _\n\t\texpr:expr0 _\n\t\t"}"\n\t\t{return expr}\n\t\t/ sem {return null}\n\t)\n\t{\n\t\treturn {\n\t\t\t_type: \'defun\',\n\t\t\tdoc: doc ? doc[0] : null,\n\t\t\ttex: tex ? tex[0] : null,\n\t\t\tsealed: !!sealed,\n\t\t\trettype,\n\t\t\tname,\n\t\t\tparams,\n\t\t\texpr,\n\t\t\tlocation: location()\n\t\t}\n\t}\n\ndefschema =\n\tdoc:(documentation __)?\n\tannotations: (a:annotation __ {return a})*\n\tschemaType:(\'axiom\' / \'theorem\' / \'schema\') __\n\tname:ident _\n\tparams:(\n\t\t"(" _\n\t\tp:(\n\t\t\thead:defschemaparam _\n\t\t\ttail:("," _ tv:defschemaparam _ {return tv})*\n\t\t\t{return [head].concat(tail)}\n\t\t)?\n\t\t")" _\n\t\t{return p || []}\n\t)\n\tusing:(\n\t\t\'using\' __\n\t\tx:(\n\t\t\thead:ident _\n\t\t\ttail:(\',\' _ n:ident _ {return n})*\n\t\t\t{return [head].concat(tail)}\n\t\t)\n\t\t{return x}\n\t)?\n\t"{" _\n\tdefdollars: (d:defdollar _ {return d})* _\n\texpr:metaexpr _\n\t"}"\n\t{\n\t\treturn {\n\t\t\t_type: \'defschema\',\n\t\t\tdoc: doc ? doc[0] : null,\n\t\t\tannotations,\n\t\t\tschemaType,\n\t\t\tname,\n\t\t\tparams,\n\t\t\tusing: using || [],\n\t\t\tdef$s: defdollars,\n\t\t\texpr,\n\t\t\tlocation: location()\n\t\t}\n\t}\n\n// var[...]\n// foo(...)[...]\n// foo[...][...]\n// (metaexpr)[...]\n// schema(?, ...)[...]\nreduction =\n\tsubject:(\n\t\tschemacall\n\t\t/ var\n\t\t/ "(" _\n\t\te:metaexpr _\n\t\t")"\n\t\t{return e}\n\t) _\n\targs:(\n\t\t"(" _\n\t\ta:(\n\t\t\thead:(\'?\' {return null} / expr0) _\n\t\t\ttail:("," _ e:(\'?\' {return null} / expr0) _ {return e})*\n\t\t\t{return [head].concat(tail)}\n\t\t)?\n\t\t")"\n\t\t{return a || []}\n\t)?\n\tleftargs:(\n\t\t"[" _\n\t\ta:(\n\t\t\thead:metaexpr _\n\t\t\ttail:(";" _ e:metaexpr _ {return e})*\n\t\t\t{return [head].concat(tail)}\n\t\t)?\n\t\t"]"\n\t\tb:(\n\t\t\t_ \'[\' _\n\t\t\t\'as\' __\n\t\t\tm:metaexpr _\n\t\t\t\']\'\n\t\t\t{return m}\n\t\t)?\n\t\t{return {a: a || [], b: b || null}}\n\t)+\n\t{\n\t\tvar ret = {\n\t\t\t_type: \'reduction\',\n\t\t\tsubject,\n\t\t\targs,\n\t\t\tleftargs: leftargs[0].a,\n\t\t\tas: leftargs[0].b,\n\t\t\tlocation: location()\n\t\t};\n\n\t\tfor (var i = 1; i < leftargs.length; i++) {\n\t\t\tret = {\n\t\t\t\t_type: \'reduction\',\n\t\t\t\tsubject: ret,\n\t\t\t\targs: null,\n\t\t\t\tleftargs: leftargs[i].a,\n\t\t\t\tas: leftargs[i].b,\n\t\t\t\tlocation: location()\n\t\t\t};\n\t\t}\n\n\t\treturn ret;\n\t}\n\n// var(...)\n// (metaexpr)(...)\nschemacall =\n\tschema:(\n\t\tvar\n\t\t/ "(" _ e:metaexpr _ ")"\n\t\t{return e}\n\t) _\n\targs:(\n\t\t"(" _\n\t\ta:(\n\t\t\thead:expr0 _\n\t\t\ttail:("," _ e:expr0 _ {return e})*\n\t\t\t{return [head].concat(tail)}\n\t\t)?\n\t\t")"\n\t\t{return a || []}\n\t)\n\t{\n\t\treturn {\n\t\t\t_type: \'schemacall\',\n\t\t\tschema,\n\t\t\targs,\n\t\t\tlocation: location()\n\t\t}\n\t}\n\n// forall(f, g)\n// (expr0)(f, g)\nfuncall =\n\tschema:(\n\t\tvar\n\t\t/ "(" _\n\t\te:expr0 _\n\t\t")"\n\t\t{return e}\n\t) _\n\targs:(\n\t\t"(" _\n\t\ta:(\n\t\t\thead:expr0 _\n\t\t\ttail:("," _ e:expr0 _ {return e})*\n\t\t\t{return [head].concat(tail)}\n\t\t)?\n\t\t")"\n\t\t{return a || []}\n\t)\n\t{\n\t\treturn {\n\t\t\t_type: \'funcall\',\n\t\t\tschema,\n\t\t\targs,\n\t\t\tlocation: location()\n\t\t}\n\t}\n\n// (T t) => expr0\n// (T t) => { expr0 }\nfunexpr =\n\tparams:(\n\t\t"(" _\n\t\tp:(\n\t\t\thead:defparam _\n\t\t\ttail:("," _ tv:defparam _ {return tv})*\n\t\t\t{return [head].concat(tail)}\n\t\t)?\n\t\t")" _\n\t\t{return p || []}\n\t)\n\t"=>" _\n\texpr:(\n\t\texpr0\n\t\t/ "{" _ e:expr0 _ "}" {return e}\n\t)\n\t{\n\t\treturn {\n\t\t\t_type: \'funexpr\',\n\t\t\tparams,\n\t\t\texpr,\n\t\t\tlocation: location()\n\t\t}\n\t}\n\n// (T t) => metaexpr_internal_1\n// (T t) => { $foo = ...; metaexpr }\nschemaexpr =\n\tparams:(\n\t\t"(" _\n\t\tp:(\n\t\t\thead:defparam _\n\t\t\ttail:("," _ tv:defparam _ {return tv})*\n\t\t\t{return [head].concat(tail)}\n\t\t)?\n\t\t")" _\n\t\t{return p || []}\n\t)\n\t"=>" _\n\tfoo:(\n\t\texpr:metaexpr_internal_1\n\t\t{return {defdollars: [], expr}}\n\t\t/ "{" _\n\t\tdefdollars: (d:defdollar _ {return d})* _\n\t\texpr:metaexpr _\n\t\t"}"\n\t\t{return {defdollars, expr}}\n\t)\n\t{\n\t\treturn {\n\t\t\t_type: \'schemaexpr\',\n\t\t\tparams,\n\t\t\tdef$s: foo.defdollars,\n\t\t\texpr: foo.expr,\n\t\t\tlocation: location()\n\t\t}\n\t}\n\ntee =\n\tleft:(\n\t\tl:(\n\t\t\thead:metaexpr_internal_1 _\n\t\t\ttail:("," _ e:metaexpr_internal_1 _ {return e})*\n\t\t\t{return [head].concat(tail)}\n\t\t)? {return l || []}\n\t)\n\t"|-" _\n\tfoo:(\n\t\texpr:metaexpr_internal_0\n\t\t{return {defdollars: [], expr}}\n\t\t/ "{" _\n\t\tdefdollars: (d:defdollar _ {return d})* _\n\t\texpr:metaexpr _\n\t\t"}"\n\t\t{return {defdollars, expr}}\n\t)\n\t{\n\t\treturn {\n\t\t\t_type: \'tee\',\n\t\t\tdef$s: foo.defdollars,\n\t\t\tleft,\n\t\t\tright: foo.expr,\n\t\t\tlocation: location()\n\t\t}\n\t}\n\nwith =\n\t\'with\' _ \'(\' _\n\ttex:(tex __)?\n\ttype:type __\n\tvarname:ident _\n\t"=" _\n\tvarexpr:expr0 _\n\t\')\' _ \'{\' _\n\tdefdollars: (d:defdollar _ {return d})* _\n\texpr:metaexpr _\n\t\'}\'\n\t{\n\t\treturn {\n\t\t\t_type: \'with\',\n\t\t\twith: {\n\t\t\t\t_type: \'defv\',\n\t\t\t\tisParam: false,\n\t\t\t\tdoc: null,\n\t\t\t\ttex: tex ? tex[0] : null,\n\t\t\t\tsealed: false,\n\t\t\t\ttype,\n\t\t\t\tname: varname,\n\t\t\t\texpr: varexpr,\n\t\t\t\tlocation: location()\n\t\t\t},\n\t\t\tdef$s: defdollars,\n\t\t\texpr,\n\t\t\tlocation: location()\n\t\t}\n\t}\n\nmetaexpr =\n\tmetaexpr_internal_0\n\nmetaexpr_internal_0 =\n\ttee\n\t/ metaexpr_internal_1\n\n/*\n * 다음이 성립하여야 한다.\n *\n * - reduction이 schemacall보다 앞이다.\n * - schemacall이 var보다 앞이다.\n *\n */\nmetaexpr_internal_1 =\n\treduction\n\t/ schemacall\n\t/ var\n\t/ schemaexpr\n\t/ with\n\t/ "(" _ e:metaexpr _ ")" {return e}\n\nexpr0 =\n\tfuncall\n\t/ funexpr\n\t/ var\n\t/ "(" _ e:expr0 _ ")" {return e}\n\ndefdollar =\n\tname:dollar_ident _\n\t\'=\' _\n\texpr:metaexpr _\n\tsem\n\t{\n\t\treturn {\n\t\t\t_type: \'def$\',\n\t\t\tname,\n\t\t\texpr,\n\t\t\tlocation: location()\n\t\t};\n\t}\n\ntype =\n\tstype\n\t/ ftype\n\nstype =\n\tname:ident\n\t{\n\t\treturn {\n\t\t\t_type: \'type\',\n\t\t\tftype: false,\n\t\t\tname,\n\t\t\tlocation: location()\n\t\t}\n\t}\n\nftype =\n\t"[" _\n\tfrom:(\n\t\ttype:type {return [type]}\n\t\t/ (\n\t\t\ttt:(\n\t\t\t\t"(" _\n\t\t\t\thead: type\n\t\t\t\ttail:(_ "," _ t:type {return t})*\n\t\t\t\t_ ")"\n\t\t\t\t{return [head].concat(tail)}\n\t\t\t)\n\t\t\t{return tt}\n\t\t)\n\t) _\n\t"->" _\n\tto:type _\n\t"]"\n\t{\n\t\treturn {\n\t\t\t_type: \'type\',\n\t\t\tftype: true,\n\t\t\tfrom,\n\t\t\tto,\n\t\t\tlocation: location()\n\t\t}\n\t}\n\nvar =\n\tat_var\n\t/ dollar_var\n\t/ plain_var\n\nat_var =\n\tname:at_ident\n\t{\n\t\treturn {\n\t\t\t_type: \'var\',\n\t\t\ttype: \'@\',\n\t\t\tname: name.slice(1),\n\t\t\tlocation: location()\n\t\t}\n\t}\n\ndollar_var =\n\tname:dollar_ident\n\t{\n\t\treturn {\n\t\t\t_type: \'var\',\n\t\t\ttype: \'$\',\n\t\t\tname: name,\n\t\t\tlocation: location()\n\t\t}\n\t}\n\nplain_var =\n\tname:ident\n\t{\n\t\treturn {\n\t\t\t_type: \'var\',\n\t\t\ttype: \'normal\',\n\t\t\tname,\n\t\t\tlocation: location()\n\t\t}\n\t}\n\nkeyword =\n\t\'as\'\n\t/ \'axiom\'\n\t/ \'base\'\n\t/ \'import\'\n\t/ \'schema\'\n\t/ \'sealed\'\n\t/ \'type\'\n\t/ \'using\'\n\t/ \'with\'\n\nannotation =\n\t\'@discouraged\'\n\t/ \'@deprecated\'\n\nident =\n\t$(!(keyword ![a-zA-Z0-9_]) [a-zA-Z0-9_]+)\n\nat_ident =\n\t$(\'@\' [a-zA-Z0-9_]+)\n\ndollar_ident =\n\t$(\'$\' [a-zA-Z0-9_]+)\n\ndocumentation =\n\t\'"\' b:$(!\'"\' a:. {return a})* \'"\' {\n\t\treturn b\n\t}\n\ntex =\n\t\'$\' b:$(!\'$\' a:. {return a})* \'$\' {\n\t\treturn b\n\t}\n\ncomment =\n\t"//" (!newline .)*\n\t/ "/*" (!"*/" .)* "*/"\n\nnewline =\n\t"\\r\\n" / "\\r" / "\\n"\n\n// optional whitespace\n_ =\n\t([ \\t\\n\\r] / comment)*\n\n// mandatory whitespace\n__ =\n\t([ \\t\\n\\r] / comment)+\n\nsem =\n\t";"'},function(t,e,r){"use strict";var n=this&&this.__awaiter||function(t,e,r,n){return new(r||(r=Promise))((function(a,i){function fulfilled(t){try{step(n.next(t))}catch(t){i(t)}}function rejected(t){try{step(n.throw(t))}catch(t){i(t)}}function step(t){t.done?a(t.value):function adopt(t){return t instanceof r?t:new r((function(e){e(t)}))}(t.value).then(fulfilled,rejected)}step((n=n.apply(t,e||[])).next())}))},a=this&&this.__importDefault||function(t){return t&&t.__esModule?t:{default:t}};Object.defineProperty(e,"__esModule",{value:!0});const i=a(r(18)),s=a(r(22)),o=a(r(24));e.default=class Program{constructor(t){if(this.scopeMap=new Map,!t)throw Error("no");this.parser=t}loadModule(t,e){return n(this,void 0,void 0,(function*(){return this.loadingModules=[],this.scope=yield this.loadModuleInternal(t,e)}))}loadModuleInternal(t,e){return n(this,void 0,void 0,(function*(){if(this.scopeMap.has(t))return this.scopeMap.get(t);var r=this.loadingModules.indexOf(t);if(r>=0){if(r==this.loadingModules.length-1)throw Error(`Cannot self import (${t})`);var n=this.loadingModules.slice(r).concat(t);throw Error(`Circular import detected (${n.join(" -> ")}). Sadly, circular import is currently not supported.`)}this.loadingModules.push(t);var{fileUri:a,code:i}=yield e(t),s=new o.default(a,null),l=this.parser.parse(i);if(yield this.feed(l,s,e),this.loadingModules.pop()!=t)throw Error("Something's wrong");return this.scopeMap.set(t,s),s}))}feed(t,e=this.scope,r){return n(this,void 0,void 0,(function*(){for(var n=0;n<t.length;n++){var a=t[n];switch(a._type){case"import":var s=yield this.loadModuleInternal(a.filename,r);e.importMap.set(a.filename,s);break;case"typedef":var o=i.default.type(a,e);if(e.hasType(o.name))throw e.error(`Type ${o.name} has already been declared`);e.addType(o);break;case"defv":var l=i.default.variable(a,e);if(e.hasVariable(l.name))throw e.error(`Definition ${l.name} has already been declared`);e.addVariable(l);break;case"defun":var u=i.default.fun(a,e);if(e.hasVariable(u.name))throw e.error(`Definition ${u.name} has already been declared`);e.addFun(u);break;case"defschema":var f=i.default.schema(a,e,null);if(e.hasSchema(f.name))throw e.error(`Schema ${f.name} has already been declared`);e.addSchema(f);break;default:throw Error("Unknown line type "+a._type)}}}))}evaluate(t){var e=new o.default("<repl>",this.scope);switch(t._type){case"typedef":return i.default.type(t,e);case"defv":return i.default.variable(t,e);case"defun":return i.default.fun(t,e);case"defschema":case"schemaexpr":return i.default.schema(t,e,null);case"tee":return i.default.tee(t,e,null);case"reduction":return i.default.reduction(t,e,null);case"schemacall":return i.default.schemacall(t,e,null);case"var":return i.default.metavar(t,e);default:throw Error("Unknown line type "+t._type)}}getProofExplorer(t,e){return s.default.get(this.scope,t,e)}}},function(t,e,r){"use strict";var n=this&&this.__importDefault||function(t){return t&&t.__esModule?t:{default:t}};Object.defineProperty(e,"__esModule",{value:!0});const a=n(r(19)),i=n(r(5)),s=n(r(7)),o=n(r(11)),l=n(r(2)),u=n(r(10)),f=n(r(20)),h=n(r(6)),d=n(r(14)),c=n(r(4)),p=n(r(21));function typeObjToString(t){if("type"!=t._type)throw Error("Assertion failed");return t.ftype?"["+t.from.map(typeObjToString).join(", ")+" -> "+typeObjToString(t.to)+"]":t.name}function typeObjToNestedArr(t){if("type"!=t._type)throw Error("Assertion failed");if(t.ftype){if(!t.from||!t.to)throw Error("Assertion failed");return t.from.map(typeObjToNestedArr).concat([typeObjToNestedArr(t.to)])}if(!(t=t).name)throw Error("Assertion failed");return t.name}function varObjToString(t){switch(t.type){case"@":return"@"+t.name;case"$":case"normal":return""+t.name;default:throw Error("Unknown type "+t.type)}}class PI{static type(t,e){if("typedef"!=t._type)throw Error("Assertion failed");var r=e.extend("type",t.name,t.location),n=t.origin?r.getType(typeObjToNestedArr(t.origin)):null,a=t.name,i=t.doc,s=t.base;if(s&&n)throw r.error("Base type should not be an alias");return n?new l.default({name:a,doc:i,base:s,origin:n}):new l.default({functional:!1,name:a,doc:i,base:s})}static variable(t,e){if(!["defv","var"].includes(t._type))throw Error("Assertion failed");var r=e.extend("variable",t.name,t.location);if("var"==t._type){if("normal"!=t.type)throw r.error(`Variable type ${t.type} not allowed`);if(!r.hasVariable(t.name))throw r.error("Undefined identifier "+varObjToString(t));return r.getVariable(t.name)}if(!r.hasType(typeObjToNestedArr(t.type)))throw r.error(`Type ${typeObjToString(t.type)} is not defined`);var n=r.getType(typeObjToNestedArr(t.type)),a=t.expr?PI.expr0(t.expr,r):null;return t.isParam?new u.default({doc:t.doc,tex:t.tex,type:n,name:t.name,selector:t.selector||null},r.trace):new c.default({doc:t.doc,tex:t.tex,sealed:!!t.sealed,type:n,name:t.name,expr:a||null},r.trace)}static fun(t,e){if("defun"!=t._type&&"funexpr"!=t._type)throw Error("Assertion failed");var r=e.extend("fun","defun"==t._type?t.name:"<anonymous>",t.location),n=null,a=null,i=!1,s=null,l=null,f=null;if("defun"==t._type){if(n=t.doc,a=t.tex,i=t.sealed,!r.hasType(typeObjToNestedArr(t.rettype)))throw r.error(`Type ${typeObjToString(t.rettype)} is not defined`);s=r.getType(typeObjToNestedArr(t.rettype)),l=t.name}var h=t.params.map((t=>{var e=PI.variable(t,r);if(r.hasOwnVariable(e.name))throw r.error(`Parameter ${e.name} has already been declared`);if(!(e instanceof u.default))throw Error("Something's wrong");return r.addVariable(e),e}));return t.expr&&(f=PI.expr0(t.expr,r)),new o.default({annotations:[],sealed:i,rettype:s,name:l,params:h,expr:f,doc:n,tex:a},r.trace)}static funcall(t,e){if("funcall"!=t._type)throw Error("Assertion failed");var r=e.extend("funcall","name"in t.schema?t.schema.name:null,t.location),n=PI.expr0(t.schema,r),a=t.args.map((t=>PI.expr0(t,r)));return new s.default({fun:n,args:a},r.trace)}static metaexpr(t,e,r){if(!["tee","reduction","schemacall","schemaexpr","var","with"].includes(t._type))throw Error("Assertion failed");var n=e;switch(t._type){case"tee":return PI.tee(t,n,r);case"reduction":return PI.reduction(t,n,r);case"schemacall":return PI.schemacall(t,n,r);case"schemaexpr":return PI.schema(t,n,r);case"var":return PI.metavar(t,n);case"with":return PI.with(t,n,r);default:throw Error("wut")}}static expr0(t,e){if(!["funcall","funexpr","var"].includes(t._type))throw console.log(t),Error("Assertion failed");var r=e;switch(t._type){case"funcall":return PI.funcall(t,r);case"funexpr":return PI.fun(t,r);case"var":return PI.variable(t,r);default:throw Error("wut")}}static metavar(t,e){if("var"!=t._type)throw Error("Assertion failed");var r=e;switch(t.type){case"@":if(t.name.match(/^h[0-9]+$/)){var n=Number(t.name.slice(1))-1;if(n>=r.hypotheses.length)throw r.error(`Hypothesis #${n+1} not found`);return r.hypotheses[n]}throw r.error("Unknown selector query "+varObjToString(t));case"$":if(!r.has$(t.name))throw r.error(varObjToString(t)+" is not defined");return r.get$(t.name);case"normal":if(!r.hasSchema(t.name))throw r.error(`Schema ${varObjToString(t)} is not defined`);return r.getSchema(t.name);default:throw r.error("Unknown type "+t.type)}}static with(t,e,r){if("with"!=t._type)throw Error("Assertion failed");var n=e.extend("with",null,t.location),a=PI.variable(t.with,n);if(n.hasOwnVariable(a.name))throw n.error(`Parameter ${a.name} has already been declared`);if(!(a instanceof c.default))throw Error("Something's wrong");n.addVariable(a);var i=t.def$s.map((t=>{var e=PI.def$(t,n,r);if(n.hasOwn$(e.name))throw n.error(t.name+" has already been declared");return n.add$(e)})),s=PI.metaexpr(t.expr,n,r);return new p.default({variable:a,def$s:i,expr:s},n.trace)}static tee(t,e,r){if("tee"!=t._type)throw Error("Assertion failed");var n=e.extend("tee",null,t.location),a=t.left.map((t=>PI.metaexpr(t,n,r))),i=n.extend("tee.right",null,t.right.location);a.forEach((t=>i.hypotheses.push(t)));var s=t.def$s.map((t=>{var e=PI.def$(t,i,r);if(i.hasOwn$(e.name))throw i.error(t.name+" has already been declared");return i.add$(e)})),o=PI.metaexpr(t.right,i,r);return new d.default({left:a,def$s:s,right:o},n.trace)}static def$(t,e,r){if("def$"!=t._type)throw Error("Assertion failed");var n=e.extend("def$",t.name,t.location),a=PI.metaexpr(t.expr,n,r);return new i.default({name:t.name,expr:a},n.trace)}static schema(t,e,r){if("defschema"!=t._type&&"schemaexpr"!=t._type)throw Error("Assertion failed");var n="defschema"==t._type?t.name:null,i=e.extend("schema",n,t.location),s="schema",o=null,l=[],f=r;if("defschema"==t._type){if(s=t.schemaType,o=t.doc,l=t.annotations,r)throw console.log(r),Error("duh");var d=t.using.map((t=>{if(!i.hasVariable(t))throw i.error(`Variable ${t} is not defined`);var e=i.getVariable(t);if(!e.expr)throw i.error(t+" is not a macro");return e}));f=new a.default(d)}var c=t.params.map((t=>{var e=PI.variable(t,i);if(i.hasOwnVariable(e.name))throw i.error(`Parameter ${e.name} has already been declared`);if(!(e instanceof u.default))throw Error("Something's wrong");return i.addVariable(e),e})),p=t.def$s.map((t=>{var e=PI.def$(t,i,f);if(i.hasOwn$(e.name))throw i.error(t.name+" has already been declared");return i.add$(e)})),m=PI.metaexpr(t.expr,i,f);return new h.default({doc:o,tex:null,annotations:l,schemaType:s,name:n,params:c,context:f,def$s:p,expr:m},i.trace)}static schemacall(t,e,r){if("schemacall"!=t._type)throw Error("Assertion failed");var n=e.extend("schemacall","name"in t.schema?t.schema.name:null,t.location),a=PI.metaexpr(t.schema,n,r),i=t.args.map((t=>PI.expr0(t,n)));return new s.default({fun:a,args:i},n.trace)}static reduction(t,e,r){if("reduction"!=t._type)throw Error("Assertion failed");if(!r)throw Error("duh");var n=e.extend("reduction","name"in t.subject?t.subject.name:null,t.location),a=PI.metaexpr(t.subject,n,r),i=t.args?t.args.map((t=>t&&PI.expr0(t,n))):null,s=t.leftargs.map((t=>PI.metaexpr(t,n,r))),o=t.as&&PI.metaexpr(t.as,n,r);return new f.default({subject:a,args:i,leftargs:s,as:o},r,n.trace)}}e.default=PI},function(t,e,r){"use strict";Object.defineProperty(e,"__esModule",{value:!0});e.default=class ExecutionContext{constructor(t){this.usingList=t||[]}canUse(t){return this.usingList.includes(t)}}},function(t,e,r){"use strict";var n=this&&this.__createBinding||(Object.create?function(t,e,r,n){void 0===n&&(n=r),Object.defineProperty(t,n,{enumerable:!0,get:function(){return e[r]}})}:function(t,e,r,n){void 0===n&&(n=r),t[n]=e[r]}),a=this&&this.__setModuleDefault||(Object.create?function(t,e){Object.defineProperty(t,"default",{enumerable:!0,value:e})}:function(t,e){t.default=e}),i=this&&this.__importStar||function(t){if(t&&t.__esModule)return t;var e={};if(null!=t)for(var r in t)"default"!==r&&Object.prototype.hasOwnProperty.call(t,r)&&n(e,t,r);return a(e,t),e},s=this&&this.__importDefault||function(t){return t&&t.__esModule?t:{default:t}};Object.defineProperty(e,"__esModule",{value:!0});const o=s(r(3)),l=s(r(7)),u=i(r(1)),f=s(r(9)),h=r(13),d=s(r(0)),c=s(r(14)),p=s(r(4));class Reduction extends u.default{constructor({subject:t,args:e,leftargs:r,as:n},a,i){if(e){let r=t.type.resolve().from,n=e.map((t=>t&&t.type));if(r.length!=n.length)throw d.default.error(`Invalid number of arguments (expected ${r.length}): ${n.length}`,i);for(var s=0;s<r.length;s++)if(n[s]&&!r[s].equals(n[s]))throw d.default.error(`Argument #${s+1} has illegal argument type (expected ${r[s]}): ${n[s]}`,i)}if(t instanceof o.default){t.params.forEach(((t,r)=>{if(!(e&&e[r]||t.selector))throw d.default.error(`Argument #${r+1} could not be guessed`,i)}));var u=t.params.map(((s,o)=>{if(e&&e[o])return e[o];var l=t.expr.expandMeta(!1);return Reduction.guess(s.selector,l.left,r,l.right,n,a,i)}));t=new l.default({fun:t,args:u},i)}else if(e)throw d.default.error("Something's wrong",i);if(!(t.type instanceof f.default&&t.type.isSimple))throw d.default.error("Subject is not reducible",i);if(!(r instanceof Array)||r.map((t=>t instanceof d.default)).some((t=>!t)))throw d.default.error("Assertion failed",i);var h=t.type.left,p=r.map((t=>t.type));if(h.length!=p.length)throw d.default.error(`Invalid number of arguments (expected ${h.length}): ${p.length}`,i);for(let t=0;t<h.length;t++)if(!h[t].equals(p[t]))throw d.default.error(`Illegal argument type (expected ${h[t]}): ${p[t]}`,i);super(i,null,null,t.type.right),this.subject=t,this.leftargs=r;var m=t.expandMeta(!0);if(!(m instanceof c.default))throw d.default.error("Assertion failed",i);var _=r.map((t=>t.expandMeta(!0)));for(let t=0;t<m.left.length;t++)if(!m.left[t].equals(_[t],a))throw d.default.error(`LHS #${t+1} failed to match:\n\n--- EXPECTED ---\n${m.left[t].expandMeta(!0)}\n----------------\n\n--- RECEIVED ---\n${r[t].expandMeta(!0)}\n----------------`,i);if(n){if(!m.right.equals(n,a))throw d.default.error(`RHS failed to match:\n\n--- EXPECTED ---\n${m.right.expandMeta(!0)}\n----------------\n\n--- RECEIVED (from [as ...]) ---\n${n.expandMeta(!0)}\n----------------`,i);this.reduced=n}else this.reduced=m.right}isProvedInternal(t){return this.subject.isProved(t)&&this.leftargs.every((e=>e.isProved(t)))}substitute(t){return this.reduced.substitute(t)}expandMetaInternal(t){return this.reduced.expandMeta(t)}getEqualsPriority(){return u.EqualsPriority.FIVE}equalsInternal(t,e){return this.reduced.equals(t,e)}static guess(t,e,r,n,a,i,s){if(0==t.length)throw d.default.error("wut",s);var o,u;if("r"==t[0]){if(!a)throw d.default.error(`Cannot dereference @${t}: expected output is not given`,s);o=n,u=a}else{var f=Number(t[0]);if(!(1<=f&&f<=r.length))throw d.default.error(`Cannot dereference @${t}: antecedent index out of range`,s);o=e[f-1],u=r[f-1]}return function recurse(e,r,n){if(n=n.expandMeta(!0),t.length<=e)return n;if(/^[0-9]$/.test(t[e])){var a=Number(t[e]);if(r instanceof c.default&&n instanceof c.default){if(r.left.length!=n.left.length)throw d.default.error(`Cannot dereference @${t}: antecedent length mismatch`,s);if(!(1<=a&&a<=n.left.length))throw d.default.error(`Cannot dereference @${t}: antecedent index out of range`,s);return recurse(e+1,r.left[a-1],n.left[a-1])}for(;;){for(;n instanceof p.default&&n.expr;)n=n.expr;if(!(r instanceof l.default&&n instanceof l.default))throw d.default.error("Cannot dereference @"+t,s);if(r.fun.equals(n.fun,i))break;if(!n.isExpandable(i))throw d.default.error("Cannot dereference @"+t,s);n=n.expandOnce(i)}if(!(1<=a&&a<=n.args.length))throw d.default.error("Cannot dereference @"+t,s);return recurse(e+1,r.args[a-1],n.args[a-1])}if("r"==t[e]){if(r instanceof c.default&&n instanceof c.default)return recurse(e+1,r.right,n.right);throw d.default.error("Cannot dereference @"+t,s)}throw d.default.error("Cannot dereference @"+t,s)}(1,o,u)}getProofInternal(t,e,r){var n,a=[],i=this.leftargs.map((n=>{if(t.has(n))return t.get(n);if(e.has(n))return e.get(n);var i=n.getProof(t,e,r);return a=a.concat(i),i[i.length-1].ctr})),s=null,u=[],f=t.get(this.subject)||e.get(this.subject)||!!(this.subject instanceof l.default&&e.has(this.subject.fun))&&(s=this.subject.args,e.get(this.subject.fun))||((n=this.subject)instanceof o.default&&n.name||n instanceof l.default&&h.isNameable(n.fun)&&n.fun.name?this.subject:(u=this.subject.getProof(t,e,r))[u.length-1].ctr);return[...a,...u,{_type:"E",ctr:r.next(),subject:f,args:s,leftargs:i,reduced:this.reduced}]}toIndentedString(t,e){var r=this.leftargs.map((e=>e.toIndentedString(t+1)));return r.join("").length<=50?(r=(r=this.leftargs.map((e=>e.toIndentedString(t)))).join(", "),[this.subject.toIndentedString(t)+"[",r,"]"].join("")):(r=r.join(",\n"+"\t".repeat(t+1)),[this.subject.toIndentedString(t)+"[","\t"+r,"]"].join("\n"+"\t".repeat(t)))}toTeXString(t,e){return`${this.subject.toTeXString(!1)}[${this.leftargs.map((t=>t.toTeXString(d.default.PREC_COMMA))).join(", ")}]`}}e.default=Reduction},function(t,e,r){"use strict";var n=this&&this.__importDefault||function(t){return t&&t.__esModule?t:{default:t}};Object.defineProperty(e,"__esModule",{value:!0});const a=n(r(1));class With extends a.default{constructor({variable:t,def$s:e,expr:r},n){super(n,null,null,r.type),this.variable=t,this.def$s=e,this.expr=r}substitute(t){if(t.has(this.variable))throw Error("Parameter collision");return t=new Map(t),this.expandMeta(!1).substitute(t)}expandMetaInternal(t){var e=new Map;return e.set(this.variable,this.variable.expr),this.expr.substitute(e).expandMeta(t)}getEqualsPriority(t){throw new Error("Method not implemented.")}equalsInternal(t,e){throw new Error("Method not implemented.")}isProvedInternal(t){return this.expr.isProved(t)}getProofInternal(t,e,r,n){return e=new Map(e),[{_type:"def",ctr:r.next(),var:this.variable},...this.def$s.map((n=>{var a=n.expr.getProof(t,e,r),i=a[a.length-1].ctr;return e.set(n,i),a})).flat(1),...this.expr.getProof(t,e,r)]}toIndentedString(t,e){throw new Error("Method not implemented.")}toTeXString(t,e){throw new Error("Method not implemented.")}}e.default=With},function(t,e,r){"use strict";var n=this&&this.__importDefault||function(t){return t&&t.__esModule?t:{default:t}};Object.defineProperty(e,"__esModule",{value:!0});const a=n(r(23)),i=n(r(6));e.default=class ProofExplorer{static get(t,e,r){var n="&#x25C7;";if(!t.hasSchema(e))throw Error("wut");var s=t.getSchema(e);if(!(s instanceof i.default))throw Error("wut");function getHtmlLine(t,e,n,a,i){for(var s=e.length,{bbb:o=!1,rrb:l=!1}=i||{},f=e.map(((t,e,n)=>`<td class="${l&&e==n.length-1?"rrb":"brb"}">${t.map((t=>r(t.toTeXStringWithId(!0)))).join(", ")}</td>`)).join(""),h=0;h<e.length;h++)for(;e[h].length;)e[h].pop();return`<tr><th>${t}</th>${f}<td ${o?'class="bbb" ':""}colspan="${u-s}">${n}</td>${a instanceof Array?a.map((t=>`<td>${t}</td>`)).join(""):`<td colspan="2">${a}</td>`}</tr>`}function exprToHtml(t,e){return"number"==typeof t?`<b>${t}</b>`:t instanceof Array?`<b>${t[0]}&ndash;${t[1]}</b>`:r(e?t.expandMeta(!0).toTeXString(!0,!0):t.toTeXString(!0,!0))}var o=s.getProof(new Map,new Map,new a.default,!0),l=o[0].$lines.concat(o[0].lines),u=function recurse(t){return Math.max(...t.map((t=>{switch(t._type){case"V":return Math.max(recurse(t.$lines),recurse(t.lines))+1;case"T":return Math.max(recurse(t.leftlines),recurse(t.rightlines))+1;default:return 1}})))}(l),f='<table class="explorer">';return f+=`<tr><th>#</th><th colspan="${u}">expr</th><th colspan="2">rule</th></tr>`,f+=function tree2html(t,e){return t.map((t=>{switch(t._type){case"V":var r=t.params.slice();return tree2html(t.$lines,e.concat([r]))+tree2html(t.lines,e.concat([r]));case"T":var a=e.concat([[]]),i="";if(0==t.leftlines.length)i+=getHtmlLine("",Array(e.length+1).fill([]),"","",{bbb:!0,rrb:!0});else i+=t.leftlines.map(((t,e,r)=>getHtmlLine(t.ctr,a,exprToHtml(t.expr,!0),"assumption",{bbb:e==r.length-1,rrb:!0}))).join("");return i+=tree2html(t.rightlines,a);case"?":return getHtmlLine(t.ctr,e,exprToHtml(t.expr,!0),"???");case"H":throw Error("no");case"R":return getHtmlLine(t.ctr,e,exprToHtml(t.expr,!0),[n,exprToHtml(t.num)]);case"RS":case"RCX":return getHtmlLine(t.ctr,e,exprToHtml(t.expr,!0),[n,exprToHtml(t.expr)]);case"RC":return getHtmlLine(t.ctr,e,exprToHtml(t.expr,!0),[n,`${exprToHtml(t.schema)} (${t.args.map((t=>exprToHtml(t))).join(", ")})`]);case"E":return getHtmlLine(t.ctr,e,exprToHtml(t.reduced,!0),["&#x25BC;",`${exprToHtml(t.subject)}${t.args?" ("+t.args.map((t=>exprToHtml(t))).join(", ")+")":""} [${t.leftargs.map((t=>exprToHtml(t))).join(", ")}]`]);case"NP":return getHtmlLine(t.ctr,e,exprToHtml(t.expr,!0),'<b class="red">not proved</b>');case"def":return getHtmlLine(t.ctr,e,exprToHtml(t.var),"definition");default:throw Error("Unknown type "+t._type)}})).join("")}(l,[]),f+="</table>"}}},function(t,e,r){"use strict";Object.defineProperty(e,"__esModule",{value:!0});e.default=class Counter{constructor(t=0){this.n=t}peek(){return this.n}next(){return++this.n}}},function(t,e,r){"use strict";var n=this&&this.__importDefault||function(t){return t&&t.__esModule?t:{default:t}};Object.defineProperty(e,"__esModule",{value:!0});const a=n(r(5)),i=n(r(3)),s=n(r(11)),o=n(r(2)),l=n(r(4)),u=n(r(25));class Scope{constructor(t,e,r){if(this.importMap=new Map,this.typedefMap=new Map,this.defMap=new Map,this.schemaMap=new Map,this.$Map=new Map,this.hypotheses=[],this.fileUri=t,this.parent=e,this.root=e?e.root:this,r&&!(r instanceof u.default))throw Error("Assertion failed");this.trace=r||new u.default(t),this.baseType=e?e.baseType:null}extend(t,e,r){var n=new Scope(this.fileUri,this,this.trace.extend({type:t,name:e,location:r}));return this.hypotheses.forEach((t=>n.hypotheses.push(t))),n}error(t){return this.trace.error(t)}hasOwnType(t){if("string"==typeof t)return this.typedefMap.has(t)||[...this.importMap.values()].some((e=>e.hasOwnType(t)));if(!(t instanceof Array))throw this.error("Argument is malformed");if(t.length<2)throw this.error("Illegal array length");return t.map((t=>this.hasOwnType(t))).every((t=>t))}hasType(t){if("string"==typeof t)return this.hasOwnType(t)||!!this.parent&&this.parent.hasType(t);if(!(t instanceof Array))throw this.error("Argument is malformed");if(t.length<2)throw this.error("Illegal array length");return t.map((t=>this.hasType(t))).every((t=>t))}addType(t){if(!(t instanceof o.default))throw this.error("Illegal argument type");if(!t.name)throw this.error("Something's wrong");if(this.hasOwnType(t.name))throw this.error(`Type ${t.name} has already been declared`);if(t.isBaseType){if(this.baseType)throw this.error("A base type already exists");!function broadcast(e){e.baseType=t,e.parent&&broadcast(e.parent)}(this)}return this.typedefMap.set(t.name,t),t}getType(t){if("string"==typeof t){if(!this.hasType(t))throw this.error(`Type ${t} is not defined`);return this.typedefMap.has(t)?this.typedefMap.get(t):!!this.parent&&this.parent.getType(t)||[...this.importMap.values()].filter((e=>e.hasType(t)))[0].getType(t)}if(!(t instanceof Array))throw this.error("Argument is malformed");if(t.length<2)throw this.error("Illegal array length");var e=t.slice(0,t.length-1).map((t=>this.getType(t))),r=this.getType(t[t.length-1]);return new o.default({functional:!0,from:e,to:r})}hasOwnVariable(t){return this.defMap.has(t)||[...this.importMap.values()].some((e=>e.hasOwnVariable(t)))}hasVariable(t){return this.hasOwnVariable(t)||!!this.parent&&this.parent.hasVariable(t)}addVariable(t){if(!(t instanceof l.default))throw this.error("Illegal argument type");if(this.hasOwnVariable(t.name))throw this.error(`Definition ${t.name} has already been declared`);return this.defMap.set(t.name,t),t}addFun(t){if(!(t instanceof s.default))throw this.error("Illegal argument type");if(!t.name)throw this.error("Cannot add anonymous fun to scope");if(this.hasOwnVariable(t.name))throw this.error(`Definition ${t.name} has already been declared`);return this.defMap.set(t.name,t),t}getVariable(t){if(!this.hasVariable(t))throw this.error(`Definition ${t} is not defined`);return this.defMap.has(t)?this.defMap.get(t):!!this.parent&&this.parent.getVariable(t)||[...this.importMap.values()].filter((e=>e.hasVariable(t)))[0].getVariable(t)}hasOwnSchema(t){return this.schemaMap.has(t)||this.defMap.has(t)||[...this.importMap.values()].some((e=>e.hasOwnSchema(t)))}hasSchema(t){return this.hasOwnSchema(t)||!!this.parent&&this.parent.hasSchema(t)}addSchema(t){if(!(t instanceof i.default))throw this.error("Illegal argument type");if(this.hasOwnSchema(t.name))throw this.error(`Schema ${t.name} has already been declared`);return this.schemaMap.set(t.name,t),t}getSchema(t){if(!this.hasSchema(t))throw this.error(`Schema ${t} is not defined`);return this.schemaMap.has(t)?this.schemaMap.get(t):this.defMap.has(t)?this.defMap.get(t):!!this.parent&&this.parent.getSchema(t)||[...this.importMap.values()].filter((e=>e.hasSchema(t)))[0].getSchema(t)}hasOwn$(t){return this.$Map.has(t)||[...this.importMap.values()].some((e=>e.hasOwn$(t)))}has$(t){return this.hasOwn$(t)||!!this.parent&&this.parent.has$(t)}add$(t){if(!(t instanceof a.default))throw this.error("Illegal argument type");if(this.hasOwn$(t.name))throw this.error(`$ variable ${t.name} has already been declared`);return this.$Map.set(t.name,t),t}get$(t){if(!this.has$(t))throw this.error(`$ variable ${t} is not defined`);return this.$Map.has(t)?this.$Map.get(t):!!this.parent&&this.parent.get$(t)||[...this.importMap.values()].filter((e=>e.has$(t)))[0].get$(t)}}e.default=Scope},function(t,e,r){"use strict";Object.defineProperty(e,"__esModule",{value:!0});class StackTrace{constructor(t,e){this.fileUri=t,this.stack=e||[]}extend(t){return new StackTrace(this.fileUri,[t].concat(this.stack))}error(t){var e=this.fileUri||"<unknown>";return new Error(t+"\n\tat "+(this.stack.length?this.stack.map((({type:t,name:r,location:n})=>`${t} ${r||"<anonymous>"} (${e}:${n.start.line}:${n.start.column})`)).join("\n\tat "):`<root> (${e}:1:1)`))}}e.default=StackTrace}])}));
//# sourceMappingURL=math.min.js.map