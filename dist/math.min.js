!function webpackUniversalModuleDefinition(t,e){"object"==typeof exports&&"object"==typeof module?module.exports=e():"function"==typeof define&&define.amd?define([],e):"object"==typeof exports?exports.math=e():t.math=e()}("undefined"!=typeof self?self:this,(function(){return function(t){var e={};function __webpack_require__(n){if(e[n])return e[n].exports;var r=e[n]={i:n,l:!1,exports:{}};return t[n].call(r.exports,r,r.exports,__webpack_require__),r.l=!0,r.exports}return __webpack_require__.m=t,__webpack_require__.c=e,__webpack_require__.d=function(t,e,n){__webpack_require__.o(t,e)||Object.defineProperty(t,e,{enumerable:!0,get:n})},__webpack_require__.r=function(t){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(t,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(t,"__esModule",{value:!0})},__webpack_require__.t=function(t,e){if(1&e&&(t=__webpack_require__(t)),8&e)return t;if(4&e&&"object"==typeof t&&t&&t.__esModule)return t;var n=Object.create(null);if(__webpack_require__.r(n),Object.defineProperty(n,"default",{enumerable:!0,value:t}),2&e&&"string"!=typeof t)for(var r in t)__webpack_require__.d(n,r,function(e){return t[e]}.bind(null,r));return n},__webpack_require__.n=function(t){var e=t&&t.__esModule?function getDefault(){return t.default}:function getModuleExports(){return t};return __webpack_require__.d(e,"a",e),e},__webpack_require__.o=function(t,e){return Object.prototype.hasOwnProperty.call(t,e)},__webpack_require__.p="",__webpack_require__(__webpack_require__.s=14)}([function(t,e,n){"use strict";var r=this&&this.__importDefault||function(t){return t&&t.__esModule?t:{default:t}};Object.defineProperty(e,"__esModule",{value:!0}),e.EqualsPriority=void 0;const a=r(n(11));!function(t){t[t.ZERO=0]="ZERO",t[t.ONE=1]="ONE",t[t.TWO=2]="TWO",t[t.THREE=3]="THREE",t[t.FOUR=4]="FOUR",t[t.FIVE=5]="FIVE"}(e.EqualsPriority||(e.EqualsPriority={}));class Metaexpr{constructor(t,e,n,r){if(this._id=a.default.next(),this.doc=t,this.tex=e,this.trace=r,!n)throw Metaexpr.error("Assertion failed",r);this.type=n}expandMeta(t){return this.expandMetaCache?this.expandMetaCache:this.expandMetaCache=this.expandMetaInternal(t)}equals(t,e){return this===t?[]:!!this.type.equals(t.type)&&(t.getEqualsPriority(e)>this.getEqualsPriority(e)?t.equalsInternal(this,e):this.equalsInternal(t,e))}isProved(t){t=t||[];for(var e=0;e<t.length;e++)if(t[e]==this)return!0;return this.isProvedInternal(t)}getProof(t,e,n,r=!1){return t.has(this)?[{_type:"R",ctr:n.next(),num:t.get(this),expr:this}]:e.has(this)?[{_type:"R",ctr:n.next(),num:e.get(this),expr:this}]:this.getProofInternal(t,e,n,r)}toString(){return this.toIndentedString(0)}error(t){return Metaexpr.error(t,this.trace)}static error(t,e){return e?e.error(t):new Error(t)}static normalizePrecedence(t){if(!1===t)return[0,0];if(!0===t)return[2,0];if("number"==typeof t)return[0,t];if(!(t instanceof Array&&2==t.length))throw console.log(t),Error("wut");return t}shouldConsolidate(t){var e=Metaexpr.normalizePrecedence(this.precedence||!1),n=Metaexpr.normalizePrecedence(t||!1);return(0!=e[0]||0!=e[1])&&!(e[0]<n[0]||e[0]==n[0]&&e[1]<n[1])}static escapeTeX(t){return t.replace(/&|%|\$|#|_|{|}|~|\^|\\/g,(t=>({"&":"\\&","%":"\\%",$:"\\$","#":"\\#",_:"\\_","{":"\\{","}":"\\}","~":"\\textasciitilde","^":"\\textasciicircum","\\":"\\textbackslash"}[t])))}static parseTeX(t){var e=!1,n=t.replace(/^!<prec=([0-9]+)>/,((t,n)=>(e=1*n,"")));return{precedence:e,code:n}}static makeTeXName(t){var e=new RegExp(`^(?:([a-z])|(${["alpha","beta","gamma","delta","epsilon","zeta","eta","theta","iota","kappa","lambda","mu","nu","xi","omicron","pi","rho","sigma","tau","upsilon","phi","chi","psi","omega"].join("|")}))([0-9]*)$`,"i"),n=t.match(e);return n?(()=>{if(n[1])return n[1];var t=n[2].charCodeAt(0)<="Z".charCodeAt(0),e=n[2].toLowerCase();return t&&(e=e[0].toUpperCase()+e.substring(1)),"\\"+e})()+(n[3]?1==n[3].length?"_"+n[3]:`_{${n[3]}}`:""):1==t.length?Metaexpr.escapeTeX(t):`\\mathrm{${Metaexpr.escapeTeX(t)}}`}makeTeX(t,e,n){e=e||[],n=n||!1;var r=this.tex;return this.shouldConsolidate(n)&&(r="\\left("+r+"\\right)"),r.replace(/#([0-9]+)/g,((t,n)=>e[1*n-1]||`\\texttt{\\textcolor{red}{\\#${n}}}`)).replace(/<<(.+?)>>/,((e,n)=>`\\href{#${t}}{${n}}`))}}e.default=Metaexpr,Metaexpr.PREC_FUNEXPR=1e3,Metaexpr.PREC_COMMA=1e3,Metaexpr.PREC_COLONEQQ=1e5},function(t,e,n){"use strict";var r=this&&this.__importDefault||function(t){return t&&t.__esModule?t:{default:t}};Object.defineProperty(e,"__esModule",{value:!0}),e.FunctionalObjectType=e.SimpleObjectType=e.ObjectType=e.FunctionalMetaType=e.TeeType=e.Type=void 0;const a=r(n(11));class Type{constructor(t,e){this._id=a.default.next(),this.doc=t,this.trace=e}toString(){return this.toIndentedString(0)}equals(t){if(this===t)return!0;if(!(t instanceof Type))return!1;if(this instanceof TeeType!=t instanceof TeeType)return!1;if(this instanceof TeeType&&t instanceof TeeType){if(this.left.length!=t.left.length)return!1;for(var e=0;e<this.left.length;e++)if(!this.left[e].equals(t.left[e]))return!1;return this.right.equals(t.right)}if(this instanceof SimpleObjectType&&this.expr)return this.expr.equals(t);if(t instanceof SimpleObjectType&&t.expr)return this.equals(t.expr);if(this instanceof SimpleObjectType||t instanceof SimpleObjectType)return!1;if((this instanceof FunctionalObjectType||this instanceof FunctionalMetaType)&&(t instanceof FunctionalObjectType||t instanceof FunctionalMetaType)){if(this.from.length!=t.from.length)return!1;for(e=0;e<this.from.length;e++)if(!this.from[e].equals(t.from[e]))return!1;return this.to.equals(t.to)}throw Error("Unknown type format")}}e.Type=Type;class TeeType extends Type{constructor({left:t,right:e},n){if(super(null,n),!t||!e)throw Error("duh");this.left=t,this.right=e}toIndentedString(t){return`[${this.left.join(", ")} |- ${this.right}]`}resolve(){return this}isFunctional(){return!1}}e.TeeType=TeeType;class FunctionalMetaType extends Type{constructor({from:t,to:e},n){if(super(null,n),!t||!e)throw Error("duh");this.from=t,this.to=e}toIndentedString(t){return`[${this.from.join(", ")} -> ${this.to}]`}resolve(){return this}isFunctional(){return!0}}e.FunctionalMetaType=FunctionalMetaType;class ObjectType extends Type{constructor(t,e){super(t,e)}}e.ObjectType=ObjectType;class SimpleObjectType extends ObjectType{constructor({doc:t,name:e,expr:n},r){if(super(t,r),!e)throw Error("duh");this.name=e,this.expr=n}resolve(){return this.expr?this.expr.resolve():this}toIndentedString(t){return this.name}toTeXString(t){var e=`\\href{#type-${this.name}}{\\mathsf{${this.name}}}`;return t&&this.expr?e+"\\coloneqq"+this.expr.toTeXString():e}isFunctional(){return!!this.expr&&this.expr.isFunctional()}}e.SimpleObjectType=SimpleObjectType;class FunctionalObjectType extends ObjectType{constructor({from:t,to:e},n){super(null,n),this.from=t,this.to=e}resolve(){return new FunctionalObjectType({from:this.from.map((t=>t.resolve())),to:this.to.resolve()},this.trace)}toIndentedString(t){return`[${this.from.join(", ")} -> ${this.to}]`}toTeXString(t){return"\\left["+this.from.map((t=>t.toTeXString())).join("\\times ")+` \\to ${this.to.toTeXString()}\\right]`}isFunctional(){return!0}}e.FunctionalObjectType=FunctionalObjectType},function(t,e,n){"use strict";var r=this&&this.__createBinding||(Object.create?function(t,e,n,r){void 0===r&&(r=n),Object.defineProperty(t,r,{enumerable:!0,get:function(){return e[n]}})}:function(t,e,n,r){void 0===r&&(r=n),t[r]=e[n]}),a=this&&this.__setModuleDefault||(Object.create?function(t,e){Object.defineProperty(t,"default",{enumerable:!0,value:e})}:function(t,e){t.default=e}),i=this&&this.__importStar||function(t){if(t&&t.__esModule)return t;var e={};if(null!=t)for(var n in t)"default"!==n&&Object.prototype.hasOwnProperty.call(t,n)&&r(e,t,n);return a(e,t),e},s=this&&this.__importDefault||function(t){return t&&t.__esModule?t:{default:t}};Object.defineProperty(e,"__esModule",{value:!0});const o=s(n(8));class Fun extends o.default{constructor({doc:t,tex:e,annotations:n,sealed:r,rettype:a,name:i,params:s,expr:o},l){if(!i&&!o)throw u.default.error("Anonymous fun cannot be primitive",l);if(a&&o&&!a.equals(o.type))throw u.default.error(`Expression type ${o.type} failed to match the return type ${a} of fun ${i}`,l);if(!a&&!o)throw u.default.error("Cannot guess the return type of a primitive fun",l);if(r&&!o)throw u.default.error("Cannot seal a primitive fun",l);var h=!1;if(e){var f=u.default.parseTeX(e);h=f.precedence,e=f.code}else e=null;super(t,e,new((a||o.type)instanceof c.ObjectType?c.FunctionalObjectType:c.FunctionalMetaType)({from:s.map((t=>t.type)),to:a||o.type},l),l),this.annotations=n,this.sealed=r,this.precedence=h,this.name=i,this.params=s,this.expr=o}get length(){return this.params.length}isProvedInternal(t){return this.expr&&this.expr.isProved(t)}getEqualsPriority(){return u.EqualsPriority.ONE}equalsInternal(t,e){if((!this.expr||this.sealed)&&(!(t instanceof Fun&&t.expr)||t.sealed))return!1;for(var n=[],r=this.type.resolve().from,a=0;a<r.length;a++)n.push(new f.default({type:r[a],name:"$"+a,selector:null},this.trace));var i=[],s=this.expr&&!this.sealed?(this.name&&i.push(this),this.call(n)):new l.default({fun:this,args:n},this.trace),o=t instanceof Fun&&t.expr&&!t.sealed?(t.name&&i.push(t),t.call(n)):new l.default({fun:t,args:n},this.trace),u=s.equals(o,e);return u&&u.concat(i)}call(t){if(!this.expr)throw Error("Cannot call a primitive fun");if(this.params.length!=t.length)throw Error("Arguments length mismatch");for(var e=0;e<this.params.length;e++)if(!this.params[e].type.equals(t[e].type))throw Error("Illegal type");var n=new Map;for(e=0;e<this.params.length;e++)n.set(this.params[e],t[e]);return this.expr.substitute(n)}getProofInternal(t,e,n,r=!1){if(this instanceof h.default&&this.name&&!r)return[{_type:"RS",ctr:n.next(),expr:this}];if(!this.expr)return[{_type:"NP",ctr:n.next(),expr:this}];e=new Map(e);var a=n.peek()+1,i=[];return this instanceof h.default&&this.def$s.forEach((r=>{var a=r.expr.getProof(t,e,n);i=i.concat(a);var s=a[a.length-1].ctr;e.set(r,s)})),[{_type:"V",$lines:i,lines:this.expr.getProof(t,e,n),params:this.params,ctr:[a,n.peek()]}]}}e.default=Fun;const l=s(n(7)),u=i(n(0)),h=s(n(3)),f=s(n(6)),c=n(1)},function(t,e,n){"use strict";var r=this&&this.__importDefault||function(t){return t&&t.__esModule?t:{default:t}};Object.defineProperty(e,"__esModule",{value:!0});const a=r(n(2));class Schema extends a.default{constructor({doc:t,tex:e,annotations:n,schemaType:r,name:a,params:s,context:o,def$s:l,expr:u},h){if(!u)throw i.default.error("wut",h);if("schema"!=r&&!a)throw i.default.error("wut",h);if(super({doc:t,tex:e,annotations:n,sealed:!1,rettype:null,name:a,params:s,expr:u},h),this.schemaType=r,this.def$s=l||[],this.context=o,"theorem"==r&&!this.isProved())throw i.default.error(`Schema ${a} is marked as a theorem but it is not proved`,h)}isProvedInternal(t){if(this.isProvedCache)return!0;if(0==t.length&&"boolean"==typeof this.isProvedCache)return this.isProvedCache;var e="axiom"==this.schemaType||this.expr.isProved(t);return t.length||(this.isProvedCache=e),e}substitute(t){if(!this.expr)return this;if(this.name)return this;if(this.params.some((e=>t.has(e))))throw Error("Parameter collision");return new Schema({doc:null,tex:null,annotations:this.annotations,schemaType:"schema",name:null,params:this.params,context:this.context,def$s:this.def$s,expr:this.expr.substitute(t)},this.trace)}expandMetaInternal(t){return this.expr?this.type instanceof s.ObjectType&&this.name?this:new Schema({doc:null,tex:null,annotations:this.annotations,schemaType:"schema",name:null,params:this.params,context:this.context,def$s:this.def$s,expr:this.expr.expandMeta(t)},this.trace):this}isCallable(t){return!0}toIndentedString(t,e){return[`∫ ${this.name||""}(${this.params.map((e=>e.toIndentedString(t))).join(", ")}) => {`,"\t"+this.expr.expandMeta(!0).toIndentedString(t+1),"}"].join("\n"+"\t".repeat(t))}toTeXString(t,e){if(!this.name)return this.precedence=i.default.PREC_FUNEXPR,[this.shouldConsolidate(t)?"\\left(":"",1==this.params.length?this.params[0].toTeXString(!1):`\\left(${this.params.map((t=>t.toTeXString(i.default.PREC_COMMA))).join(", ")}\\right)`,"\\mapsto ",this.expr.expandMeta(!0).toTeXString(!1),this.shouldConsolidate(t)?"\\right)":""].join("");var n="def-"+this.name,r=this.isProved()?"p":"np";return e?`\\href{#${n}}{\\htmlData{proved=${r}}{\\mathsf{${i.default.escapeTeX(this.name)}}}}\\mathord{\\left(${this.params.map((t=>t.toTeXStringWithId(i.default.PREC_COMMA)+(t.selector?`: \\texttt{@${t.selector}}`:""))).join(", ")}\\right)}:\\\\\\quad`+this.expr.expandMeta(!0).toTeXString(!0):`\\href{#${n}}{\\htmlData{proved=${r}}{\\mathsf{${i.default.escapeTeX(this.name)}}}}`}}e.default=Schema;const i=r(n(0)),s=n(1)},function(t,e,n){"use strict";var r=this&&this.__createBinding||(Object.create?function(t,e,n,r){void 0===r&&(r=n),Object.defineProperty(t,r,{enumerable:!0,get:function(){return e[n]}})}:function(t,e,n,r){void 0===r&&(r=n),t[r]=e[n]}),a=this&&this.__setModuleDefault||(Object.create?function(t,e){Object.defineProperty(t,"default",{enumerable:!0,value:e})}:function(t,e){t.default=e}),i=this&&this.__importStar||function(t){if(t&&t.__esModule)return t;var e={};if(null!=t)for(var n in t)"default"!==n&&Object.prototype.hasOwnProperty.call(t,n)&&r(e,t,n);return a(e,t),e},s=this&&this.__importDefault||function(t){return t&&t.__esModule?t:{default:t}};Object.defineProperty(e,"__esModule",{value:!0});const o=s(n(8)),l=i(n(0));class Variable extends o.default{constructor({doc:t,tex:e,sealed:n,type:r,name:a,expr:i},s){if(super(t,e,r,s),"string"!=typeof a)throw l.default.error("Assertion failed",s);if(n&&!i)throw l.default.error("Cannot seal a primitive fun",s);if(i&&!r.equals(i.type))throw l.default.error(`Expression type ${i.type} failed to match the type ${r} of variable ${a}`,s);this.sealed=n,this.name=a,this.expr=i}isProvedInternal(t){return!1}substitute(t){return t.has(this)?t.get(this):this}expandMetaInternal(t){return this}getEqualsPriority(t){return!this.expr||this.sealed&&!t.canUse(this)?l.EqualsPriority.ZERO:l.EqualsPriority.FOUR}equalsInternal(t,e){if(!this.expr)return!1;if(!this.sealed||e.canUse(this)){var n=this.expr.equals(t,e);return n?(n.push(this),n):n}return!1}getProofInternal(t,e,n){return[{_type:"NP",ctr:n.next(),expr:this}]}toSimpleString(){return this.type.toString()+" "+this.name}toIndentedString(t,e){return`${e?this.type+" ":""}${this.name}<${this._id}>`}toTeXString(t,e){return`\\href{#${this instanceof u.default?"id-"+this._id:"def-"+this.name}}{${this.tex||l.default.makeTeXName(this.name)}}${e&&this.expr?"\\coloneqq "+this.expr.toTeXString(l.default.PREC_COLONEQQ):""}`}}e.default=Variable;const u=s(n(6))},function(t,e,n){"use strict";var r=this&&this.__createBinding||(Object.create?function(t,e,n,r){void 0===r&&(r=n),Object.defineProperty(t,r,{enumerable:!0,get:function(){return e[n]}})}:function(t,e,n,r){void 0===r&&(r=n),t[r]=e[n]}),a=this&&this.__setModuleDefault||(Object.create?function(t,e){Object.defineProperty(t,"default",{enumerable:!0,value:e})}:function(t,e){t.default=e}),i=this&&this.__importStar||function(t){if(t&&t.__esModule)return t;var e={};if(null!=t)for(var n in t)"default"!==n&&Object.prototype.hasOwnProperty.call(t,n)&&r(e,t,n);return a(e,t),e};Object.defineProperty(e,"__esModule",{value:!0});const s=i(n(0));class $Variable extends s.default{constructor({name:t,expr:e},n){if(super(null,null,e.type,n),!t||!e)throw s.default.error("Assertion failed",n);this.name=t,this.expr=e}isProvedInternal(t){return this.expr.isProved(t)}substitute(t){return this.expr.substitute(t)}expandMetaInternal(t){return this.expr.expandMeta(t)}getEqualsPriority(){return s.EqualsPriority.FIVE}equalsInternal(t,e){return this.expr.equals(t,e)}getProofInternal(t,e,n){if(!e.has(this))throw Error(this.name+" is not defined");return[{_type:"R",ctr:n.next(),num:e.get(this),expr:this.expr}]}toIndentedString(t,e){return this.name}toTeXString(t,e){return`\\mathtt{${s.default.escapeTeX(this.name)}}`}}e.default=$Variable},function(t,e,n){"use strict";var r=this&&this.__importDefault||function(t){return t&&t.__esModule?t:{default:t}};Object.defineProperty(e,"__esModule",{value:!0});const a=r(n(4));class Parameter extends a.default{constructor({doc:t,tex:e,type:n,name:r,selector:a},i){super({doc:t,tex:e,sealed:!1,type:n,name:r,expr:null},i),this.selector=a}toTeXStringWithId(t,e){return[`\\htmlId{${"id-"+this._id}}{`,this.toTeXString(t,e),"}"].join("")}}e.default=Parameter},function(t,e,n){"use strict";var r=this&&this.__createBinding||(Object.create?function(t,e,n,r){void 0===r&&(r=n),Object.defineProperty(t,r,{enumerable:!0,get:function(){return e[n]}})}:function(t,e,n,r){void 0===r&&(r=n),t[r]=e[n]}),a=this&&this.__setModuleDefault||(Object.create?function(t,e){Object.defineProperty(t,"default",{enumerable:!0,value:e})}:function(t,e){t.default=e}),i=this&&this.__importStar||function(t){if(t&&t.__esModule)return t;var e={};if(null!=t)for(var n in t)"default"!==n&&Object.prototype.hasOwnProperty.call(t,n)&&r(e,t,n);return a(e,t),e},s=this&&this.__importDefault||function(t){return t&&t.__esModule?t:{default:t}};Object.defineProperty(e,"__esModule",{value:!0});const o=s(n(8));class Funcall extends o.default{constructor({fun:t,args:e},n){if(!t.type.isFunctional()){var r=f.isNameable(t)?t.name:"<anonymous>";throw h.default.error(r+" is not callable",n)}if(!(e instanceof Array)||e.map((t=>t instanceof o.default)).some((t=>!t)))throw h.default.error("Assertion failed",n);var a=t.type.resolve(),i=a.from,s=e.map((t=>t.type));if(i.length!=s.length)throw h.default.error(`Invalid number of arguments (expected ${i.length}): ${s.length}`,n);for(var l=0;l<i.length;l++)if(!i[l].equals(s[l]))throw h.default.error(`Argument #${l+1} has illegal argument type (expected ${i[l]}): ${s[l]}`,n);super(null,null,a.to,n),this.fun=t,this.args=e}isProvedInternal(t){return this.fun.isProved(t)}substitute(t){return new Funcall({fun:this.fun.substitute(t),args:this.args.map((e=>e.substitute(t)))},this.trace)}expandMetaInternal(t){var e=this.fun.expandMeta(t),n=this.args.map((e=>e.expandMeta(t)));return e instanceof u.default&&e.expr&&(!e.name||e instanceof d.default)?e.call(n).expandMeta(t):new Funcall({fun:e,args:n},this.trace)}isExpandable(t){for(var e=this.fun;e instanceof l.default;)e=e.expr;return!!(e instanceof p.default&&e.expr)||(e instanceof Funcall?e.isExpandable(t):e instanceof u.default&&e.isCallable(t))}expandOnce(t){if(!this.isExpandable(t))throw Error("Cannot expand");for(var e=[],n=this.fun;n instanceof l.default;)n=n.expr;if(n instanceof p.default&&n.expr)return e.push(n),{expanded:new Funcall({fun:n.expr,args:this.args},this.trace),used:e};if(n instanceof Funcall){var r=n.expandOnce(t);return e.push(...r.used),{expanded:new Funcall({fun:r.expanded,args:this.args},this.trace),used:e}}if(!(n instanceof u.default))throw Error("Something's wrong");return n.name&&e.push(n),{expanded:n.call(this.args),used:e}}getEqualsPriority(){return h.EqualsPriority.THREE}equalsInternal(t,e){if(!(t instanceof Funcall)){if(!this.isExpandable(e))return!1;var{expanded:n,used:r}=this.expandOnce(e);return(l=n.equals(t,e))&&l.concat(r)}var a=[],T=t=>(t&&a.push(...t),t);if(this.fun==t.fun||T(this.fun.equals(t.fun,e))){for(var i=0;i<this.args.length;i++)if(!T(this.args[i].equals(t.args[i],e)))return!1;return a}if(this.fun instanceof Funcall&&this.fun.isExpandable(e)){var{expanded:n,used:r}=this.expandOnce(e);return(l=n.equals(t,e))&&l.concat(r)}if(t.fun instanceof Funcall&&t.fun.isExpandable(e)){var{expanded:n,used:r}=t.expandOnce(e);return(l=this.equals(n,e))&&l.concat(r)}var s=this.isExpandable(e),o=t.isExpandable(e);if(this.fun==t.fun||!s&&!o){if(this.fun!=t.fun)return!1;if(!s&&!o){for(i=0;i<this.args.length;i++)if(!T(this.args[i].equals(t.args[i],e)))return!1;return a}if(this.args.every(((n,r)=>T(this.args[r].equals(t.args[r],e)))))return a}if(s){var{expanded:n,used:r}=this.expandOnce(e);return(l=n.equals(t,e))&&l.concat(r)}var l,{expanded:n,used:r}=t.expandOnce(e);return(l=this.equals(n,e))&&l.concat(r)}getProofInternal(t,e,n){if(t.has(this.fun))return[{_type:"RC",ctr:n.next(),schema:t.get(this.fun),args:this.args,expr:this}];if(e.has(this.fun))return[{_type:"RC",ctr:n.next(),schema:e.get(this.fun),args:this.args,expr:this}];if(this.fun instanceof d.default&&this.fun.name)return[{_type:"RCX",ctr:n.next(),expr:this}];if(!(this.fun instanceof d.default))return[{_type:"NP",ctr:n.next(),expr:this}];var r=this.fun.getProof(t,e,n);return[...r,{_type:"RC",ctr:n.next(),schema:r[r.length-1].ctr,args:this.args,expr:this}]}toIndentedString(t,e){var n=this.args.map((e=>e instanceof p.default?`${e.name}<${e._id}>`:e.toIndentedString(t+1)));return n.join("").length<=50?(n=(n=this.args.map((e=>e instanceof p.default?`${e.name}<${e._id}>`:e.toIndentedString(t)))).join(", "),this.fun instanceof d.default?`${this.fun.name||`(${this.fun})`}(${n})`:[this.fun instanceof u.default&&this.fun.name?this.fun.name:"("+this.fun.toIndentedString(t)+")",`(${n})`].join("")):(n=n.join(",\n"+"\t".repeat(t+1)),this.fun instanceof d.default?[this.fun.name||`(${this.fun.toIndentedString(t)})`,"(","\t"+n,")"].join("\n"+"\t".repeat(t)):[(this.fun instanceof u.default&&"name"in this.fun&&this.fun.name?this.fun.name:"("+this.fun.toIndentedString(t)+")")+"(","\t"+n,")"].join("\n"+"\t".repeat(t)))}toTeXString(t,e){if(this.fun instanceof d.default)return(this.fun.name?`\\href{#def-${this.fun.name}}{\\htmlData{proved=${this.fun.isProved()?"p":"np"}}{\\textsf{${h.default.escapeTeX(this.fun.name)}}}}`:this.fun.toTeXString(!1))+`\\mathord{\\left(${this.args.map((t=>t.toTeXString(h.default.PREC_COMMA))).join(", ")}\\right)}`;if(this.fun instanceof c.default)return this.fun.funcallToTeXString(this.args,t);var n=this.args.map((t=>t.toTeXString(h.default.PREC_COMMA)));return(!f.isNameable(this.fun)||!this.fun.name||this.fun instanceof p.default?this.fun.toTeXString(!1):h.default.makeTeXName(this.fun.name))+`\\mathord{\\left(${n.join(", ")}\\right)}`}}e.default=Funcall;const l=s(n(5)),u=s(n(2)),h=i(n(0)),f=n(12),c=s(n(9)),d=s(n(3)),p=s(n(4))},function(t,e,n){"use strict";var r=this&&this.__importDefault||function(t){return t&&t.__esModule?t:{default:t}};Object.defineProperty(e,"__esModule",{value:!0});const a=r(n(0));class Expr0 extends a.default{}e.default=Expr0},function(t,e,n){"use strict";var r=this&&this.__importDefault||function(t){return t&&t.__esModule?t:{default:t}};Object.defineProperty(e,"__esModule",{value:!0});const a=r(n(2));class ObjectFun extends a.default{constructor({doc:t,tex:e,annotations:n,sealed:r,rettype:a,name:i,params:s,expr:o},l){super({doc:t,tex:e,annotations:n,sealed:r,rettype:a,name:i,params:s,expr:o},l)}substitute(t){if(!this.expr)return this;if(this.name)return this;if(this.params.some((e=>t.has(e))))throw Error("Parameter collision");return new ObjectFun({doc:null,tex:null,annotations:this.annotations,sealed:this.sealed,rettype:null,name:null,params:this.params,expr:this.expr.substitute(t)},this.trace)}expandMetaInternal(t){return this.expr?this.type instanceof s.ObjectType&&this.name?this:new ObjectFun({doc:null,tex:null,annotations:this.annotations,sealed:this.sealed,rettype:null,name:null,params:this.params,expr:this.expr.expandMeta(t)},this.trace):this}isCallable(t){return this.expr&&(!this.sealed||t.canUse(this))}toIndentedString(t,e){return this.name?this.name:[`ƒ ${this.name||""}(${this.params.map((e=>e.toIndentedString(t))).join(", ")}) => {`,"\t"+this.expr.toIndentedString(t+1),"}"].join("\n"+"\t".repeat(t))}toTeXString(t,e){return this.name?e?this.expr?this.funcallToTeXString(this.params,i.default.PREC_COLONEQQ)+"\\coloneqq "+this.expr.toTeXString(i.default.PREC_COLONEQQ):this.funcallToTeXString(this.params,t):`\\href{#def-${this.name}}{${i.default.makeTeXName(this.name)}}`:(this.precedence=i.default.PREC_FUNEXPR,[this.shouldConsolidate(t)?"\\left(":"",1==this.params.length?this.params[0].toTeXString(!1):`\\left(${this.params.map((t=>t.toTeXString(i.default.PREC_COMMA))).join(", ")}\\right)`,"\\mapsto ",this.expr.expandMeta(!0).toTeXString(!1),this.shouldConsolidate(t)?"\\right)":""].join(""))}funcallToTeXString(t,e){return t=t.map((t=>t.toTeXString(this.tex?this.precedence:i.default.PREC_COMMA))),this.tex?this.makeTeX("def-"+this.name,t,e):(this.name?`\\href{#def-${this.name}}{${i.default.makeTeXName(this.name)}}`:this.toTeXString(!1))+`\\mathord{\\left(${t.join(", ")}\\right)}`}}e.default=ObjectFun;const i=r(n(0)),s=n(1)},function(t,e,n){"use strict";Object.defineProperty(e,"__esModule",{value:!0});e.default=class ExecutionContext{constructor(t){this.usingList=t||[]}canUse(t){return this.usingList.includes(t)}}},function(t,e,n){"use strict";Object.defineProperty(e,"__esModule",{value:!0});var r=0;e.default={peek:()=>r,next:()=>++r}},function(t,e,n){"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.isNameable=void 0,e.isNameable=function isNameable(t){return"name"in t}},function(t,e,n){"use strict";var r=this&&this.__createBinding||(Object.create?function(t,e,n,r){void 0===r&&(r=n),Object.defineProperty(t,r,{enumerable:!0,get:function(){return e[n]}})}:function(t,e,n,r){void 0===r&&(r=n),t[r]=e[n]}),a=this&&this.__setModuleDefault||(Object.create?function(t,e){Object.defineProperty(t,"default",{enumerable:!0,value:e})}:function(t,e){t.default=e}),i=this&&this.__importStar||function(t){if(t&&t.__esModule)return t;var e={};if(null!=t)for(var n in t)"default"!==n&&Object.prototype.hasOwnProperty.call(t,n)&&r(e,t,n);return a(e,t),e},s=this&&this.__importDefault||function(t){return t&&t.__esModule?t:{default:t}};Object.defineProperty(e,"__esModule",{value:!0});const o=s(n(5)),l=i(n(0)),u=n(1);class Tee extends l.default{constructor({left:t,def$s:e,right:n},r){if(!(t instanceof Array&&t.every((t=>t.type instanceof u.ObjectType||t.type instanceof u.Type))))throw console.log(t),l.default.error("Assertion failed",r);if(e&&!(e instanceof Array&&e.every((t=>t instanceof o.default))))throw l.default.error("Assertion failed",r);if(!(n.type instanceof u.ObjectType||n.type instanceof u.Type))throw console.log(n),l.default.error("Assertion failed",r);super(null,null,new u.TeeType({left:t.map((t=>t.type)),right:n.type},r),r),this.left=t,this.def$s=e||[],this.right=n,this.precedence=l.default.PREC_COMMA}isProvedInternal(t){return this.right.isProved(t.concat(this.left))}substitute(t){var e=this.left.map((e=>e.substitute(t))),n=this.right.substitute(t);return new Tee({left:e,def$s:null,right:n},this.trace)}expandMetaInternal(t){var e=this.left.map((e=>e.expandMeta(t))),n=this.right.expandMeta(t);return new Tee({left:e,def$s:null,right:n},this.trace)}getEqualsPriority(){return l.EqualsPriority.TWO}equalsInternal(t,e){if(!(t instanceof Tee))throw Error("Assertion failed");if(this.left.length!=t.left.length)throw Error("Assertion failed");for(var n=0;n<this.left.length;n++)if(!this.left[n].equals(t.left[n],e))return!1;return this.right.equals(t.right,e)}getProofInternal(t,e,n){t=new Map(t);var r=n.peek()+1,a=this.left.map((e=>(t.set(e,n.next()),{_type:"H",ctr:n.peek(),expr:e})));return e=new Map(e),[{_type:"T",leftlines:a,rightlines:this.def$s.map((r=>{var a=r.expr.getProof(t,e,n),i=a[a.length-1].ctr;return e.set(r,i),a})).flat(1).concat(this.right.getProof(t,e,n)),ctr:[r,n.peek()]}]}toIndentedString(t,e){return this.left.length?["\t"+this.left.map((e=>e.toIndentedString(t+1))).join(",\n"+"\t".repeat(t+1)),"|-","\t"+this.right.toIndentedString(t+1)].join("\n"+"\t".repeat(t)):"|- "+this.right.toIndentedString(t)}toTeXString(t,e){var n=this.expandMeta(!0);return[this.shouldConsolidate(t)?"\\left(":"",`{${n.left.map((t=>t.toTeXString(l.default.PREC_COMMA))).join(", ")} \\vdash ${n.right.toTeXString(l.default.PREC_COMMA)}}`,this.shouldConsolidate(t)?"\\right)":""].join("")}}e.default=Tee},function(t,e,n){var r;r=n(15).default;var a=n(16).default;t.exports={grammar:r,Program:a}},function(t,e,n){"use strict";n.r(e),e.default="start =\n\t_\n\timports:(i:import _ {return i})*\n\tlines:(a:line _ {return a})*\n\t{return imports.concat(lines)}\n\nline =\n\ttypedef\n\t/ defv\n\t/ defun\n\t/ defschema\n\nevaluable =\n\t_ e:evaluable_internal _ {return e}\n\nevaluable_internal =\n\ttypedef\n\t/ defv\n\t/ defun\n\t/ defschema\n\t/ metaexpr\n\nimport =\n\t'import' __\n\tfilename:ident _\n\tsem\n\t{\n\t\treturn {\n\t\t\t_type: 'import',\n\t\t\tfilename,\n\t\t\tlocation: location()\n\t\t}\n\t}\n\ntypedef =\n\tdoc:(documentation __)?\n\t\"type\" __\n\tname:ident _\n\texpr:('=' _ o:ftype _ {return o})?\n\tsem\n\t{\n\t\treturn {\n\t\t\t_type: 'typedef',\n\t\t\tdoc: doc ? doc[0] : null,\n\t\t\texpr,\n\t\t\tname,\n\t\t\tlocation: location()\n\t\t}\n\t}\n\ndefv =\n\tdoc:(documentation __)?\n\ttex:(tex __)?\n\tsealed:('sealed' __)?\n\ttype:type __\n\tname:ident _\n\texpr:(\n\t\t\"=\" _\n\t\texpr:expr0 _\n\t\tsem\n\t\t{return expr}\n\t\t/ sem {return null}\n\t)\n\t{\n\t\treturn {\n\t\t\t_type: 'defv',\n\t\t\tisParam: false,\n\t\t\tdoc: doc ? doc[0] : null,\n\t\t\ttex: tex ? tex[0] : null,\n\t\t\tsealed: !!sealed,\n\t\t\ttype,\n\t\t\tname,\n\t\t\texpr,\n\t\t\tlocation: location()\n\t\t}\n\t}\n\ndefparam =\n\ttex:(tex __)? type:type __ name:ident\n\t{\n\t\treturn {\n\t\t\t_type: 'defv',\n\t\t\tisParam: true,\n\t\t\tdoc: null,\n\t\t\ttex: tex ? tex[0] : null,\n\t\t\ttype,\n\t\t\tname,\n\t\t\tlocation: location()\n\t\t}\n\t}\n\ndefschemaparam =\n\ttex:(tex __)? type:type __ name:ident\n\tselector:(_ ':' _ '@' g:$[a-z0-9_]+ {return g})?\n\t{\n\t\treturn {\n\t\t\t_type: 'defv',\n\t\t\tisParam: true,\n\t\t\tdoc: null,\n\t\t\ttex: tex ? tex[0] : null,\n\t\t\ttype,\n\t\t\tname,\n\t\t\tselector,\n\t\t\tlocation: location()\n\t\t}\n\t}\n \ndefun =\n\tdoc:(documentation __)?\n\ttex:(tex __)?\n\tsealed:('sealed' __)?\n\trettype:type __\n\tname:ident _\n\tparams:(\n\t\t\"(\" _\n\t\tp:(\n\t\t\thead:defparam _\n\t\t\ttail:(\",\" _ tv:defparam _ {return tv})*\n\t\t\t{return [head].concat(tail)}\n\t\t)?\n\t\t\")\" _\n\t\t{return p || []}\n\t)\n\texpr:(\n\t\t\"{\" _\n\t\texpr:expr0 _\n\t\t\"}\"\n\t\t{return expr}\n\t\t/ sem {return null}\n\t)\n\t{\n\t\treturn {\n\t\t\t_type: 'defun',\n\t\t\tdoc: doc ? doc[0] : null,\n\t\t\ttex: tex ? tex[0] : null,\n\t\t\tsealed: !!sealed,\n\t\t\trettype,\n\t\t\tname,\n\t\t\tparams,\n\t\t\texpr,\n\t\t\tlocation: location()\n\t\t}\n\t}\n\ndefschema =\n\tdoc:(documentation __)?\n\tannotations: (a:annotation __ {return a})*\n\tschemaType:('axiom' / 'theorem' / 'schema') __\n\tname:ident _\n\tparams:(\n\t\t\"(\" _\n\t\tp:(\n\t\t\thead:defschemaparam _\n\t\t\ttail:(\",\" _ tv:defschemaparam _ {return tv})*\n\t\t\t{return [head].concat(tail)}\n\t\t)?\n\t\t\")\" _\n\t\t{return p || []}\n\t)\n\tusing:(\n\t\t'using' __\n\t\tx:(\n\t\t\thead:ident _\n\t\t\ttail:(',' _ n:ident _ {return n})*\n\t\t\t{return [head].concat(tail)}\n\t\t)\n\t\t{return x}\n\t)?\n\t\"{\" _\n\tdefdollars: (d:defdollar _ {return d})* _\n\texpr:metaexpr _\n\t\"}\"\n\t{\n\t\treturn {\n\t\t\t_type: 'defschema',\n\t\t\tdoc: doc ? doc[0] : null,\n\t\t\tannotations,\n\t\t\tschemaType,\n\t\t\tname,\n\t\t\tparams,\n\t\t\tusing: using || [],\n\t\t\tdef$s: defdollars,\n\t\t\texpr,\n\t\t\tlocation: location()\n\t\t}\n\t}\n\n// var[...]\n// foo(...)[...]\n// foo[...][...]\n// (metaexpr)[...]\n// schema(?, ...)[...]\nreduction =\n\tantecedents:(\n\t\ta:metaexpr_internal_2 {return [a]}\n\t\t/ \"[\" _\n\t\tb:(\n\t\t\thead:metaexpr _\n\t\t\ttail:(\";\" _ e:metaexpr _ {return e})*\n\t\t\t{return [head].concat(tail)}\n\t\t)?\n\t\t\"]\"\n\t\t{return b || []}\n\t)\n\tright:(\n\t\t_ '>' _\n\t\tsubject:(\n\t\t\tschemacall\n\t\t\t/ var\n\t\t\t/ \"(\" _\n\t\t\te:metaexpr _\n\t\t\t\")\"\n\t\t\t{return e}\n\t\t)\n\t\targs:(\n\t\t\t_ \"(\" _\n\t\t\ta:(\n\t\t\t\thead:('?' {return null} / expr0) _\n\t\t\t\ttail:(\",\" _ e:('?' {return null} / expr0) _ {return e})*\n\t\t\t\t{return [head].concat(tail)}\n\t\t\t)?\n\t\t\t\")\"\n\t\t\t{return a || []}\n\t\t)?\n\t\tas_:(\n\t\t\t__ 'as' __\n\t\t\tm:metaexpr_internal_2\n\t\t\t{return m}\n\t\t)?\n\t\t{return {subject, args, as_: as_ || null};}\n\t)+\n\t{\n\t\tvar ret = {\n\t\t\t_type: 'reduction',\n\t\t\tsubject: right[0].subject,\n\t\t\targs: right[0].args,\n\t\t\tantecedents,\n\t\t\tas: right[0].as_,\n\t\t\tlocation: location()\n\t\t};\n\n\t\tfor (var i = 1; i < right.length; i++) {\n\t\t\tret = {\n\t\t\t\t_type: 'reduction',\n\t\t\t\tsubject: right[i].subject,\n\t\t\t\targs: right[i].args,\n\t\t\t\tantecedents: [ret],\n\t\t\t\tas: right[i].as_,\n\t\t\t\tlocation: location()\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn ret;\n\t}\n\n// var(...)\n// (metaexpr)(...)\nschemacall =\n\tschema:(\n\t\tvar\n\t\t/ \"(\" _ e:metaexpr _ \")\"\n\t\t{return e}\n\t) _\n\targs:(\n\t\t\"(\" _\n\t\ta:(\n\t\t\thead:expr0 _\n\t\t\ttail:(\",\" _ e:expr0 _ {return e})*\n\t\t\t{return [head].concat(tail)}\n\t\t)?\n\t\t\")\"\n\t\t{return a || []}\n\t)\n\t{\n\t\treturn {\n\t\t\t_type: 'schemacall',\n\t\t\tschema,\n\t\t\targs,\n\t\t\tlocation: location()\n\t\t}\n\t}\n\n// forall(f, g)\n// (expr0)(f, g)\nfuncall =\n\tschema:(\n\t\tvar\n\t\t/ \"(\" _\n\t\te:expr0 _\n\t\t\")\"\n\t\t{return e}\n\t) _\n\targs:(\n\t\t\"(\" _\n\t\ta:(\n\t\t\thead:expr0 _\n\t\t\ttail:(\",\" _ e:expr0 _ {return e})*\n\t\t\t{return [head].concat(tail)}\n\t\t)?\n\t\t\")\"\n\t\t{return a || []}\n\t)\n\t{\n\t\treturn {\n\t\t\t_type: 'funcall',\n\t\t\tschema,\n\t\t\targs,\n\t\t\tlocation: location()\n\t\t}\n\t}\n\n// (T t) => expr0\n// (T t) => { expr0 }\nfunexpr =\n\tparams:(\n\t\t\"(\" _\n\t\tp:(\n\t\t\thead:defparam _\n\t\t\ttail:(\",\" _ tv:defparam _ {return tv})*\n\t\t\t{return [head].concat(tail)}\n\t\t)?\n\t\t\")\" _\n\t\t{return p || []}\n\t)\n\t\"=>\" _\n\texpr:(\n\t\texpr0\n\t\t/ \"{\" _ e:expr0 _ \"}\" {return e}\n\t)\n\t{\n\t\treturn {\n\t\t\t_type: 'funexpr',\n\t\t\tparams,\n\t\t\texpr,\n\t\t\tlocation: location()\n\t\t}\n\t}\n\n// (T t) => metaexpr_internal_1\n// (T t) => { $foo = ...; metaexpr }\nschemaexpr =\n\tparams:(\n\t\t\"(\" _\n\t\tp:(\n\t\t\thead:defparam _\n\t\t\ttail:(\",\" _ tv:defparam _ {return tv})*\n\t\t\t{return [head].concat(tail)}\n\t\t)?\n\t\t\")\" _\n\t\t{return p || []}\n\t)\n\t\"=>\" _\n\tfoo:(\n\t\texpr:metaexpr_internal_1\n\t\t{return {defdollars: [], expr}}\n\t\t/ \"{\" _\n\t\tdefdollars: (d:defdollar _ {return d})* _\n\t\texpr:metaexpr _\n\t\t\"}\"\n\t\t{return {defdollars, expr}}\n\t)\n\t{\n\t\treturn {\n\t\t\t_type: 'schemaexpr',\n\t\t\tparams,\n\t\t\tdef$s: foo.defdollars,\n\t\t\texpr: foo.expr,\n\t\t\tlocation: location()\n\t\t}\n\t}\n\ntee =\n\tleft:(\n\t\tl:(\n\t\t\thead:metaexpr_internal_1 _\n\t\t\ttail:(\",\" _ e:metaexpr_internal_1 _ {return e})*\n\t\t\t{return [head].concat(tail)}\n\t\t)? {return l || []}\n\t)\n\t\"|-\" _\n\tfoo:(\n\t\texpr:metaexpr_internal_2\n\t\t{return {defdollars: [], expr}}\n\t\t/ \"{\" _\n\t\tdefdollars: (d:defdollar _ {return d})* _\n\t\texpr:metaexpr _\n\t\t\"}\"\n\t\t{return {defdollars, expr}}\n\t)\n\t{\n\t\treturn {\n\t\t\t_type: 'tee',\n\t\t\tdef$s: foo.defdollars,\n\t\t\tleft,\n\t\t\tright: foo.expr,\n\t\t\tlocation: location()\n\t\t}\n\t}\n\nwith =\n\t'with' _ '(' _\n\ttex:(tex __)?\n\ttype:type __\n\tvarname:ident _\n\t\"=\" _\n\tvarexpr:expr0 _\n\t')' _ '{' _\n\tdefdollars: (d:defdollar _ {return d})* _\n\texpr:metaexpr _\n\t'}'\n\t{\n\t\treturn {\n\t\t\t_type: 'with',\n\t\t\twith: {\n\t\t\t\t_type: 'defv',\n\t\t\t\tisParam: false,\n\t\t\t\tdoc: null,\n\t\t\t\ttex: tex ? tex[0] : null,\n\t\t\t\tsealed: false,\n\t\t\t\ttype,\n\t\t\t\tname: varname,\n\t\t\t\texpr: varexpr,\n\t\t\t\tlocation: location()\n\t\t\t},\n\t\t\tdef$s: defdollars,\n\t\t\texpr,\n\t\t\tlocation: location()\n\t\t}\n\t}\n\nmetaexpr =\n\tmetaexpr_internal_3\n\nmetaexpr_internal_3 =\n\treduction\n\t/ metaexpr_internal_2\n\nmetaexpr_internal_2 =\n\ttee\n\t/ metaexpr_internal_1\n\n/*\n * The following should hold:\n *\n * - `schemacall` should precede `var`.\n *\n */\nmetaexpr_internal_1 =\n\tschemacall\n\t/ var\n\t/ schemaexpr\n\t/ with\n\t/ \"(\" _ e:metaexpr _ \")\" {return e}\n\nexpr0 =\n\tfuncall\n\t/ funexpr\n\t/ var\n\t/ \"(\" _ e:expr0 _ \")\" {return e}\n\ndefdollar =\n\tname:dollar_ident _\n\t'=' _\n\texpr:metaexpr _\n\tsem\n\t{\n\t\treturn {\n\t\t\t_type: 'def$',\n\t\t\tname,\n\t\t\texpr,\n\t\t\tlocation: location()\n\t\t};\n\t}\n\ntype =\n\tstype\n\t/ ftype\n\nstype =\n\tname:ident\n\t{\n\t\treturn {\n\t\t\t_type: 'type',\n\t\t\tftype: false,\n\t\t\tname,\n\t\t\tlocation: location()\n\t\t}\n\t}\n\nftype =\n\t\"[\" _\n\tfrom:(\n\t\thead:type\n\t\ttail:(_ \",\" _ t:type {return t})*\n\t\t{return [head].concat(tail)}\n\t) _\n\t\"->\" _\n\tto:type _\n\t\"]\"\n\t{\n\t\treturn {\n\t\t\t_type: 'type',\n\t\t\tftype: true,\n\t\t\tfrom,\n\t\t\tto,\n\t\t\tlocation: location()\n\t\t}\n\t}\n\nvar =\n\tat_var\n\t/ dollar_var\n\t/ plain_var\n\nat_var =\n\tname:at_ident\n\t{\n\t\treturn {\n\t\t\t_type: 'var',\n\t\t\ttype: '@',\n\t\t\tname: name.slice(1),\n\t\t\tlocation: location()\n\t\t}\n\t}\n\ndollar_var =\n\tname:dollar_ident\n\t{\n\t\treturn {\n\t\t\t_type: 'var',\n\t\t\ttype: '$',\n\t\t\tname: name,\n\t\t\tlocation: location()\n\t\t}\n\t}\n\nplain_var =\n\tname:ident\n\t{\n\t\treturn {\n\t\t\t_type: 'var',\n\t\t\ttype: 'normal',\n\t\t\tname,\n\t\t\tlocation: location()\n\t\t}\n\t}\n\nkeyword =\n\t'as'\n\t/ 'axiom'\n\t/ 'import'\n\t/ 'schema'\n\t/ 'sealed'\n\t/ 'theorem'\n\t/ 'type'\n\t/ 'using'\n\t/ 'with'\n\nannotation =\n\t'@discouraged'\n\t/ '@deprecated'\n\nident =\n\t$(!(keyword ![a-zA-Z0-9_]) [a-zA-Z0-9_]+)\n\nat_ident =\n\t$('@' [a-zA-Z0-9_]+)\n\ndollar_ident =\n\t$('$' [a-zA-Z0-9_]+)\n\ndocumentation =\n\t'\"' b:$(!'\"' a:. {return a})* '\"' {\n\t\treturn b.replace(/\\r\\n|\\r/g, '\\n');\n\t}\n\ntex =\n\t'$' b:$(!'$' a:. {return a})* '$' {\n\t\treturn b.replace(/\\r\\n|\\r/g, '\\n');\n\t}\n\ncomment =\n\t\"//\" (!newline .)*\n\t/ \"/*\" (!\"*/\" .)* \"*/\"\n\nnewline =\n\t\"\\r\\n\" / \"\\r\" / \"\\n\"\n\n// optional whitespace\n_ =\n\t([ \\t\\n\\r] / comment)*\n\n// mandatory whitespace\n__ =\n\t([ \\t\\n\\r] / comment)+\n\nsem =\n\t\";\""},function(t,e,n){"use strict";var r=this&&this.__awaiter||function(t,e,n,r){return new(n||(n=Promise))((function(a,i){function fulfilled(t){try{step(r.next(t))}catch(t){i(t)}}function rejected(t){try{step(r.throw(t))}catch(t){i(t)}}function step(t){t.done?a(t.value):function adopt(t){return t instanceof n?t:new n((function(e){e(t)}))}(t.value).then(fulfilled,rejected)}step((r=r.apply(t,e||[])).next())}))},a=this&&this.__importDefault||function(t){return t&&t.__esModule?t:{default:t}};Object.defineProperty(e,"__esModule",{value:!0});const i=a(n(17)),s=a(n(20)),o=a(n(22));e.default=class Program{constructor(t){if(this.scopeMap=new Map,!t)throw Error("no");this.parser=t}loadModule(t,e){return r(this,void 0,void 0,(function*(){return this.loadingModules=[],this.scope=yield this.loadModuleInternal(t,e)}))}loadModuleInternal(t,e){return r(this,void 0,void 0,(function*(){if(this.scopeMap.has(t))return this.scopeMap.get(t);var n=this.loadingModules.indexOf(t);if(n>=0){if(n==this.loadingModules.length-1)throw Error(`Cannot self import (${t})`);var r=this.loadingModules.slice(n).concat(t);throw Error(`Circular import detected (${r.join(" -> ")}). Sadly, circular import is currently not supported.`)}this.loadingModules.push(t);var{fileUri:a,code:i}=yield e(t),s=new o.default(a,null),l=this.parser.parse(i);if(yield this.feed(l,s,e),this.loadingModules.pop()!=t)throw Error("Something's wrong");return this.scopeMap.set(t,s),s}))}feed(t,e=this.scope,n){return r(this,void 0,void 0,(function*(){for(var r=0;r<t.length;r++){var a=t[r];switch(a._type){case"import":var s=yield this.loadModuleInternal(a.filename,n);e.importMap.set(a.filename,s);break;case"typedef":var o=i.default.type(a,e);if(e.hasType(o.name))throw e.error(`Type ${o.name} has already been declared`);e.addType(o);break;case"defv":var l=i.default.variable(a,e);if(e.hasVariable(l.name))throw e.error(`Definition ${l.name} has already been declared`);e.addVariable(l);break;case"defun":var u=i.default.fun(a,e);if(e.hasVariable(u.name))throw e.error(`Definition ${u.name} has already been declared`);e.addFun(u);break;case"defschema":var h=i.default.schema(a,e,null);if(e.hasSchema(h.name))throw e.error(`Schema ${h.name} has already been declared`);e.addSchema(h);break;default:throw Error("Unknown line type "+a._type)}}}))}evaluate(t){var e=new o.default("<repl>",this.scope);switch(t._type){case"typedef":return i.default.type(t,e);case"defv":return i.default.variable(t,e);case"defun":return i.default.fun(t,e);case"defschema":case"schemaexpr":return i.default.schema(t,e,null);case"tee":return i.default.tee(t,e,null);case"reduction":return i.default.reduction(t,e,null);case"schemacall":return i.default.schemacall(t,e,null);case"var":return i.default.metavar(t,e);default:throw Error("Unknown line type "+t._type)}}getProofExplorer(t,e){return s.default.get(this.scope,t,e)}}},function(t,e,n){"use strict";var r=this&&this.__importDefault||function(t){return t&&t.__esModule?t:{default:t}};Object.defineProperty(e,"__esModule",{value:!0});const a=r(n(10)),i=r(n(5)),s=r(n(7)),o=r(n(9)),l=r(n(6)),u=r(n(18)),h=r(n(3)),f=r(n(13)),c=n(1),d=r(n(4)),p=r(n(19));function typeObjToString(t){if("type"!=t._type)throw Error("Assertion failed");return t.ftype?"["+t.from.map(typeObjToString).join(", ")+" -> "+typeObjToString(t.to)+"]":t.name}function typeObjToNestedArr(t){if("type"!=t._type)throw Error("Assertion failed");if(t.ftype){if(!t.from||!t.to)throw Error("Assertion failed");return t.from.map(typeObjToNestedArr).concat([typeObjToNestedArr(t.to)])}if(!(t=t).name)throw Error("Assertion failed");return t.name}function varObjToString(t){switch(t.type){case"@":return"@"+t.name;case"$":case"normal":return""+t.name;default:throw Error("Unknown type "+t.type)}}class PI{static type(t,e){if("typedef"!=t._type)throw Error("Assertion failed");var n=e.extend("type",t.name,t.location),r=t.expr?n.getType(typeObjToNestedArr(t.expr)):null,a=t.name,i=t.doc;return r?new c.SimpleObjectType({doc:i,name:a,expr:r},n.trace):new c.SimpleObjectType({doc:i,name:a,expr:null},n.trace)}static variable(t,e){if(!["defv","var"].includes(t._type))throw Error("Assertion failed");var n=e.extend("variable",t.name,t.location);if("var"==t._type){if("normal"!=t.type)throw n.error(`Variable type ${t.type} not allowed`);if(!n.hasVariable(t.name))throw n.error("Undefined identifier "+varObjToString(t));return n.getVariable(t.name)}if(!n.hasType(typeObjToNestedArr(t.type)))throw n.error(`Type ${typeObjToString(t.type)} is not defined`);var r=n.getType(typeObjToNestedArr(t.type)),a=t.expr?PI.expr0(t.expr,n):null;return t.isParam?new l.default({doc:t.doc,tex:t.tex,type:r,name:t.name,selector:t.selector||null},n.trace):new d.default({doc:t.doc,tex:t.tex,sealed:!!t.sealed,type:r,name:t.name,expr:a||null},n.trace)}static fun(t,e){if("defun"!=t._type&&"funexpr"!=t._type)throw Error("Assertion failed");var n=e.extend("fun","defun"==t._type?t.name:"<anonymous>",t.location),r=null,a=null,i=!1,s=null,u=null,h=null;if("defun"==t._type){if(r=t.doc,a=t.tex,i=t.sealed,!n.hasType(typeObjToNestedArr(t.rettype)))throw n.error(`Type ${typeObjToString(t.rettype)} is not defined`);s=n.getType(typeObjToNestedArr(t.rettype)),u=t.name}var f=t.params.map((t=>{var e=PI.variable(t,n);if(n.hasOwnVariable(e.name))throw n.error(`Parameter ${e.name} has already been declared`);if(!(e instanceof l.default))throw Error("Something's wrong");return n.addVariable(e),e}));return t.expr&&(h=PI.expr0(t.expr,n)),new o.default({annotations:[],sealed:i,rettype:s,name:u,params:f,expr:h,doc:r,tex:a},n.trace)}static funcall(t,e){if("funcall"!=t._type)throw Error("Assertion failed");var n=e.extend("funcall","name"in t.schema?t.schema.name:null,t.location),r=PI.expr0(t.schema,n),a=t.args.map((t=>PI.expr0(t,n)));return new s.default({fun:r,args:a},n.trace)}static metaexpr(t,e,n){if(!["tee","reduction","schemacall","schemaexpr","var","with"].includes(t._type))throw Error("Assertion failed");var r=e;switch(t._type){case"tee":return PI.tee(t,r,n);case"reduction":return PI.reduction(t,r,n);case"schemacall":return PI.schemacall(t,r,n);case"schemaexpr":return PI.schema(t,r,n);case"var":return PI.metavar(t,r);case"with":return PI.with(t,r,n);default:throw Error("wut")}}static expr0(t,e){if(!["funcall","funexpr","var"].includes(t._type))throw console.log(t),Error("Assertion failed");var n=e;switch(t._type){case"funcall":return PI.funcall(t,n);case"funexpr":return PI.fun(t,n);case"var":return PI.variable(t,n);default:throw Error("wut")}}static metavar(t,e){if("var"!=t._type)throw Error("Assertion failed");var n=e;switch(t.type){case"@":if(t.name.match(/^h[0-9]+$/)){var r=Number(t.name.slice(1))-1;if(r>=n.hypotheses.length)throw n.error(`Hypothesis #${r+1} not found`);return n.hypotheses[r]}throw n.error("Unknown selector query "+varObjToString(t));case"$":if(!n.has$(t.name))throw n.error(varObjToString(t)+" is not defined");return n.get$(t.name);case"normal":if(!n.hasSchema(t.name))throw n.error(`Schema ${varObjToString(t)} is not defined`);return n.getSchema(t.name);default:throw n.error("Unknown type "+t.type)}}static with(t,e,n){if("with"!=t._type)throw Error("Assertion failed");var r=e.extend("with",null,t.location),a=PI.variable(t.with,r);if(r.hasOwnVariable(a.name))throw r.error(`Parameter ${a.name} has already been declared`);if(!(a instanceof d.default))throw Error("Something's wrong");r.addVariable(a);var i=t.def$s.map((t=>{var e=PI.def$(t,r,n);if(r.hasOwn$(e.name))throw r.error(t.name+" has already been declared");return r.add$(e)})),s=PI.metaexpr(t.expr,r,n);return new p.default({variable:a,def$s:i,expr:s},r.trace)}static tee(t,e,n){if("tee"!=t._type)throw Error("Assertion failed");var r=e.extend("tee",null,t.location),a=t.left.map((t=>PI.metaexpr(t,r,n))),i=r.extend("tee.right",null,t.right.location);a.forEach((t=>i.hypotheses.push(t)));var s=t.def$s.map((t=>{var e=PI.def$(t,i,n);if(i.hasOwn$(e.name))throw i.error(t.name+" has already been declared");return i.add$(e)})),o=PI.metaexpr(t.right,i,n);return new f.default({left:a,def$s:s,right:o},r.trace)}static def$(t,e,n){if("def$"!=t._type)throw Error("Assertion failed");var r=e.extend("def$",t.name,t.location),a=PI.metaexpr(t.expr,r,n);return new i.default({name:t.name,expr:a},r.trace)}static schema(t,e,n){if("defschema"!=t._type&&"schemaexpr"!=t._type)throw Error("Assertion failed");var r="defschema"==t._type?t.name:null,i=e.extend("schema",r,t.location),s="schema",o=null,u=[],f=n;if("defschema"==t._type){if(s=t.schemaType,o=t.doc,u=t.annotations,n)throw console.log(n),Error("duh");var c=t.using.map((t=>{if(!i.hasVariable(t))throw i.error(`Variable ${t} is not defined`);var e=i.getVariable(t);if(!e.expr)throw i.error(t+" is not a macro");return e}));f=new a.default(c)}var d=t.params.map((t=>{var e=PI.variable(t,i);if(i.hasOwnVariable(e.name))throw i.error(`Parameter ${e.name} has already been declared`);if(!(e instanceof l.default))throw Error("Something's wrong");return i.addVariable(e),e})),p=t.def$s.map((t=>{var e=PI.def$(t,i,f);if(i.hasOwn$(e.name))throw i.error(t.name+" has already been declared");return i.add$(e)})),m=PI.metaexpr(t.expr,i,f);return new h.default({doc:o,tex:null,annotations:u,schemaType:s,name:r,params:d,context:f,def$s:p,expr:m},i.trace)}static schemacall(t,e,n){if("schemacall"!=t._type)throw Error("Assertion failed");var r=e.extend("schemacall","name"in t.schema?t.schema.name:null,t.location),a=PI.metaexpr(t.schema,r,n),i=t.args.map((t=>PI.expr0(t,r)));return new s.default({fun:a,args:i},r.trace)}static reduction(t,e,n){if("reduction"!=t._type)throw Error("Assertion failed");if(!n)throw Error("duh");var r=e.extend("reduction","name"in t.subject?t.subject.name:null,t.location),a=PI.metaexpr(t.subject,r,n),i=t.args?t.args.map((t=>t&&PI.expr0(t,r))):null,s=t.antecedents.map((t=>PI.metaexpr(t,r,n))),o=t.as&&PI.metaexpr(t.as,r,n);return new u.default({subject:a,args:i,antecedents:s,as:o},n,r.trace)}}e.default=PI},function(t,e,n){"use strict";var r=this&&this.__createBinding||(Object.create?function(t,e,n,r){void 0===r&&(r=n),Object.defineProperty(t,r,{enumerable:!0,get:function(){return e[n]}})}:function(t,e,n,r){void 0===r&&(r=n),t[r]=e[n]}),a=this&&this.__setModuleDefault||(Object.create?function(t,e){Object.defineProperty(t,"default",{enumerable:!0,value:e})}:function(t,e){t.default=e}),i=this&&this.__importStar||function(t){if(t&&t.__esModule)return t;var e={};if(null!=t)for(var n in t)"default"!==n&&Object.prototype.hasOwnProperty.call(t,n)&&r(e,t,n);return a(e,t),e},s=this&&this.__importDefault||function(t){return t&&t.__esModule?t:{default:t}};Object.defineProperty(e,"__esModule",{value:!0});const o=s(n(10)),l=s(n(2)),u=s(n(7)),h=i(n(0)),f=n(12),c=s(n(6)),d=s(n(3)),p=s(n(13)),m=n(1),_=s(n(4));class Reduction extends h.default{constructor({antecedents:t,subject:e,args:n,as:r},a,i){if(n){let t=e.type.resolve().from,r=n.map((t=>t&&t.type));if(t.length!=r.length)throw h.default.error(`Invalid number of arguments (expected ${t.length}): ${r.length}`,i);for(var s=0;s<t.length;s++)if(r[s]&&!t[s].equals(r[s]))throw h.default.error(`Argument #${s+1} has illegal argument type (expected ${t[s]}): ${r[s]}`,i)}if(e instanceof l.default){e.params.forEach(((t,e)=>{if(!(n&&n[e]||t.selector))throw h.default.error(`Argument #${e+1} could not be guessed`,i)}));var o=e.params.map(((s,o)=>{if(n&&n[o])return n[o];var l=e.expr.expandMeta(!1);if(!(l instanceof p.default))throw Error("wut");return Reduction.guess(s.selector,l.left,t,l.right,r,a,i)}));e=new u.default({fun:e,args:o},i)}else if(n)throw h.default.error("Something's wrong",i);if(!(e.type instanceof m.TeeType))throw h.default.error("Subject is not reducible",i);if(!(t instanceof Array)||t.map((t=>t instanceof h.default)).some((t=>!t)))throw h.default.error("Assertion failed",i);var f=e.type.left,c=t.map((t=>t.type));if(f.length!=c.length)throw h.default.error(`Invalid number of arguments (expected ${f.length}): ${c.length}`,i);for(let t=0;t<f.length;t++)if(!f[t].equals(c[t]))throw h.default.error(`Illegal argument type (expected ${f[t]}): ${c[t]}`,i);super(null,null,e.type.right,i),this.subject=e,this.antecedents=t;var d=e.expandMeta(!0);if(!(d instanceof p.default))throw h.default.error("Assertion failed",i);this.requiredAntecedents=d.left,this.antecedentEqualsResults=Array(d.left.length).fill(0).map((()=>[]));var _=t.map((t=>t.expandMeta(!0)));for(let e=0;e<d.left.length;e++){if(!(g=d.left[e].equals(_[e],a)))throw h.default.error(`LHS #${e+1} failed to match:\n\n--- EXPECTED ---\n${d.left[e].expandMeta(!0)}\n----------------\n\n--- RECEIVED ---\n${t[e].expandMeta(!0)}\n----------------`,i);this.antecedentEqualsResults[e]=g}if(this.preFormatConsequent=d.right,r){var g;if(!(g=d.right.equals(r,a)))throw h.default.error(`RHS failed to match:\n\n--- EXPECTED ---\n${d.right.expandMeta(!0)}\n----------------\n\n--- RECEIVED (from [as ...]) ---\n${r.expandMeta(!0)}\n----------------`,i);this.rightEqualsResult=g,this.consequent=r}else this.consequent=d.right}isProvedInternal(t){return this.subject.isProved(t)&&this.antecedents.every((e=>e.isProved(t)))}substitute(t){return this.consequent.substitute(t)}expandMetaInternal(t){return this.consequent.expandMeta(t)}getEqualsPriority(){return h.EqualsPriority.FIVE}equalsInternal(t,e){return this.consequent.equals(t,e)}getProofInternal(t,e,n){var r,a=[],i=this.antecedents.map(((r,i)=>{if(!this.antecedentEqualsResults[i].length){if(t.has(r))return t.get(r);if(e.has(r))return e.get(r)}var s=t.has(r)?t.get(r):e.has(r)?e.get(r):null,o=s?[]:r.getProof(t,e,n);return this.antecedentEqualsResults[i].length&&o.push({_type:"bydef",ctr:n.next(),ref:s||o[o.length-1].ctr,expr:this.requiredAntecedents[i],of:this.antecedentEqualsResults[i]}),a.push(o),this.antecedentEqualsResults[i].length?n.peek():o[o.length-1].ctr})),s=null,o=[],h=t.get(this.subject)||e.get(this.subject)||!!(this.subject instanceof u.default&&e.has(this.subject.fun))&&(s=this.subject.args,e.get(this.subject.fun))||((r=this.subject)instanceof l.default&&r.name||r instanceof u.default&&f.isNameable(r.fun)&&r.fun.name?this.subject:(o=this.subject.getProof(t,e,n))[o.length-1].ctr),c=[...a.flat(),...o];return this.rightEqualsResult&&this.rightEqualsResult.length?c.push({_type:"E",ctr:n.next(),subject:h,args:s,antecedents:i,reduced:this.preFormatConsequent},{_type:"bydef",ref:n.peek(),ctr:n.next(),expr:this.consequent,of:this.rightEqualsResult}):c.push({_type:"E",ctr:n.next(),subject:h,args:s,antecedents:i,reduced:this.consequent}),c}static guess(t,e,n,r,a,i,s){if(0==t.length)throw h.default.error("wut",s);var f,m;if("r"==t[0]){if(!a)throw h.default.error(`Cannot dereference @${t} (at 0): expected output is not given`,s);f=r,m=a}else{var g=Number(t[0]);if(!(1<=g&&g<=n.length))throw h.default.error(`Cannot dereference @${t} (at 0): antecedent index out of range`,s);f=e[g-1],m=n[g-1]}return function recurse(e,n,r,a){if(r=r.expandMeta(!0),t.length<=e)return r;if(/^[0-9]$/.test(t[e])){var f=Number(t[e]);if(n instanceof p.default&&r instanceof p.default){if(n.left.length!=r.left.length)throw h.default.error(`Cannot dereference @${t} (at ${e}): antecedent length mismatch`,s);if(!(1<=f&&f<=r.left.length))throw h.default.error(`Cannot dereference @${t} (at ${e}): antecedent index out of range`,s);return recurse(e+1,n.left[f-1],r.left[f-1],a)}for(;;){for(;r instanceof _.default&&r.expr;)r=r.expr;if(!(n instanceof u.default&&r instanceof u.default))throw h.default.error(`Cannot dereference @${t} (at ${e})`,s);if(n.fun.equals(r.fun,i))break;if(!r.isExpandable(i))throw h.default.error(`Cannot dereference @${t} (at ${e}): ${r}`,s);r=r.expandOnce(i).expanded}if(!(1<=f&&f<=r.args.length))throw h.default.error(`Cannot dereference @${t} (at ${e})`,s);return recurse(e+1,n.args[f-1],r.args[f-1],a)}if("r"==t[e]){if(!(n instanceof p.default&&r instanceof p.default))throw h.default.error(`Cannot dereference @${t} (at ${e})`,s);return recurse(e+1,n.right,r.right,a)}if("c"==t[e]){if(!(n instanceof l.default&&!n.name&&r instanceof l.default)||r.name)throw h.default.error(`Cannot dereference @${t} (at ${e})`,s);if(n.length!=r.length)throw h.default.error(`Cannot dereference @${t} (at ${e}): parameter length mismatch`,s);for(var m=[],g=0;g<n.length;g++){if(!n.params[g].type.equals(r.params[g].type))throw h.default.error(`Cannot dereference @${t} (at ${e}): parameter type mismatch`,s);m.push(new c.default({tex:r.params[g].tex,type:n.params[g].type,name:r.params[g].name,selector:null},s))}return recurse(e+1,n.call(m),r.call(m),m.concat(a))}if("f"==t[e]){if(e!=t.length-1)throw h.default.error(`Cannot dereference @${t} (at ${e}): invalid selector`,s);return r instanceof u.default&&r.args.length==a.length&&r.args.every(((t,e)=>t==a[e]))?r.fun:new d.default({doc:null,tex:null,annotations:[],schemaType:"schema",name:null,params:a,context:new o.default,def$s:[],expr:r},s)}throw h.default.error(`Cannot dereference @${t} (at ${e}): invalid selector`,s)}(1,f,m,[])}toIndentedString(t,e){var n=this.antecedents.map((e=>e.toIndentedString(t+1)));return n.join("").length<=50?(n=this.antecedents.map((e=>e.toIndentedString(t))),[this.subject.toIndentedString(t)+"[",n.join(", "),"]"].join("")):[this.subject.toIndentedString(t)+"[","\t"+n.join(",\n"+"\t".repeat(t+1)),"]"].join("\n"+"\t".repeat(t))}toTeXString(t,e){return`${this.subject.toTeXString(!1)}[${this.antecedents.map((t=>t.toTeXString(h.default.PREC_COMMA))).join(", ")}]`}}e.default=Reduction},function(t,e,n){"use strict";var r=this&&this.__importDefault||function(t){return t&&t.__esModule?t:{default:t}};Object.defineProperty(e,"__esModule",{value:!0});const a=r(n(0));class With extends a.default{constructor({variable:t,def$s:e,expr:n},r){super(null,null,n.type,r),this.variable=t,this.def$s=e,this.expr=n}substitute(t){if(t.has(this.variable))throw Error("Parameter collision");return t=new Map(t),this.expandMeta(!1).substitute(t)}expandMetaInternal(t){var e=new Map;return e.set(this.variable,this.variable.expr),this.expr.substitute(e).expandMeta(t)}getEqualsPriority(t){throw new Error("Method not implemented.")}equalsInternal(t,e){throw new Error("Method not implemented.")}isProvedInternal(t){return this.expr.isProved(t)}getProofInternal(t,e,n,r){return e=new Map(e),[{_type:"def",ctr:n.next(),var:this.variable},...this.def$s.map((r=>{var a=r.expr.getProof(t,e,n),i=a[a.length-1].ctr;return e.set(r,i),a})).flat(1),...this.expr.getProof(t,e,n)]}toIndentedString(t,e){throw new Error("Method not implemented.")}toTeXString(t,e){throw new Error("Method not implemented.")}}e.default=With},function(t,e,n){"use strict";var r=this&&this.__importDefault||function(t){return t&&t.__esModule?t:{default:t}};Object.defineProperty(e,"__esModule",{value:!0});const a=r(n(21)),i=r(n(3));e.default=class ProofExplorer{static get(t,e,n){var r="&#x25C7;";if(!t.hasSchema(e))throw Error("wut");var s=t.getSchema(e);if(!(s instanceof i.default))throw Error("wut");function getHtmlLine(t,e,r,a,i){for(var s=e.length,{bbb:o=!1,rrb:l=!1}=i||{},h=e.map(((t,e,r)=>`<td class="${l&&e==r.length-1?"rrb":"brb"}">${t.map((t=>n(t.toTeXStringWithId(!0)))).join(", ")}</td>`)).join(""),f=0;f<e.length;f++)for(;e[f].length;)e[f].pop();return`<tr><th>${t}</th>${h}<td ${o?'class="bbb" ':""}colspan="${u-s}">${r}</td>${a instanceof Array?a.map((t=>`<td>${t}</td>`)).join(""):`<td colspan="2">${a}</td>`}</tr>`}function exprToHtml(t,e){return"number"==typeof t?`<b>${t}</b>`:t instanceof Array?`<b>${t[0]}&ndash;${t[1]}</b>`:n(e?t.expandMeta(!0).toTeXString(!0,!0):t.toTeXString(!0,!0))}var o=s.getProof(new Map,new Map,new a.default,!0),l=o[0].$lines.concat(o[0].lines),u=function recurse(t){return Math.max(...t.map((t=>{switch(t._type){case"V":return Math.max(recurse(t.$lines),recurse(t.lines))+1;case"T":return Math.max(recurse(t.leftlines),recurse(t.rightlines))+1;default:return 1}})))}(l),h='<table class="explorer">';return h+=`<tr><th>#</th><th colspan="${u}">expr</th><th colspan="2">rule</th></tr>`,h+=function tree2html(t,e){return t.map((t=>{switch(t._type){case"V":var n=t.params.slice();return tree2html(t.$lines,e.concat([n]))+tree2html(t.lines,e.concat([n]));case"T":var a=e.concat([[]]),i="";if(0==t.leftlines.length)i+=getHtmlLine("",Array(e.length+1).fill([]),"","",{bbb:!0,rrb:!0});else i+=t.leftlines.map(((t,e,n)=>getHtmlLine(t.ctr,a,exprToHtml(t.expr,!0),"assumption",{bbb:e==n.length-1,rrb:!0}))).join("");return i+=tree2html(t.rightlines,a);case"?":return getHtmlLine(t.ctr,e,exprToHtml(t.expr,!0),"???");case"H":throw Error("no");case"R":return getHtmlLine(t.ctr,e,exprToHtml(t.expr,!0),[r,exprToHtml(t.num)]);case"RS":case"RCX":return getHtmlLine(t.ctr,e,exprToHtml(t.expr,!0),[r,exprToHtml(t.expr)]);case"RC":return getHtmlLine(t.ctr,e,exprToHtml(t.expr,!0),[r,`${exprToHtml(t.schema)} (${t.args.map((t=>exprToHtml(t))).join(", ")})`]);case"E":return getHtmlLine(t.ctr,e,exprToHtml(t.reduced,!0),["&#x25BC;",`${exprToHtml(t.subject)}${t.args?" ("+t.args.map((t=>exprToHtml(t))).join(", ")+")":""} [${t.antecedents.map((t=>exprToHtml(t))).join(", ")}]`]);case"NP":return getHtmlLine(t.ctr,e,exprToHtml(t.expr,!0),'<b class="red">not proved</b>');case"def":return getHtmlLine(t.ctr,e,exprToHtml(t.var),"definition");case"bydef":return getHtmlLine(t.ctr,e,exprToHtml(t.expr),`by definition of ${t.of.map((t=>exprToHtml(t))).join(", ")} [${exprToHtml(t.ref)}]`);default:throw Error("Unknown type "+t._type)}})).join("")}(l,[]),h+="</table>"}}},function(t,e,n){"use strict";Object.defineProperty(e,"__esModule",{value:!0});e.default=class Counter{constructor(t=0){this.n=t}peek(){return this.n}next(){return++this.n}}},function(t,e,n){"use strict";var r=this&&this.__importDefault||function(t){return t&&t.__esModule?t:{default:t}};Object.defineProperty(e,"__esModule",{value:!0});const a=r(n(5)),i=r(n(2)),s=r(n(9)),o=n(1),l=r(n(4)),u=r(n(23));class Scope{constructor(t,e,n){if(this.importMap=new Map,this.typedefMap=new Map,this.defMap=new Map,this.schemaMap=new Map,this.$Map=new Map,this.hypotheses=[],this.fileUri=t,this.parent=e,this.root=e?e.root:this,n&&!(n instanceof u.default))throw Error("Assertion failed");this.trace=n||new u.default(t)}extend(t,e,n){var r=new Scope(this.fileUri,this,this.trace.extend({type:t,name:e,location:n}));return this.hypotheses.forEach((t=>r.hypotheses.push(t))),r}error(t){return this.trace.error(t)}hasOwnType(t){if("string"==typeof t)return this.typedefMap.has(t)||[...this.importMap.values()].some((e=>e.hasOwnType(t)));if(!(t instanceof Array))throw this.error("Argument is malformed");if(t.length<2)throw this.error("Illegal array length");return t.map((t=>this.hasOwnType(t))).every((t=>t))}hasType(t){if("string"==typeof t)return this.hasOwnType(t)||!!this.parent&&this.parent.hasType(t);if(!(t instanceof Array))throw this.error("Argument is malformed");if(t.length<2)throw this.error("Illegal array length");return t.map((t=>this.hasType(t))).every((t=>t))}addType(t){if(!(t instanceof o.SimpleObjectType))throw this.error("Illegal argument type");if(!t.name)throw this.error("Something's wrong");if(this.hasOwnType(t.name))throw this.error(`Type ${t.name} has already been declared`);return this.typedefMap.set(t.name,t),t}getType(t){if("string"==typeof t){if(!this.hasType(t))throw this.error(`Type ${t} is not defined`);return this.typedefMap.has(t)?this.typedefMap.get(t):!!this.parent&&this.parent.getType(t)||[...this.importMap.values()].filter((e=>e.hasType(t)))[0].getType(t)}if(!(t instanceof Array))throw this.error("Argument is malformed");if(t.length<2)throw this.error("Illegal array length");var e=t.slice(0,t.length-1).map((t=>this.getType(t))),n=this.getType(t[t.length-1]);return new o.FunctionalObjectType({from:e,to:n},this.trace)}hasOwnVariable(t){return this.defMap.has(t)||[...this.importMap.values()].some((e=>e.hasOwnVariable(t)))}hasVariable(t){return this.hasOwnVariable(t)||!!this.parent&&this.parent.hasVariable(t)}addVariable(t){if(!(t instanceof l.default))throw this.error("Illegal argument type");if(this.hasOwnVariable(t.name))throw this.error(`Definition ${t.name} has already been declared`);return this.defMap.set(t.name,t),t}addFun(t){if(!(t instanceof s.default))throw this.error("Illegal argument type");if(!t.name)throw this.error("Cannot add anonymous fun to scope");if(this.hasOwnVariable(t.name))throw this.error(`Definition ${t.name} has already been declared`);return this.defMap.set(t.name,t),t}getVariable(t){if(!this.hasVariable(t))throw this.error(`Definition ${t} is not defined`);return this.defMap.has(t)?this.defMap.get(t):!!this.parent&&this.parent.getVariable(t)||[...this.importMap.values()].filter((e=>e.hasVariable(t)))[0].getVariable(t)}hasOwnSchema(t){return this.schemaMap.has(t)||this.defMap.has(t)||[...this.importMap.values()].some((e=>e.hasOwnSchema(t)))}hasSchema(t){return this.hasOwnSchema(t)||!!this.parent&&this.parent.hasSchema(t)}addSchema(t){if(!(t instanceof i.default))throw this.error("Illegal argument type");if(this.hasOwnSchema(t.name))throw this.error(`Schema ${t.name} has already been declared`);return this.schemaMap.set(t.name,t),t}getSchema(t){if(!this.hasSchema(t))throw this.error(`Schema ${t} is not defined`);return this.schemaMap.has(t)?this.schemaMap.get(t):this.defMap.has(t)?this.defMap.get(t):!!this.parent&&this.parent.getSchema(t)||[...this.importMap.values()].filter((e=>e.hasSchema(t)))[0].getSchema(t)}hasOwn$(t){return this.$Map.has(t)||[...this.importMap.values()].some((e=>e.hasOwn$(t)))}has$(t){return this.hasOwn$(t)||!!this.parent&&this.parent.has$(t)}add$(t){if(!(t instanceof a.default))throw this.error("Illegal argument type");if(this.hasOwn$(t.name))throw this.error(`$ variable ${t.name} has already been declared`);return this.$Map.set(t.name,t),t}get$(t){if(!this.has$(t))throw this.error(`$ variable ${t} is not defined`);return this.$Map.has(t)?this.$Map.get(t):!!this.parent&&this.parent.get$(t)||[...this.importMap.values()].filter((e=>e.has$(t)))[0].get$(t)}}e.default=Scope},function(t,e,n){"use strict";Object.defineProperty(e,"__esModule",{value:!0});class StackTrace{constructor(t,e){this.fileUri=t,this.stack=e||[]}extend(t){return new StackTrace(this.fileUri,[t].concat(this.stack))}error(t){var e=this.fileUri||"<unknown>";return new Error(t+"\n\tat "+(this.stack.length?this.stack.map((({type:t,name:n,location:r})=>`${t} ${n||"<anonymous>"} (${e}:${r.start.line}:${r.start.column})`)).join("\n\tat "):`<root> (${e}:1:1)`))}}e.default=StackTrace}])}));
//# sourceMappingURL=math.min.js.map