{"version":3,"sources":["webpack://math/webpack/universalModuleDefinition","webpack://math/webpack/bootstrap","webpack://math/./src/nodes/Node.ts","webpack://math/./src/nodes/Metaexpr.ts","webpack://math/./src/nodes/ObjectType.ts","webpack://math/./src/nodes/Fun.ts","webpack://math/./src/nodes/Variable.ts","webpack://math/./src/nodes/$Variable.ts","webpack://math/./src/nodes/Schema.ts","webpack://math/./src/nodes/Funcall.ts","webpack://math/./src/nodes/Expr0.ts","webpack://math/./src/nodes/MetaType.ts","webpack://math/./src/nodes/Parameter.ts","webpack://math/./src/nodes/ObjectFun.ts","webpack://math/./src/nodes/Type.ts","webpack://math/./src/nodes/Nameable.ts","webpack://math/./src/nodes/Tee.ts","webpack://math/./src/entry.js","webpack://math/./src/grammar.pegjs","webpack://math/./src/Program.ts","webpack://math/./src/PegInterface.ts","webpack://math/./src/ExecutionContext.ts","webpack://math/./src/nodes/Reduction.ts","webpack://math/./src/nodes/With.ts","webpack://math/./src/ProofExplorer.ts","webpack://math/./src/Counter.ts","webpack://math/./src/Scope.ts","webpack://math/./src/StackTrace.ts"],"names":["webpackUniversalModuleDefinition","root","factory","exports","module","define","amd","self","this","installedModules","__webpack_require__","moduleId","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","getDefault","getModuleExports","object","property","prototype","hasOwnProperty","p","s","ctr","Node","trace","doc","tex","_id","toIndentedString","message","error","Error","prec","Array","length","console","log","my","normalizePrecedence","precedence","your","replace","code","match","g1","regex","RegExp","join","capitalize","charCodeAt","commandName","toLowerCase","toUpperCase","substring","escapeTeX","id","args","ret","shouldConsolidate","_match","PREC_FUNEXPR","PREC_COMMA","PREC_COLONEQQ","EqualsPriority","Metaexpr","type","super","andFuncalls","expandMetaCache","expandMetaInternal","obj","context","equals","getEqualsPriority","equalsInternal","hypotheses","isProvedInternal","hypnumMap","$Map","has","_type","next","num","expr","getProofInternal","ObjectType","origin","isFunctional","isBaseType","base","functional","from","map","f","some","e","to","resolved","resolve","toSimpleString","indent","isSimple","toTeXString","Fun","annotations","sealed","rettype","params","parsed","parseTeX","variable","isProved","ONE","placeholders","types","push","selector","usedMacrosList","thisCall","fun","objCall","concat","Map","set","substitute","start","peek","$lines","def$s","forEach","$","lines","getProof","$num","Variable","canUse","ZERO","FOUR","tmp","makeTeXName","$Variable","expandMeta","FIVE","Schema","schemaType","hyps","isProvedCache","cache","_context","repeat","proved","toTeXStringWithId","Funcall","isNameable","resolvedType","paramTypes","argTypes","arg","callee","isExpandable","isCallable","used","expanded","calleeExpanded","expandOnce","THREE","T","q","thisIsExpandable","objIsExpandable","every","_","schema","schemalines","funcallToTeXString","Expr0","MetaType","left","right","Parameter","ObjectFun","makeTeX","Type","Tee","lef","TWO","leftlines","rightlines","flat","grammar","default","Program","parser","scopeMap","filename","loader","loadingModules","scope","loadModuleInternal","loadingModuleIndex","indexOf","cycle","slice","fileUri","parse","feed","pop","line","scope2","importMap","hasType","addType","hasVariable","addVariable","addFun","hasSchema","addSchema","tee","reduction","schemacall","metavar","ktx","typeObjToString","ftype","typeObjToNestedArr","varObjToString","PI","parentScope","extend","location","getType","includes","getVariable","expr0","isParam","tvo","tv","hasOwnVariable","with","funcall","hypnum","Number","has$","get$","getSchema","$v","def$","hasOwn$","add$","metaexpr","scopeRight","oldContext","using","subject","g","antecedents","as","ExecutionContext","usingList","Reduction","derefs","guess","antecedentTypes","requiredAntecedents","antecedentEqualsResults","fill","antecedentsExpanded","preFormatConsequent","rightEqualsResult","consequent","antecedentLinesList","antecedentNums","ref","of","subjectlines","subjectnum","reduced","parameter","argument","recurse","ptr","test","With","var","ProofExplorer","DIAMOND","getHtmlLine","h1","h2","options","padding","bbb","rrb","htmlLeft","a","ncols","exprToHtml","expand","tree","innertree","Math","max","html","tree2html","newleft","v","Counter","Scope","parent","typedefMap","defMap","schemaMap","baseType","child","h","values","hasOwnType","broadcast","filter","hasOwnSchema","StackTrace","stack","element","column"],"mappings":"CAAA,SAAUA,iCAAiCC,EAAMC,GAC1B,iBAAZC,SAA0C,iBAAXC,OACxCA,OAAOD,QAAUD,IACQ,mBAAXG,QAAyBA,OAAOC,IAC9CD,OAAO,GAAIH,GACe,iBAAZC,QACdA,QAAc,KAAID,IAElBD,EAAW,KAAIC,IARjB,CASmB,oBAATK,KAAuBA,KAAOC,MAAM,WAC9C,O,YCTE,IAAIC,EAAmB,GAGvB,SAASC,oBAAoBC,GAG5B,GAAGF,EAAiBE,GACnB,OAAOF,EAAiBE,GAAUR,QAGnC,IAAIC,EAASK,EAAiBE,GAAY,CACzCC,EAAGD,EACHE,GAAG,EACHV,QAAS,IAUV,OANAW,EAAQH,GAAUI,KAAKX,EAAOD,QAASC,EAAQA,EAAOD,QAASO,qBAG/DN,EAAOS,GAAI,EAGJT,EAAOD,QA0Df,OArDAO,oBAAoBM,EAAIF,EAGxBJ,oBAAoBO,EAAIR,EAGxBC,oBAAoBQ,EAAI,SAASf,EAASgB,EAAMC,GAC3CV,oBAAoBW,EAAElB,EAASgB,IAClCG,OAAOC,eAAepB,EAASgB,EAAM,CAAEK,YAAY,EAAMC,IAAKL,KAKhEV,oBAAoBgB,EAAI,SAASvB,GACX,oBAAXwB,QAA0BA,OAAOC,aAC1CN,OAAOC,eAAepB,EAASwB,OAAOC,YAAa,CAAEC,MAAO,WAE7DP,OAAOC,eAAepB,EAAS,aAAc,CAAE0B,OAAO,KAQvDnB,oBAAoBoB,EAAI,SAASD,EAAOE,GAEvC,GADU,EAAPA,IAAUF,EAAQnB,oBAAoBmB,IAC/B,EAAPE,EAAU,OAAOF,EACpB,GAAW,EAAPE,GAA8B,iBAAVF,GAAsBA,GAASA,EAAMG,WAAY,OAAOH,EAChF,IAAII,EAAKX,OAAOY,OAAO,MAGvB,GAFAxB,oBAAoBgB,EAAEO,GACtBX,OAAOC,eAAeU,EAAI,UAAW,CAAET,YAAY,EAAMK,MAAOA,IACtD,EAAPE,GAA4B,iBAATF,EAAmB,IAAI,IAAIM,KAAON,EAAOnB,oBAAoBQ,EAAEe,EAAIE,EAAK,SAASA,GAAO,OAAON,EAAMM,IAAQC,KAAK,KAAMD,IAC9I,OAAOF,GAIRvB,oBAAoB2B,EAAI,SAASjC,GAChC,IAAIgB,EAAShB,GAAUA,EAAO4B,WAC7B,SAASM,aAAe,OAAOlC,EAAgB,SAC/C,SAASmC,mBAAqB,OAAOnC,GAEtC,OADAM,oBAAoBQ,EAAEE,EAAQ,IAAKA,GAC5BA,GAIRV,oBAAoBW,EAAI,SAASmB,EAAQC,GAAY,OAAOnB,OAAOoB,UAAUC,eAAe5B,KAAKyB,EAAQC,IAGzG/B,oBAAoBkC,EAAI,GAIjBlC,oBAAoBA,oBAAoBmC,EAAI,I,gFChFrD,IAAIC,EAAM,EAIV,MAA8BC,KAY7B,YAAaC,EAAmBC,EAAaC,GAC5C1C,KAAK2C,MAAQL,EACbtC,KAAKwC,MAAQA,EACbxC,KAAKyC,IAAMA,EACXzC,KAAK0C,IAAMA,EAGL,WACN,OAAO1C,KAAK4C,iBAAiB,GAMvB,MAAMC,GACZ,OAAON,KAAKO,MAAMD,EAAS7C,KAAKwC,OAG1B,aAAaK,EAAiBL,GACpC,OAAIA,EACIA,EAAMM,MAAMD,GAEZ,IAAIE,MAAMF,GAQZ,2BAA2BG,GACjC,IAAa,IAATA,EAAgB,MAAO,CAAC,EAAG,GAC/B,IAAa,IAATA,EAAe,MAAO,CAAC,EAAG,GAC9B,GAAmB,iBAARA,EAAkB,MAAO,CAAC,EAAGA,GAExC,KAAMA,aAAgBC,OAAwB,GAAfD,EAAKE,QAEnC,MADAC,QAAQC,IAAIJ,GACND,MAAM,OAGb,OAAOC,EAGD,kBAAkBA,GACxB,IAAIK,EAAKd,KAAKe,oBAAoBtD,KAAKuD,aAAc,GACpDC,EAAOjB,KAAKe,oBAAoBN,IAAQ,GAEzC,OAAa,GAATK,EAAG,IAAoB,GAATA,EAAG,OAEZA,EAAG,GAAKG,EAAK,IAAMH,EAAG,IAAMG,EAAK,IAAMH,EAAG,GAAKG,EAAK,IAGvD,iBAAiBnB,GACvB,OAAOA,EAAEoB,QAAQ,2BAA2BjD,IAAK,CAChD,IAAK,MAAO,IAAK,MAAO,EAAK,MAC7B,IAAK,MAAO,EAAK,MAAO,IAAK,MAC7B,IAAK,MACL,IAAK,mBACL,IAAK,oBACL,KAAM,mBACJA,MAGG,gBAAgBkC,GACtB,IAAIa,GAAyB,EAEzBG,EAAOhB,EAAIe,QAAQ,qBAAqB,CAACE,EAAOC,KACnDL,EAAkB,EAALK,EACN,MAGR,MAAO,CAACL,aAAYG,QAGd,mBAAmB/C,GACzB,IASIkD,EAAQ,IAAIC,OAAO,gBATR,CACd,QAAS,OAAQ,QAAS,QAC1B,UAAW,OAAQ,MAAO,QAC1B,OAAQ,QAAS,SAAU,KAC3B,KAAM,KAAM,UAAW,KACvB,MAAO,QAAS,MAAO,UACvB,MAAO,MAAO,MAAO,SAG0BC,KAAK,kBAAmB,KACpEJ,EAAQhD,EAAKgD,MAAME,GAEvB,OAAIF,EACU,MACZ,GAAIA,EAAM,GAAI,OAAOA,EAAM,GAE3B,IAAIK,EAAaL,EAAM,GAAGM,WAAW,IAAM,IAAIA,WAAW,GACtDC,EAAcP,EAAM,GAAGQ,cAM3B,OAJIH,IACHE,EAAcA,EAAY,GAAGE,cAAgBF,EAAYG,UAAU,IAG7D,KAAOH,GAVF,IAcPP,EAAM,GACY,GAAnBA,EAAM,GAAGT,OAAoB,IAAMS,EAAM,GACtC,KAAKA,EAAM,MAFI,IAQL,GAAfhD,EAAKuC,OACDX,KAAK+B,UAAU3D,GAGhB,YAAY4B,KAAK+B,UAAU3D,MAG5B,QAAQ4D,EAAIC,EAAMxB,GACxBwB,EAAOA,GAAQ,GACfxB,EAAOA,IAAQ,EAEf,IAAIyB,EAAMzE,KAAK0C,IAMf,OAJI1C,KAAK0E,kBAAkB1B,KAC1ByB,EAAM,UAAYA,EAAM,YAGlBA,EAAIhB,QAAQ,cAAc,CAACE,EAAOC,IACjCY,EAAU,EAALZ,EAAS,IAAM,gCAAgCA,QACzDH,QAAQ,aAAa,CAACkB,EAAQf,IACzB,WAAWW,MAAOX,QA9I5B,eAQwB,KAAAgB,aAAe,IACf,KAAAC,WAAa,IACb,KAAAC,cAAgB,K,0LCVxC,iBAOA,SAAYC,GAEX,mBAEA,iBAEA,iBAEA,qBAEA,mBAEA,mBAZD,CAAY,EAAAA,iBAAA,EAAAA,eAAc,KAe1B,MAA8BC,iBAAiB,UAK9C,YAAYxC,EAAmBC,EAAaC,EAAauC,GAGxD,GAFAC,MAAM1C,EAAOC,EAAKC,IAEbuC,EAAM,MAAM,UAAKnC,MAAM,mBAAoBN,GAEhDxC,KAAKiF,KAAOA,EASN,WAAWE,GACjB,OAAInF,KAAKoF,gBAAwBpF,KAAKoF,gBAC/BpF,KAAKoF,gBAAkBpF,KAAKqF,mBAAmBF,GAShD,OAAOG,EAAeC,GAI5B,OAAIvF,OAASsF,EAAY,KACpBtF,KAAKiF,KAAKO,OAAOF,EAAIL,QAEtBK,EAAIG,kBAAkBF,GAAWvF,KAAKyF,kBAAkBF,GACpDD,EAAII,eAAe1F,KAAMuF,GAE1BvF,KAAK0F,eAAeJ,EAAKC,IAe1B,SAASI,GACfA,EAAaA,GAAc,GAE3B,IAAK,IAAIvF,EAAI,EAAGA,EAAIuF,EAAWzC,OAAQ9C,IACtC,GAAIuF,EAAWvF,IAAMJ,KAAM,OAAO,EAGnC,OAAOA,KAAK4F,iBAAiBD,GAKvB,SACLE,EACAC,EACAxD,EACA7C,GAAc,GAEf,OAAIoG,EAAUE,IAAI/F,MACV,CAAC,CACPgG,MAAO,IACP1D,IAAKA,EAAI2D,OACTC,IAAKL,EAAU5E,IAAIjB,MACnBmG,KAAMnG,OAIJ8F,EAAKC,IAAI/F,MACL,CAAC,CACPgG,MAAO,IACP1D,IAAKA,EAAI2D,OACTC,IAAKJ,EAAK7E,IAAIjB,MACdmG,KAAMnG,OAIDA,KAAKoG,iBAAiBP,EAAWC,EAAMxD,EAAK7C,IA3FrD,oB,kKC3BA,gBACA,WAEA,MAAqB4G,mBAAmB,UAQvC,YAAaxF,GACZ,GAAIA,EAAEyF,OAAQ,CAKb,GAJApB,MAAM,KAAMrE,EAAE4B,IAAK,KAAM5B,EAAEyF,OAAOC,cAElCvG,KAAKwG,aAAe3F,EAAE4F,KAED,iBAAV5F,EAAEF,KACZ,MAAM,UAAKmC,MAAM,4BAA+B,MAGjD,GAFA9C,KAAKW,KAAOE,EAAEF,OAERE,EAAEyF,kBAAkBD,YACzB,MAAM,UAAKvD,MAAM,oCAAqC,MAEvD9C,KAAKsG,OAASzF,EAAEyF,WACV,CAKN,GAJApB,MAAM,KAAMrE,EAAE4B,IAAK,KAAM5B,EAAE6F,YAE3B1G,KAAKwG,aAAe3F,EAAE4F,KAEK,kBAAhB5F,EAAE6F,WACZ,MAAM,UAAK5D,MAAM,mCAAsC,MAExD,GAAKjC,EAAE6F,WAIA,CACN,GAAI7F,EAAE8F,KAAKC,KAAIC,GAAKA,aAAaR,aAAYS,MAAKC,IAAMA,IACvD,MAAM,UAAKjE,MAAM,yDAA0D,MAC5E,KAAMjC,EAAEmG,cAAcX,YACrB,MAAM,UAAKvD,MAAM,gCAAiC,MAEnD9C,KAAK2G,KAAO9F,EAAE8F,KACd3G,KAAKgH,GAAKnG,EAAEmG,OAXM,CAClB,GAAqB,iBAAVnG,EAAEF,KACZ,MAAM,UAAKmC,MAAM,4BAA+B,MACjD9C,KAAKW,KAAOE,EAAEF,OAaV,iBACN,GAAIX,KAAKW,KAAM,OAAOX,KAAKW,KAE3B,IAAIsG,EAAWjH,KAAKkH,UAEpB,MAAO,IAAID,EAASN,KAAKC,KAAIG,GAAKA,EAAEI,mBAAkBpD,KAAK,YAAYkD,EAASD,GAAGG,oBAG7E,iBAAiBC,GACvB,OAAIpH,KAAKqH,SAAiBrH,KAAKW,KAExB,GAAGX,KAAKW,KAAOX,KAAKW,KAAO,KAAO,MAAMX,KAAKkH,UAAUP,KAAK5C,KAAK,YAAY/D,KAAKkH,UAAUF,MAG7F,YAAYvH,GAClB,OAAIO,KAAKqH,WAEJ5H,GAAQO,KAAKW,KAFQ,gBAAgBX,KAAKW,iBAAiBX,KAAKW,SAM3DX,KAAKW,KAAO,gBAAgBX,KAAKW,iBAAiBX,KAAKW,UAAY,KAC1E,UAAUX,KAAKkH,UAAUP,KAAKC,KAAIG,GAAKA,EAAEO,gBAAevD,KAAK,cAC7D,SAAS/D,KAAKkH,UAAUF,GAAGM,yBAGxB,UACN,OAAOtH,KAAKsG,OAAStG,KAAKsG,OAAOY,UAAYlH,KAGvC,OAAOsB,GACb,KAAMA,aAAa+E,YAAa,OAAO,EAEvC,GAAIrG,KAAKsG,OAAQ,OAAOtG,KAAKsG,OAAOd,OAAOlE,GAC3C,GAAIA,EAAEgF,OAAQ,OAAOtG,KAAKwF,OAAOlE,EAAEgF,QAEnC,GAAItG,KAAKqH,UAAY/F,EAAE+F,SAAU,OAAO,EAExC,GAAIrH,KAAKqH,SAAU,OAAOrH,OAASsB,EAEnC,GAAItB,KAAK2G,KAAKzD,QAAU5B,EAAEqF,KAAKzD,OAAQ,OAAO,EAE9C,IAAK,IAAI9C,EAAI,EAAGA,EAAIJ,KAAK2G,KAAKzD,OAAQ9C,IACrC,IAAKJ,KAAK2G,KAAKvG,GAAGoF,OAAOlE,EAAEqF,KAAKvG,IAAK,OAAO,EAE7C,OAAOJ,KAAKgH,GAAGxB,OAAOlE,EAAE0F,KA3F1B,sB,kKCJA,gBAGA,MAA8BO,YAAY,UAQzC,aAAa,IAAC9E,EAAG,IAAEC,EAAG,YAAE8E,EAAW,OAAEC,EAAM,QAAEC,EAAO,KAAE/G,EAAI,OAAEgH,EAAM,KAAExB,GAAwB3D,GAC3F,IAAK7B,IAASwF,EACb,MAAM,UAAKrD,MAAM,oCAAqCN,GAEvD,GAAIkF,GAAWvB,IACTuB,EAAQlC,OAAOW,EAAKlB,MACxB,MAAM,UAAKnC,MAAM,mBAAmBqD,EAAKlB,wCAAwCyC,YAAkB/G,IAAQ6B,GAI7G,IAAKkF,IAAYvB,EAChB,MAAM,UAAKrD,MAAM,kDAAmDN,GAGrE,GAAIiF,IAAWtB,EACd,MAAM,UAAKrD,MAAM,8BAA+BN,GAGjD,IAAIe,GAAa,EAEjB,GAAIb,EAAK,CACR,IAAIkF,EAAS,UAAKC,SAASnF,GAC3Ba,EAAaqE,EAAOrE,WACpBb,EAAMkF,EAAOlE,UAEbhB,EAAM,KAGPwC,MACC1C,EAAOC,EAAKC,EACZ,KAAMgF,GAAWvB,EAAKlB,gBAAiB,UAAa,UAAa,WAAU,CAC1EyB,YAAY,EACZC,KAAMgB,EAAOf,KAAIkB,GAAYA,EAAS7C,OACtC+B,GAAIU,GAAWvB,EAAKlB,QAItBjF,KAAKwH,YAAcA,EACnBxH,KAAKyH,OAASA,EACdzH,KAAKuD,WAAaA,EAClBvD,KAAKW,KAAOA,EACZX,KAAK2H,OAASA,EACd3H,KAAKmG,KAAOA,EAGH,iBAAiBR,GAC1B,OAAO3F,KAAKmG,MAAQnG,KAAKmG,KAAK4B,SAASpC,GAG9B,oBACT,OAAO,EAAAZ,eAAeiD,IAGb,eAAe1C,EAAeC,GACvC,KAAMvF,KAAKmG,MAASnG,KAAKyH,YAClBnC,aAAeiC,KAAOjC,EAAIa,OAASb,EAAImC,QAC7C,OAAO,EAMR,IAHA,IAAIQ,EAAe,GACfC,EAASlI,KAAKiF,KAAKiC,UAAoCP,KAElDvG,EAAI,EAAGA,EAAI8H,EAAMhF,OAAQ9C,IACjC6H,EAAaE,KAAK,IAAI,UAAU,CAC/BlD,KAAMiD,EAAM9H,GACZO,KAAM,IAAMP,EACZgI,SAAU,MACRpI,KAAKwC,QAGT,IAAI6F,EAAiB,GAEjBC,EAAWtI,KAAKmG,OAASnG,KAAKyH,QAC9BzH,KAAKW,MAAQ0H,EAAeF,KAAKnI,MAAOA,KAAKO,KAAK0H,IACnD,IAAI,UAAQ,CACbM,IAAKvI,KACLwE,KAAMyD,GACJjI,KAAKwC,OAELgG,EAAUlD,aAAeiC,KAAOjC,EAAIa,OAASb,EAAImC,QACjDnC,EAAI3E,MAAQ0H,EAAeF,KAAK7C,GAAMA,EAAI/E,KAAK0H,IAChD,IAAI,UAAQ,CACbM,IAAKjD,EACLd,KAAMyD,GACJjI,KAAKwC,OAELiC,EAAM6D,EAAS9C,OAAOgD,EAASjD,GACnC,OAAOd,GAAOA,EAAIgE,OAAOJ,GAKnB,KAAK7D,GACX,IAAKxE,KAAKmG,KACT,MAAMpD,MAAM,+BAGb,GAAI/C,KAAK2H,OAAOzE,QAAUsB,EAAKtB,OAC9B,MAAMH,MAAM,4BAKb,IAFA,IAAI6D,EAA4B,IAAI8B,IAE3BtI,EAAI,EAAGA,EAAIJ,KAAK2H,OAAOzE,OAAQ9C,IACvCwG,EAAI+B,IAAI3I,KAAK2H,OAAOvH,GAAIoE,EAAKpE,IAG9B,OAAOJ,KAAKmG,KAAKyC,WAAWhC,GAGnB,iBACRf,EACAC,EACAxD,EACA7C,GAAc,GAEf,GAAIO,gBAAgB,WAAUA,KAAKW,OAASlB,EAC3C,MAAO,CAAC,CACPuG,MAAO,KACP1D,IAAKA,EAAI2D,OACTE,KAAMnG,OAIR,IAAKA,KAAKmG,KACT,MAAO,CAAC,CACPH,MAAO,KACP1D,IAAKA,EAAI2D,OACTE,KAAMnG,OAIR8F,EAAO,IAAI4C,IAAI5C,GAEf,IAAI+C,EAAQvG,EAAIwG,OAAS,EAErBC,EAAsB,GAY1B,OAVI/I,gBAAgB,WACnBA,KAAKgJ,MAAMC,SAAQC,IAClB,IAAIC,EAAQD,EAAE/C,KAAKiD,SAASvD,EAAWC,EAAMxD,GAC7CyG,EAASA,EAAON,OAAOU,GAEvB,IAAIE,EAAOF,EAAMA,EAAMjG,OAAS,GAAGZ,IACnCwD,EAAK6C,IAAIO,EAAGG,MAIP,CAAC,CACPrD,MAAO,IACP+C,SACAI,MAAOnJ,KAAKmG,KAAKiD,SAASvD,EAAWC,EAAMxD,GAC3CqF,OAAQ3H,KAAK2H,OACbrF,IAAK,CAACuG,EAAOvG,EAAIwG,WAjKpB,cAsKA,gBACA,OACA,UACA,UACA,UAOA,UACA,Y,kKCjLA,gBAEA,OAEA,UAYA,MAAqBQ,iBAAiB,UAOrC,aAAa,IAAC7G,EAAG,IAAEC,EAAG,OAAE+E,EAAM,KAAExC,EAAI,KAAEtE,EAAI,KAAEwF,GAA6B3D,GAGxE,GAFA0C,MAAM1C,EAAOC,EAAKC,EAAKuC,GAEJ,iBAARtE,EACV,MAAM,UAAKmC,MAAM,mBAAoBN,GAEtC,GAAIiF,IAAWtB,EACd,MAAM,UAAKrD,MAAM,8BAA+BN,GAGjD,GAAI2D,IAASlB,EAAKO,OAAOW,EAAKlB,MAC7B,MAAM,UAAKnC,MAAM,mBAAmBqD,EAAKlB,iCAAiCA,iBAAoBtE,IAAQ6B,GAGvGxC,KAAKyH,OAASA,EACdzH,KAAKW,KAAOA,EACZX,KAAKmG,KAAOA,EAGH,iBAAiBR,GAC1B,OAAO,EAGD,WAAWiB,GACjB,OAAIA,EAAIb,IAAI/F,MAAc4G,EAAI3F,IAAIjB,MAI3BA,KAGE,mBAAmBmF,GAC5B,OAAOnF,KAGE,kBAAkBuF,GAC3B,OAAOvF,KAAKmG,MAAUnG,KAAKyH,SAAUlC,EAAQgE,OAAOvJ,MAEjD,EAAA+E,eAAeyE,KADf,EAAAzE,eAAe0E,KAIT,eAAenE,EAAeC,GACvC,IAAKvF,KAAKmG,KAAM,OAAO,EAEvB,IAAKnG,KAAKyH,QAAUlC,EAAQgE,OAAOvJ,MAAO,CACzC,IAAI0J,EAAM1J,KAAKmG,KAAKX,OAAOF,EAAKC,GAChC,OAAKmE,GACEA,EAAIvB,KAAKnI,MAAO0J,GADNA,EAIlB,OAAO,EAGE,iBACR7D,EACAC,EACAxD,GAED,MAAO,CAAC,CACP0D,MAAO,KACP1D,IAAKA,EAAI2D,OACTE,KAAMnG,OAKD,iBACN,OAAOA,KAAKiF,KAAKkC,iBAAmB,IAAMnH,KAAKW,KAGzC,iBAAiByG,EAAgB3H,GACvC,MAAO,GAAGA,EAAOO,KAAKiF,KAAO,IAAM,KAAKjF,KAAKW,QAAQX,KAAK2C,OAGpD,YAAYK,EAAmBvD,GASrC,MAAO,WAREO,gBAAgB,UAAY,MAAMA,KAAK2C,IAAQ,OAAO3C,KAAKW,SAE1DX,KAAK0C,KAAO,UAAKiH,YAAY3J,KAAKW,SAEjClB,GAAQO,KAAKmG,KACrB,cAAcnG,KAAKmG,KAAKmB,YAAY,UAAKxC,eACzC,MAxFL,mBA8FA,kB,2rBC5GA,gBAEA,UAQA,MAAqB8E,kBAAkB,UAKtC,aAAa,KAACjJ,EAAI,KAAEwF,GAA8B3D,GAGjD,GAFA0C,MAAM1C,EAAO,KAAM,KAAM2D,EAAKlB,OAEzBtE,IAASwF,EACb,MAAM,UAAKrD,MAAM,mBAAoBN,GAGtCxC,KAAKW,KAAOA,EACZX,KAAKmG,KAAOA,EAGH,iBAAiBR,GAC1B,OAAO3F,KAAKmG,KAAK4B,SAASpC,GAGpB,WAAWiB,GACjB,OAAO5G,KAAKmG,KAAKyC,WAAWhC,GAGnB,mBAAmBzB,GAC5B,OAAOnF,KAAKmG,KAAK0D,WAAW1E,GAGnB,oBACT,OAAO,EAAAJ,eAAe+E,KAGb,eAAexE,EAAeC,GACvC,OAAOvF,KAAKmG,KAAKX,OAAOF,EAAKC,GAGpB,iBACRM,EACAC,EACAxD,GAED,IAAKwD,EAAKC,IAAI/F,MACb,MAAM+C,MAAS/C,KAAKW,KAAR,mBAGb,MAAO,CAAC,CACPqF,MAAO,IACP1D,IAAKA,EAAI2D,OACTC,IAAKJ,EAAK7E,IAAIjB,MACdmG,KAAMnG,KAAKmG,OAIN,iBAAiBiB,EAAgB3H,GACvC,OAAOO,KAAKW,KAGN,YAAYqC,EAAmBvD,GACrC,MAAO,YAAY,UAAK6E,UAAUtE,KAAKW,UA1DzC,qB,kKChBA,gBAIA,MAAqBoJ,eAAe,UAQnC,aAAa,IAACtH,EAAG,IAAEC,EAAG,YAAE8E,EAAW,WAAEwC,EAAU,KAAErJ,EAAI,OAAEgH,EAAM,QAAEpC,EAAO,MAAEyD,EAAK,KAAE7C,GAA2B3D,GACzG,IAAK2D,EACJ,MAAM,UAAKrD,MAAM,MAAON,GAGzB,GAAkB,UAAdwH,IAA2BrJ,EAC9B,MAAM,UAAKmC,MAAM,MAAON,GASzB,GANA0C,MAAM,CAACzC,MAAKC,MAAK8E,cAAaC,QAAQ,EAAOC,QAAS,KAAM/G,OAAMgH,SAAQxB,QAAO3D,GAEjFxC,KAAKgK,WAAaA,EAClBhK,KAAKgJ,MAAQA,GAAS,GACtBhJ,KAAKuF,QAAUA,EAEG,WAAdyE,IACEhK,KAAK+H,WACT,MAAM,UAAKjF,MAAM,UAAUnC,gDAAoD6B,GAK3E,SAASyH,GACf,GAAIjK,KAAKkK,cAAe,OAAO,EAE/B,IAAKD,GAAqC,kBAAtBjK,KAAKkK,cACxB,OAAOlK,KAAKkK,cAGb,IAAIC,GAASF,IAASA,EAAK/G,OAC3B+G,EAAOA,GAAQ,GAEf,IAAIxF,EAAyB,SAAnBzE,KAAKgK,YAAyB9E,MAAM6C,SAASkC,GAEvD,OADIE,IAAOnK,KAAKkK,cAAgBzF,GACzBA,EAGD,WAAWmC,GACjB,IAAK5G,KAAKmG,KAAM,OAAOnG,KAIvB,GAAIA,KAAKW,KAAM,OAAOX,KAGtB,GAAIA,KAAK2H,OAAOb,MAAKC,GAAKH,EAAIb,IAAIgB,KACjC,MAAMhE,MAAM,uBAEb,OAAO,IAAIgH,OAAO,CACjBtH,IAAK,KACLC,IAAK,KACL8E,YAAaxH,KAAKwH,YAClBwC,WAAY,SACZrJ,KAAM,KACNgH,OAAQ3H,KAAK2H,OACbpC,QAASvF,KAAKuF,QACdyD,MAAOhJ,KAAKgJ,MACZ7C,KAAMnG,KAAKmG,KAAKyC,WAAWhC,IACzB5G,KAAKwC,OAGC,mBAAmB2C,GAC5B,OAAKnF,KAAKmG,KACNnG,KAAKiF,gBAAgB,WAAcjF,KAAKW,KAAaX,KAElD,IAAI+J,OAAO,CACjBtH,IAAK,KACLC,IAAK,KACL8E,YAAaxH,KAAKwH,YAClBwC,WAAY,SACZrJ,KAAM,KACNgH,OAAQ3H,KAAK2H,OACbpC,QAASvF,KAAKuF,QACdyD,MAAOhJ,KAAKgJ,MACZ7C,KAAMnG,KAAKmG,KAAK0D,WAAW1E,IACzBnF,KAAKwC,OAbexC,KAgBjB,WAAWoK,GACjB,OAAO,EAGD,iBAAiBhD,EAAgB3H,GACvC,MAAO,CACN,KAAKO,KAAKW,MAAQ,MAAMX,KAAK2H,OAAOf,KAAIxE,GAAKA,EAAEQ,iBAAiBwE,KAASrD,KAAK,cAC9E,KAAO/D,KAAKmG,KAAK0D,YAAW,GAAMjH,iBAAiBwE,EAAS,GAC5D,KACCrD,KAAK,KAAO,KAAKsG,OAAOjD,IAGpB,YAAYpE,EAAmBvD,GACrC,IAAKO,KAAKW,KAET,OADAX,KAAKuD,WAAa,UAAKqB,aAChB,CACL5E,KAAK0E,kBAAkB1B,GAAQ,UAAY,GAGrB,GAAtBhD,KAAK2H,OAAOzE,OACVlD,KAAK2H,OAAO,GAAGL,aAAY,GAC3B,UAAUtH,KAAK2H,OAAOf,KAAIG,GAAKA,EAAEO,YAAY,UAAKzC,cAAad,KAAK,gBAEvE,YACA/D,KAAKmG,KAAK0D,YAAW,GAAMvC,aAAY,GAEtCtH,KAAK0E,kBAAkB1B,GAAQ,WAAa,IAC5Ce,KAAK,IAGR,IAAIQ,EAAK,OAASvE,KAAKW,KACtB2J,EAAStK,KAAK+H,WAAa,IAAM,KAElC,OAAKtI,EAGE,WAAW8E,wBAAyB+F,eAAoB,UAAKhG,UAAUtE,KAAKW,4BAA4BX,KAAK2H,OAAOf,KAAIG,GAAKA,EAAEwD,kBAAkB,UAAK1F,aAAekC,EAAEqB,SAAW,eAAerB,EAAEqB,YAAc,MAAKrE,KAAK,4BAC9N/D,KAAKmG,KAAK0D,YAAW,GAAMvC,aAAY,GAHnC,WAAW/C,wBAAyB+F,eAAoB,UAAKhG,UAAUtE,KAAKW,YAxHtF,iBAkIA,gBACA,W,kKCnIA,gBACA,UACA,UACA,OAEA,QACA,UACA,WAEA,UACA,UAOA,MAAqB6J,gBAAgB,UAKpC,aAAa,IAACjC,EAAG,KAAE/D,GAA4BhC,GAC9C,GAAI+F,EAAItD,KAAKoC,SAAU,CACtB,IAAI1G,EAAO,EAAA8J,WAAWlC,GAAOA,EAAI5H,KAAO,cACxC,MAAM,UAAKmC,MAASnC,EAAH,mBAA2B6B,GAG7C,KAAMgC,aAAgBvB,QAAUuB,EAAKoC,KAAIG,GAAKA,aAAa,YAAMD,MAAKC,IAAMA,IAC3E,MAAM,UAAKjE,MAAM,mBAAoBN,GAEtC,IAAIkI,EAAenC,EAAItD,KAAKiC,UAC3ByD,EAAaD,EAAa/D,KAC1BiE,EAAWpG,EAAKoC,KAAIG,GAAKA,EAAE9B,OAE5B,GAAI0F,EAAWzH,QAAU0H,EAAS1H,OACjC,MAAM,UAAKJ,MAAM,yCAAyC6H,EAAWzH,YAAY0H,EAAS1H,SAAUV,GAErG,IAAK,IAAIpC,EAAI,EAAGA,EAAIuK,EAAWzH,OAAQ9C,IACtC,IAAKuK,EAAWvK,GAAGoF,OAAOoF,EAASxK,IAClC,MAAM,UAAK0C,MAAM,aAAa1C,EAAI,yCAAyCuK,EAAWvK,QAAQwK,EAASxK,KAAMoC,GAI/G0C,MAAM1C,EAAO,KAAM,KAAMkI,EAAa1D,IAEtChH,KAAKuI,IAAMA,EACXvI,KAAKwE,KAAOA,EAGH,iBAAiBmB,GAC1B,OAAO3F,KAAKuI,IAAIR,SAASpC,GAGnB,WAAWiB,GACjB,OAAO,IAAI4D,QAAQ,CAClBjC,IAAKvI,KAAKuI,IAAIK,WAAWhC,GACzBpC,KAAMxE,KAAKwE,KAAKoC,KAAIiE,GAAOA,EAAIjC,WAAWhC,MACxC5G,KAAKwC,OAGC,mBAAmB2C,GAC5B,IAAIoD,EAAMvI,KAAKuI,IAAIsB,WAAW1E,GAC7BX,EAAOxE,KAAKwE,KAAKoC,KAAIiE,GAAOA,EAAIhB,WAAW1E,KAE5C,OAAMoD,aAAe,WAASA,EAAIpC,QAAQoC,EAAI5H,MAAU4H,aAAe,WAGhEA,EAAIhI,KAAKiE,GAAMqF,WAAW1E,GAFzB,IAAIqF,QAAQ,CAACjC,MAAK/D,QAAOxE,KAAKwC,OAKhC,aAAa+C,GAGnB,IAFA,IAAIuF,EAAmB9K,KAAKuI,IAErBuC,aAAkB,WACxBA,EAASA,EAAO3E,KAGjB,SAAI2E,aAAkB,WAAYA,EAAO3E,QAIrC2E,aAAkBN,QACdM,EAAOC,aAAaxF,GAGtBuF,aAAkB,WAEjBA,EAAOE,WAAWzF,IAGnB,WAAWA,GACjB,IAAKvF,KAAK+K,aAAaxF,GACtB,MAAMxC,MAAM,iBAOb,IAJA,IAAIkI,EAA2B,GAE3BH,EAAmB9K,KAAKuI,IAErBuC,aAAkB,WACxBA,EAASA,EAAO3E,KAGjB,GAAI2E,aAAkB,WAAYA,EAAO3E,KAGxC,OAFA8E,EAAK9C,KAAK2C,GAEH,CACNI,SAAU,IAAIV,QAAQ,CACrBjC,IAAKuC,EAAO3E,KACZ3B,KAAMxE,KAAKwE,MACTxE,KAAKwC,OACRyI,QAIF,GAAIH,aAAkBN,QAAS,CAC9B,IAAIW,EAAiBL,EAAOM,WAAW7F,GAEvC,OADA0F,EAAK9C,QAAQgD,EAAeF,MACrB,CACNC,SAAU,IAAIV,QAAQ,CACrBjC,IAAK4C,EAAeD,SACpB1G,KAAMxE,KAAKwE,MACTxE,KAAKwC,OACRyI,QAIF,KAAMH,aAAkB,WACvB,MAAM/H,MAAM,qBAKb,OAFI+H,EAAOnK,MAAMsK,EAAK9C,KAAK2C,GAEpB,CACNI,SAAUJ,EAAOvK,KAAKP,KAAKwE,MAC3ByG,QAIQ,oBACT,OAAO,EAAAlG,eAAesG,MAGb,eAAe/F,EAAeC,GACvC,KAAMD,aAAekF,SAAU,CAC9B,IAAKxK,KAAK+K,aAAaxF,GAAU,OAAO,EAExC,IAAI,SAAC2F,EAAQ,KAAED,GAAQjL,KAAKoL,WAAW7F,GAEvC,OADId,EAAMyG,EAAS1F,OAAOF,EAAKC,KACjBd,EAAIgE,OAAOwC,GAG1B,IAAI5C,EAAqC,GACxCiD,EAAKC,IAAwCA,GAAGlD,EAAeF,QAAQoD,GAAWA,GAEnF,GAAIvL,KAAKuI,KAAOjD,EAAIiD,KAAO+C,EAAEtL,KAAKuI,IAAI/C,OAAOF,EAAIiD,IAAKhD,IAAW,CAChE,IAAK,IAAInF,EAAI,EAAGA,EAAIJ,KAAKwE,KAAKtB,OAAQ9C,IACrC,IAAKkL,EAAEtL,KAAKwE,KAAKpE,GAAGoF,OAAOF,EAAId,KAAKpE,GAAImF,IAAW,OAAO,EAG3D,OAAO8C,EAGR,GAAIrI,KAAKuI,eAAeiC,SAAWxK,KAAKuI,IAAIwC,aAAaxF,GAAU,CAClE,IAAI,SAAC2F,EAAQ,KAAED,GAAQjL,KAAKoL,WAAW7F,GAEvC,OADId,EAAMyG,EAAS1F,OAAOF,EAAKC,KACjBd,EAAIgE,OAAOwC,GAG1B,GAAI3F,EAAIiD,eAAeiC,SAAWlF,EAAIiD,IAAIwC,aAAaxF,GAAU,CAChE,IAAI,SAAC2F,EAAQ,KAAED,GAAQ3F,EAAI8F,WAAW7F,GAEtC,OADId,EAAMzE,KAAKwF,OAAO0F,EAAU3F,KAClBd,EAAIgE,OAAOwC,GAG1B,IAAIO,EAAmBxL,KAAK+K,aAAaxF,GACxCkG,EAAkBnG,EAAIyF,aAAaxF,GAEpC,GAAIvF,KAAKuI,KAAOjD,EAAIiD,MAAQiD,IAAqBC,EAAiB,CACjE,GAAIzL,KAAKuI,KAAOjD,EAAIiD,IAAK,OAAO,EAEhC,IAAKiD,IAAqBC,EAAiB,CAC1C,IAASrL,EAAI,EAAGA,EAAIJ,KAAKwE,KAAKtB,OAAQ9C,IACrC,IAAKkL,EAAEtL,KAAKwE,KAAKpE,GAAGoF,OAAOF,EAAId,KAAKpE,GAAImF,IAAW,OAAO,EAG3D,OAAO8C,EAGR,GAAIrI,KAAKwE,KAAKkH,OAAM,CAACC,EAAGvL,IAChBkL,EAAEtL,KAAKwE,KAAKpE,GAAGoF,OAAOF,EAAId,KAAKpE,GAAImF,MAE1C,OAAO8C,EAIT,GAAImD,EAAkB,CACrB,IAAI,SAACN,EAAQ,KAAED,GAAQjL,KAAKoL,WAAW7F,GAEvC,OADId,EAAMyG,EAAS1F,OAAOF,EAAKC,KACjBd,EAAIgE,OAAOwC,GAG1B,IACIxG,GADA,SAACyG,EAAQ,KAAED,GAAQ3F,EAAI8F,WAAW7F,GAEtC,OADId,EAAMzE,KAAKwF,OAAO0F,EAAU3F,KAClBd,EAAIgE,OAAOwC,GAGhB,iBACRpF,EACAC,EACAxD,GAED,GAAIuD,EAAUE,IAAI/F,KAAKuI,KACtB,MAAO,CAAC,CACPvC,MAAO,KACP1D,IAAKA,EAAI2D,OACT2F,OAAQ/F,EAAU5E,IAAIjB,KAAKuI,KAC3B/D,KAAMxE,KAAKwE,KACX2B,KAAMnG,OAIR,GAAI8F,EAAKC,IAAI/F,KAAKuI,KACjB,MAAO,CAAC,CACPvC,MAAO,KACP1D,IAAKA,EAAI2D,OACT2F,OAAQ9F,EAAK7E,IAAIjB,KAAKuI,KACtB/D,KAAMxE,KAAKwE,KACX2B,KAAMnG,OAIR,GAAIA,KAAKuI,eAAe,WAAUvI,KAAKuI,IAAI5H,KAC1C,MAAO,CAAC,CACPqF,MAAO,MACP1D,IAAKA,EAAI2D,OACTE,KAAMnG,OAIR,KAAMA,KAAKuI,eAAe,WACzB,MAAO,CAAC,CACPvC,MAAO,KACP1D,IAAKA,EAAI2D,OACTE,KAAMnG,OAIR,IAAI6L,EAAc7L,KAAKuI,IAAIa,SAASvD,EAAWC,EAAMxD,GAErD,MAAO,IACHuJ,EACH,CACC7F,MAAO,KACP1D,IAAKA,EAAI2D,OACT2F,OAAQC,EAAYA,EAAY3I,OAAS,GAAGZ,IAC5CkC,KAAMxE,KAAKwE,KACX2B,KAAMnG,OAKF,iBAAiBoH,EAAgB3H,GACvC,IAAI+E,EAAYxE,KAAKwE,KAAKoC,KAAIiE,GACzBA,aAAe,UAAiB,GAAGA,EAAIlK,QAAQkK,EAAIlI,OAChDkI,EAAIjI,iBAAiBwE,EAAS,KAGtC,OAAI5C,EAAKT,KAAK,IAAIb,QAAU,IAM3BsB,GALAA,EAAOxE,KAAKwE,KAAKoC,KAAIiE,GAChBA,aAAe,UAAiB,GAAGA,EAAIlK,QAAQkK,EAAIlI,OAChDkI,EAAIjI,iBAAiBwE,MAGjBrD,KAAK,MAEb/D,KAAKuI,eAAe,UAChB,GAAGvI,KAAKuI,IAAI5H,MAAQ,IAAIX,KAAKuI,UAAU/D,KAEvC,CACJxE,KAAKuI,eAAe,WAASvI,KAAKuI,IAAI5H,KAErCX,KAAKuI,IAAI5H,KADT,IAAMX,KAAKuI,IAAI3F,iBAAiBwE,GAAU,IAE7C,IAAI5C,MACHT,KAAK,MAGRS,EAAOA,EAAKT,KAAK,MAAQ,KAAKsG,OAAOjD,EAAS,IAE1CpH,KAAKuI,eAAe,UAChB,CACNvI,KAAKuI,IAAI5H,MAAQ,IAAIX,KAAKuI,IAAI3F,iBAAiBwE,MAC/C,IACA,KAAO5C,EACP,KACCT,KAAK,KAAO,KAAKsG,OAAOjD,IAEnB,EAEHpH,KAAKuI,eAAe,WAAU,SAAUvI,KAAKuI,KAAOvI,KAAKuI,IAAI5H,KAE5DX,KAAKuI,IAAI5H,KADT,IAAMX,KAAKuI,IAAI3F,iBAAiBwE,GAAU,KAE1C,IACJ,KAAO5C,EACP,KACCT,KAAK,KAAO,KAAKsG,OAAOjD,KAKtB,YAAYpE,EAAmBvD,GACrC,GAAIO,KAAKuI,eAAe,UACvB,OACCvI,KAAKuI,IAAI5H,KACN,eAAeX,KAAKuI,IAAI5H,2BAA2BX,KAAKuI,IAAIR,WAAa,IAAM,kBAAkB,UAAKzD,UAAUtE,KAAKuI,IAAI5H,WACzHX,KAAKuI,IAAIjB,aAAY,IACrB,oBAAoBtH,KAAKwE,KAAKoC,KAAIiE,GAC9BA,EAAIvD,YAAY,UAAKzC,cAC1Bd,KAAK,iBAGT,GAAI/D,KAAKuI,eAAe,UACvB,OAAOvI,KAAKuI,IAAIuD,mBAAmB9L,KAAKwE,KAAMxB,GAE/C,IAAIwB,EAAOxE,KAAKwE,KAAKoC,KAAIiE,GACjBA,EAAIvD,YAAY,UAAKzC,cAG7B,QACG,EAAA4F,WAAWzK,KAAKuI,OAAQvI,KAAKuI,IAAI5H,MAASX,KAAKuI,eAAe,UAC7DvI,KAAKuI,IAAIjB,aAAY,GACrB,UAAKqC,YAAY3J,KAAKuI,IAAI5H,OAC1B,oBAAoB6D,EAAKT,KAAK,kBA5TpC,mB,kKCrBA,gBAEA,MAA8BgI,cAAc,WAA5C,iB,kKCFA,gBACA,UACA,WAgBA,MAAqBC,iBAAiB,UAOrC,YAAanL,GAGZ,GAFAqE,MAAM,KAAM,KAAM,KAAMrE,EAAE6F,YAEC,kBAAhB7F,EAAE6F,WACZ,MAAM,UAAK5D,MAAM,mCAAsC,MAExD,GAAoB,GAAhBjC,EAAE6F,WAAqB,CAC1B,KAAM7F,EAAEoL,gBAAgBhJ,OACvB,MAAM,UAAKH,MAAM,0BAA2B,MAE7C9C,KAAKiM,KAAOpL,EAAEoL,KACdjM,KAAKkM,MAAQrL,EAAEqL,UACT,CACN,GAAIrL,EAAE8F,KAAKG,MAAKD,KAAOA,aAAa,aACnC,MAAM,UAAK/D,MAAM,+CAAgD,MAClE,KAAMjC,EAAEmG,cAAcgF,UACrB,MAAM,UAAKlJ,MAAM,8BAA+B,MAEjD,GAAIjC,EAAEmG,GAAGT,aACR,MAAM,UAAKzD,MAAM,8DAA+D,MAEjF9C,KAAK2G,KAAO9F,EAAE8F,KACd3G,KAAKgH,GAAKnG,EAAEmG,IAIP,UACN,OAAOhH,KAGD,iBAAiBoH,GACvB,OAAIpH,KAAKqH,SAAiB,IAAIrH,KAAKiM,KAAKlI,KAAK,YAAY/D,KAAKkM,SAEvD,IAAIlM,KAAK2G,KAAK5C,KAAK,YAAY/D,KAAKgH,MAGrC,YAAYhE,EAAmBvD,GACrC,MAAM,IAAIsD,MAAM,2BAGV,OAAOzB,GACb,KAAMA,aAAa0K,UAAW,OAAO,EAErC,GAAIhM,KAAKqH,UAAY/F,EAAE+F,SAAU,OAAO,EAExC,GAAIrH,KAAKqH,SAAU,CAClB,GAAIrH,KAAKiM,KAAK/I,QAAU5B,EAAE2K,KAAK/I,OAAQ,OAAO,EAE9C,IAAK,IAAI9C,EAAI,EAAGA,EAAIJ,KAAKiM,KAAK/I,OAAQ9C,IACrC,IAAKJ,KAAKiM,KAAK7L,GAAGoF,OAAOlE,EAAE2K,KAAK7L,IAAK,OAAO,EAG7C,QAAKJ,KAAKkM,MAAM1G,OAAOlE,EAAE4K,OAK1B,GAAIlM,KAAK2G,KAAKzD,QAAU5B,EAAEqF,KAAKzD,OAAQ,OAAO,EAE9C,IAAK,IAAI9C,EAAI,EAAGA,EAAIJ,KAAK2G,KAAKzD,OAAQ9C,IACrC,IAAKJ,KAAK2G,KAAKvG,GAAGoF,OAAOlE,EAAEqF,KAAKvG,IAAK,OAAO,EAE7C,OAAOJ,KAAKgH,GAAGxB,OAAOlE,EAAE0F,KArE1B,oB,kKCfA,gBAUA,MAAqBmF,kBAAkB,UAItC,aAAa,IAAC1J,EAAG,IAAEC,EAAG,KAAEuC,EAAI,KAAEtE,EAAI,SAAEyH,GAAkC5F,GACrE0C,MAAM,CAACzC,MAAKC,MAAK+E,QAAQ,EAAOxC,OAAMtE,OAAMwF,KAAM,MAAO3D,GAEzDxC,KAAKoI,SAAWA,EAGV,kBAAkBpF,EAAmBvD,GAG3C,MAAO,CACN,YAHO,MAAMO,KAAK2C,QAIlB3C,KAAKsH,YAAYtE,EAAMvD,GACvB,KACCsE,KAAK,KAjBT,qB,kKCVA,gBAEA,UACA,UAgBA,MAAqBqI,kBAAkB,UAEtC,aAAa,IAAC3J,EAAG,IAAEC,EAAG,YAAE8E,EAAW,OAAEC,EAAM,QAAEC,EAAO,KAAE/G,EAAI,OAAEgH,EAAM,KAAExB,GAA8B3D,GACjG0C,MAAM,CAACzC,MAAKC,MAAK8E,cAAaC,SAAQC,UAAS/G,OAAMgH,SAAQxB,QAAO3D,GAG9D,WAAWoE,GACjB,IAAK5G,KAAKmG,KAAM,OAAOnG,KAIvB,GAAIA,KAAKW,KAAM,OAAOX,KAGtB,GAAIA,KAAK2H,OAAOb,MAAKC,GAAKH,EAAIb,IAAIgB,KACjC,MAAMhE,MAAM,uBAEb,OAAO,IAAIqJ,UAAU,CACpB3J,IAAK,KACLC,IAAK,KACL8E,YAAaxH,KAAKwH,YAClBC,OAAQzH,KAAKyH,OACbC,QAAS,KACT/G,KAAM,KACNgH,OAAQ3H,KAAK2H,OACbxB,KAAMnG,KAAKmG,KAAKyC,WAAWhC,IACzB5G,KAAKwC,OAGC,mBAAmB2C,GAC5B,OAAKnF,KAAKmG,KACNnG,KAAKiF,gBAAgB,WAAcjF,KAAKW,KAAaX,KAElD,IAAIoM,UAAU,CACpB3J,IAAK,KACLC,IAAK,KACL8E,YAAaxH,KAAKwH,YAClBC,OAAQzH,KAAKyH,OACbC,QAAS,KACT/G,KAAM,KACNgH,OAAQ3H,KAAK2H,OACbxB,KAAMnG,KAAKmG,KAAK0D,WAAW1E,IACzBnF,KAAKwC,OAZexC,KAejB,WAAWuF,GACjB,OAAOvF,KAAKmG,QAAUnG,KAAKyH,QAAUlC,EAAQgE,OAAOvJ,OAG9C,iBAAiBoH,EAAgB3H,GACvC,OAAIO,KAAKW,KAAaX,KAAKW,KAEpB,CACN,KAAKX,KAAKW,MAAQ,MAAMX,KAAK2H,OAAOf,KAAIxE,GAAKA,EAAEQ,iBAAiBwE,KAASrD,KAAK,cAC9E,KAAO/D,KAAKmG,KAAKvD,iBAAiBwE,EAAS,GAC3C,KACCrD,KAAK,KAAO,KAAKsG,OAAOjD,IAGpB,YAAYpE,EAAmBvD,GACrC,OAAKO,KAAKW,KAiBLlB,EAGAO,KAAKmG,KAGHnG,KAAK8L,mBAAmB9L,KAAK2H,OAAQ,UAAK7C,eAC7C,cAAc9E,KAAKmG,KAAKmB,YAAY,UAAKxC,eAHrC9E,KAAK8L,mBAAmB9L,KAAK2H,OAAQ3E,GAHrC,eAAehD,KAAKW,SAAS,UAAKgJ,YAAY3J,KAAKW,UAjB1DX,KAAKuD,WAAa,UAAKqB,aAChB,CACL5E,KAAK0E,kBAAkB1B,GAAQ,UAAY,GAGrB,GAAtBhD,KAAK2H,OAAOzE,OACVlD,KAAK2H,OAAO,GAAGL,aAAY,GAC3B,UAAUtH,KAAK2H,OAAOf,KAAIG,GAAKA,EAAEO,YAAY,UAAKzC,cAAad,KAAK,gBAEvE,YACA/D,KAAKmG,KAAK0D,YAAW,GAAMvC,aAAY,GAEtCtH,KAAK0E,kBAAkB1B,GAAQ,WAAa,IAC5Ce,KAAK,KAaF,mBAAmBS,EAAMxB,GAK/B,OAJAwB,EAAOA,EAAKoC,KAAIiE,GACRA,EAAIvD,YAAYtH,KAAK0C,IAAM1C,KAAKuD,WAAa,UAAKsB,cAGtD7E,KAAK0C,IACD1C,KAAKqM,QAAQ,OAASrM,KAAKW,KAAM6D,EAAMxB,IAI7ChD,KAAKW,KAEH,eAAeX,KAAKW,SAAS,UAAKgJ,YAAY3J,KAAKW,SADnDX,KAAKsH,aAAY,IAEjB,oBAAoB9C,EAAKT,KAAK,kBApGpC,qB,kKCrBA,gBAEA,MAA8BuI,aAAa,UAM1C,YAAa9J,EAAmBC,EAAaC,EAAa6D,GACzDrB,MAAM1C,EAAOC,EAAKC,GAClB1C,KAAKuG,aAAeA,EACpBvG,KAAKqH,UAAYd,GATnB,gB,kGCCA,sBAAgBkE,WAAWnF,GAC1B,MAAO,SAAUA,I,2rBCDlB,gBAGA,UACA,UACA,UACA,UASA,MAAqBiH,YAAY,UAMhC,aAAa,KAACN,EAAI,MAAEjD,EAAK,MAAEkD,GAAyB1J,GACnD,KAAMyJ,aAAgBhJ,OACjBgJ,EAAKP,OAAMrL,GACNA,EAAE4E,gBAAgB,WACrB5E,EAAE4E,gBAAgB,aAGxB,MADA9B,QAAQC,IAAI6I,GACN,UAAKnJ,MAAM,mBAAoBN,GAGtC,GAAIwG,KAAWA,aAAiB/F,OAAS+F,EAAM0C,OAAMxC,GAAKA,aAAa,aACtE,MAAM,UAAKpG,MAAM,mBAAoBN,GAEtC,KAAM0J,EAAMjH,gBAAgB,WAAciH,EAAMjH,gBAAgB,WAE/D,MADA9B,QAAQC,IAAI8I,GACN,UAAKpJ,MAAM,mBAAoBN,GAGtC,GAAI0J,EAAMjH,KAAKsB,aACd,MAAM,UAAKzD,MAAM,mCAAoCN,GAGtD0C,MAAM1C,EAAO,KAAM,KAAM,IAAI,UAAS,CACrCkE,YAAY,EACZuF,KAAMA,EAAKrF,KAAIG,GAAKA,EAAE9B,OACtBiH,MAAOA,EAAMjH,QAGdjF,KAAKiM,KAAOA,EACZjM,KAAKgJ,MAAQA,GAAS,GACtBhJ,KAAKkM,MAAQA,EACblM,KAAKuD,WAAa,UAAKsB,WAGd,iBAAiBc,GAC1B,OAAO3F,KAAKkM,MAAMnE,SAASpC,EAAW8C,OAAOzI,KAAKiM,OAG5C,WAAWrF,GACjB,IAAIqF,EAAOjM,KAAKiM,KAAKrF,KAAIG,GAAKA,EAAE6B,WAAWhC,KACvCsF,EAAQlM,KAAKkM,MAAMtD,WAAWhC,GAElC,OAAO,IAAI2F,IAAI,CACdN,OACAjD,MAAO,KACPkD,SACElM,KAAKwC,OAGC,mBAAmB2C,GAC5B,IAAI8G,EAAOjM,KAAKiM,KAAKrF,KAAI4F,GAAOA,EAAI3C,WAAW1E,KAC3C+G,EAAQlM,KAAKkM,MAAMrC,WAAW1E,GAElC,OAAO,IAAIoH,IAAI,CAACN,OAAMjD,MAAO,KAAMkD,SAAQlM,KAAKwC,OAGvC,oBACT,OAAO,EAAAuC,eAAe0H,IAGb,eAAenH,EAAeC,GACvC,KAAMD,aAAeiH,KACpB,MAAMxJ,MAAM,oBAGb,GAAI/C,KAAKiM,KAAK/I,QAAUoC,EAAI2G,KAAK/I,OAChC,MAAMH,MAAM,oBAGb,IAAK,IAAI3C,EAAI,EAAGA,EAAIJ,KAAKiM,KAAK/I,OAAQ9C,IACrC,IAAKJ,KAAKiM,KAAK7L,GAAGoF,OAAOF,EAAI2G,KAAK7L,GAAImF,GAAU,OAAO,EAGxD,OAAOvF,KAAKkM,MAAM1G,OAAOF,EAAI4G,MAAO3G,GAG3B,iBACRM,EACAC,EACAxD,GAEDuD,EAAY,IAAI6C,IAAI7C,GAEpB,IAAIgD,EAAQvG,EAAIwG,OAAS,EAErB4D,EAAyB1M,KAAKiM,KAAKrF,KAAIvG,IAC1CwF,EAAU8C,IAAItI,EAAGiC,EAAI2D,QAEd,CACND,MAAO,IACP1D,IAAKA,EAAIwG,OACT3C,KAAM9F,MAaR,OATAyF,EAAO,IAAI4C,IAAI5C,GASR,CAAC,CACPE,MAAO,IACP0G,UAAWA,EACXC,WAVY3M,KAAKgJ,MAAMpC,KAAIsC,IAC3B,IAAIC,EAAQD,EAAE/C,KAAKiD,SAASvD,EAAWC,EAAMxD,GACzC+G,EAAOF,EAAMA,EAAMjG,OAAS,GAAGZ,IAEnC,OADAwD,EAAK6C,IAAIO,EAAGG,GACLF,KACLyD,KAAK,GAKYnE,OAAOzI,KAAKkM,MAAM9C,SAASvD,EAAWC,EAAMxD,IAC/DA,IAAK,CAACuG,EAAOvG,EAAIwG,UAIZ,iBAAiB1B,EAAgB3H,GACvC,OAAKO,KAAKiM,KAAK/I,OAIR,CACN,KAAOlD,KAAKiM,KAAKrF,KAAIG,GAAKA,EAAEnE,iBAAiBwE,EAAS,KAAIrD,KAAK,MAAQ,KAAKsG,OAAOjD,EAAS,IAC5F,KACA,KAAOpH,KAAKkM,MAAMtJ,iBAAiBwE,EAAS,IAC3CrD,KAAK,KAAO,KAAKsG,OAAOjD,IAPlB,MAAQpH,KAAKkM,MAAMtJ,iBAAiBwE,GAUtC,YAAYpE,EAAmBvD,GACrC,IAAIyL,EAAWlL,KAAK6J,YAAW,GAE/B,MAAO,CACL7J,KAAK0E,kBAAkB1B,GAAQ,UAAY,GAC5C,IAAIkI,EAASe,KAAKrF,KAAIG,GAAKA,EAAEO,YAAY,UAAKzC,cAAad,KAAK,iBAAiBmH,EAASgB,MAAM5E,YAAY,UAAKzC,eAChH7E,KAAK0E,kBAAkB1B,GAAQ,WAAa,IAC5Ce,KAAK,KAzIT,e,gBCnBA,IAAI8I,EAGHA,EAAU,EAAQ,IAA8BC,QAQjD,IAAIC,EAAU,EAAQ,IAAaD,QAEnClN,EAAOD,QAAU,CAACkN,UAASE,Y,6BCb3B,OAAe,26T,yhBCAf,iBAEA,WACA,WASA,gBAAqBA,QAiBpB,YAAaC,GACZ,GAde,KAAAC,SAA+B,IAAIvE,KAc7CsE,EAAQ,MAAMjK,MAAM,MACzB/C,KAAKgN,OAASA,EAGF,WAAWE,EAAkBC,G,yCAEzC,OADAnN,KAAKoN,eAAiB,GACfpN,KAAKqN,YAAcrN,KAAKsN,mBAAmBJ,EAAUC,MAG/C,mBAAmBD,EAAkBC,G,yCAElD,GAAInN,KAAKiN,SAASlH,IAAImH,GACrB,OAAOlN,KAAKiN,SAAShM,IAAIiM,GAG1B,IAAIK,EAAqBvN,KAAKoN,eAAeI,QAAQN,GAGrD,GAAIK,GAAsB,EAAG,CAC5B,GAAIA,GAAsBvN,KAAKoN,eAAelK,OAAS,EACtD,MAAMH,MAAM,uBAAuBmK,MAGpC,IAAIO,EAAQzN,KAAKoN,eAAeM,MAAMH,GAAoB9E,OAAOyE,GAEjE,MAAMnK,MAAM,6BAA6B0K,EAAM1J,KAAK,gEAIrD/D,KAAKoN,eAAejF,KAAK+E,GAEzB,IAAI,QAACS,EAAO,KAAEjK,SAAcyJ,EAAOD,GAE/BG,EAAQ,IAAI,UAAMM,EAAS,MAC3B/F,EAAS5H,KAAKgN,OAAOY,MAAMlK,GAK/B,SAHM1D,KAAK6N,KAAKjG,EAAQyF,EAAOF,GAG3BnN,KAAKoN,eAAeU,OAASZ,EAChC,MAAMnK,MAAM,qBAKb,OADA/C,KAAKiN,SAAStE,IAAIuE,EAAUG,GACrBA,KAGK,KAAKlE,EAA6BkE,EAAarN,KAAKqN,MAAOF,G,yCACvE,IAAK,IAAI/M,EAAI,EAAGA,EAAI+I,EAAMjG,OAAQ9C,IAAK,CACtC,IAAI2N,EAAO5E,EAAM/I,GAEjB,OAAQ2N,EAAK/H,OACZ,IAAK,SACJ,IAAIgI,QAAehO,KAAKsN,mBAAmBS,EAAKb,SAAUC,GAC1DE,EAAMY,UAAUtF,IAAIoF,EAAKb,SAAUc,GACnC,MACD,IAAK,UACJ,IAAI/I,EAAO,UAAaA,KAAK8I,EAAMV,GAEnC,GAAIA,EAAMa,QAAQjJ,EAAKtE,MACtB,MAAM0M,EAAMvK,MAAM,QAAQmC,EAAKtE,kCAGhC0M,EAAMc,QAAQlJ,GACd,MACD,IAAK,OACJ,IAAI6C,EAAW,UAAaA,SAASiG,EAAMV,GAE3C,GAAIA,EAAMe,YAAYtG,EAASnH,MAC9B,MAAM0M,EAAMvK,MAAM,cAAcgF,EAASnH,kCAG1C0M,EAAMgB,YAAYvG,GAClB,MACD,IAAK,QACJ,IAAIS,EAAM,UAAaA,IAAIwF,EAAMV,GAEjC,GAAIA,EAAMe,YAAY7F,EAAI5H,MACzB,MAAM0M,EAAMvK,MAAM,cAAcyF,EAAI5H,kCAGrC0M,EAAMiB,OAAO/F,GACb,MACD,IAAK,YACJ,IAAIqD,EAAS,UAAaA,OAAOmC,EAAMV,EAAO,MAE9C,GAAIA,EAAMkB,UAAU3C,EAAOjL,MAC1B,MAAM0M,EAAMvK,MAAM,UAAU8I,EAAOjL,kCAGpC0M,EAAMmB,UAAU5C,GAChB,MACD,QACC,MAAM7I,MAAM,qBAAsBgL,EAAa/H,YAK5C,SAAS+H,GACf,IAAIV,EAAQ,IAAI,UAAM,SAAUrN,KAAKqN,OAErC,OAAQU,EAAK/H,OACZ,IAAK,UACJ,OAAO,UAAaf,KAAK8I,EAAMV,GAChC,IAAK,OACJ,OAAO,UAAavF,SAASiG,EAAMV,GACpC,IAAK,QACJ,OAAO,UAAa9E,IAAIwF,EAAMV,GAC/B,IAAK,YACL,IAAK,aACJ,OAAO,UAAazB,OAAOmC,EAAMV,EAAO,MACzC,IAAK,MACJ,OAAO,UAAaoB,IAAIV,EAAMV,EAAO,MACtC,IAAK,YACJ,OAAO,UAAaqB,UAAUX,EAAMV,EAAO,MAC5C,IAAK,aACJ,OAAO,UAAasB,WAAWZ,EAAMV,EAAO,MAC7C,IAAK,MACJ,OAAO,UAAauB,QAAQb,EAAMV,GACnC,QACC,MAAMtK,MAAM,qBAAsBgL,EAAa/H,QAI3C,iBAAiBrF,EAAckO,GACrC,OAAO,UAAc5N,IAAIjB,KAAKqN,MAAO1M,EAAMkO,M,kKCvJ7C,iBACA,UAGA,UAEA,WACA,UACA,WACA,WACA,UACA,WACA,UACA,WAIA,SAASC,gBAAgBxJ,GACxB,GAAiB,QAAbA,EAAIU,MACP,MAAMjD,MAAM,oBAEb,OAAKuC,EAAIyJ,MACF,IAAMzJ,EAAIqB,KAAKC,IAAIkI,iBAAiB/K,KAAK,MAAQ,OACpD+K,gBAAgBxJ,EAAI0B,IAAM,IAFN1B,EAAoB3E,KAY7C,SAASqO,mBAAmB1J,GAC3B,GAAiB,QAAbA,EAAIU,MACP,MAAMjD,MAAM,oBAEb,GAAKuC,EAAIyJ,MAOF,CACN,IAAKzJ,EAAIqB,OAASrB,EAAI0B,GACrB,MAAMjE,MAAM,oBAEb,OAAOuC,EAAIqB,KAAKC,IAAIoI,oBAAoBvG,OACvC,CAACuG,mBAAmB1J,EAAI0B,MATzB,KAFA1B,EAAMA,GAEG3E,KACR,MAAMoC,MAAM,oBAEb,OAAOuC,EAAI3E,KAWb,SAASsO,eAAe3J,GACvB,OAAQA,EAAIL,MACX,IAAK,IACJ,MAAO,IAAIK,EAAI3E,KAChB,IAAK,IAEL,IAAK,SACJ,MAAO,GAAG2E,EAAI3E,KACf,QACC,MAAMoC,MAAM,gBAAgBuC,EAAIL,OAInC,MAAqBiK,GACb,YAAY5J,EAAoB6J,GACtC,GAAiB,WAAb7J,EAAIU,MACP,MAAMjD,MAAM,oBAEb,IAAIsK,EAAe8B,EAAYC,OAAO,OAAQ9J,EAAI3E,KAAM2E,EAAI+J,UAExD/I,EAAqBhB,EAAIgB,OAAS+G,EAAMiC,QAAQN,mBAAmB1J,EAAIgB,SAAW,KAElF3F,EAAe2E,EAAI3E,KACnB8B,EAAc6C,EAAI7C,IAClBgE,EAAgBnB,EAAImB,KAExB,GAAIA,GAAQH,EACX,MAAM+G,EAAMvK,MAAM,oCAGnB,OAAIwD,EACI,IAAI,UAAW,CACrB3F,OACA8B,MACAgE,OACAH,WAIK,IAAI,UAAW,CACrBI,YAAY,EACZ/F,OACA8B,MACAgE,SAIK,gBAAgBnB,EAA6B6J,GACnD,IAAK,CAAC,OAAQ,OAAOI,SAASjK,EAAIU,OACjC,MAAMjD,MAAM,oBAGb,IAAIsK,EAAQ8B,EAAYC,OAAO,WAAY9J,EAAI3E,KAAM2E,EAAI+J,UAEzD,GAAiB,OAAb/J,EAAIU,MAAgB,CACvB,GAAgB,UAAZV,EAAIL,KACP,MAAMoI,EAAMvK,MAAM,iBAAiBwC,EAAIL,oBAGxC,IAAKoI,EAAMe,YAAY9I,EAAI3E,MAC1B,MAAM0M,EAAMvK,MAAM,wBAAwBmM,eAAe3J,IAC1D,OAAO+H,EAAMmC,YAAYlK,EAAI3E,MAG9B,IAAK0M,EAAMa,QAAQc,mBAAmB1J,EAAIL,OACzC,MAAMoI,EAAMvK,MAAM,QAAQgM,gBAAgBxJ,EAAIL,wBAE/C,IAAIA,EAAOoI,EAAMiC,QAAQN,mBAAmB1J,EAAIL,OAE5CkB,EAAOb,EAAIa,KAAO+I,GAAGO,MAAMnK,EAAIa,KAAMkH,GAAS,KAElD,OAAI/H,EAAIoK,QACA,IAAI,UAAU,CACpBjN,IAAK6C,EAAI7C,IACTC,IAAK4C,EAAI5C,IACTuC,OACAtE,KAAM2E,EAAI3E,KACVyH,SAAU9C,EAAI8C,UAAY,MACxBiF,EAAM7K,OAGH,IAAI,UAAS,CACnBC,IAAK6C,EAAI7C,IACTC,IAAK4C,EAAI5C,IACT+E,SAAUnC,EAAImC,OACdxC,OACAtE,KAAM2E,EAAI3E,KACVwF,KAAMA,GAAQ,MACZkH,EAAM7K,OAGH,WAAW8C,EAAkC6J,GACnD,GAAiB,SAAb7J,EAAIU,OAAiC,WAAbV,EAAIU,MAC/B,MAAMjD,MAAM,oBAEb,IAAIsK,EAAQ8B,EAAYC,OAAO,MAAoB,SAAb9J,EAAIU,MAAmBV,EAAI3E,KAAO,cAAe2E,EAAI+J,UAEvF5M,EAAM,KACTC,EAAM,KACN+E,GAAS,EACTC,EAAsB,KACtB/G,EAAO,KACPwF,EAAO,KAER,GAAiB,SAAbb,EAAIU,MAAkB,CAKzB,GAJAvD,EAAM6C,EAAI7C,IACVC,EAAM4C,EAAI5C,IACV+E,EAASnC,EAAImC,QAER4F,EAAMa,QAAQc,mBAAmB1J,EAAIoC,UACzC,MAAM2F,EAAMvK,MAAM,QAAQgM,gBAAgBxJ,EAAIoC,2BAG/CA,EAAU2F,EAAMiC,QAAQN,mBAAmB1J,EAAIoC,UAC/C/G,EAAO2E,EAAI3E,KAGZ,IAAIgH,EAASrC,EAAIqC,OAAOf,KAAI+I,IAC3B,IAAIC,EAAKV,GAAGpH,SAAS6H,EAAKtC,GAE1B,GAAIA,EAAMwC,eAAeD,EAAGjP,MAC3B,MAAM0M,EAAMvK,MAAM,aAAa8M,EAAGjP,kCAEnC,KAAMiP,aAAc,WACnB,MAAM7M,MAAM,qBAIb,OADAsK,EAAMgB,YAAYuB,GACXA,KAOR,OAJItK,EAAIa,OACPA,EAAO+I,GAAGO,MAAMnK,EAAIa,KAAMkH,IAGpB,IAAI,UAAU,CAAC7F,YAAa,GAAIC,SAAQC,UAAS/G,OAAMgH,SAAQxB,OAAM1D,MAAKC,OAAM2K,EAAM7K,OAGvF,eAAe8C,EAAoB6J,GACzC,GAAiB,WAAb7J,EAAIU,MACP,MAAMjD,MAAM,oBAEb,IAAIsK,EAAQ8B,EAAYC,OAAO,UAAW,SAAU9J,EAAIsG,OAAStG,EAAIsG,OAAOjL,KAAO,KAAM2E,EAAI+J,UAEzF9G,EAAM2G,GAAGO,MAAMnK,EAAIsG,OAAQyB,GAE3B7I,EAAOc,EAAId,KAAKoC,KAAIiE,GAChBqE,GAAGO,MAAM5E,EAAKwC,KAGtB,OAAO,IAAI,UAAQ,CAAC9E,MAAK/D,QAAO6I,EAAM7K,OAGhC,gBAAgB8C,EAAqB6J,EAAoB5J,GAC/D,IAAK,CAAC,MAAO,YAAa,aAAc,aAAc,MAAO,QAAQgK,SAASjK,EAAIU,OACjF,MAAMjD,MAAM,oBAIb,IAAIsK,EAAQ8B,EAEZ,OAAQ7J,EAAIU,OACX,IAAK,MACJ,OAAOkJ,GAAGT,IAAInJ,EAAK+H,EAAO9H,GAC3B,IAAK,YACJ,OAAO2J,GAAGR,UAAUpJ,EAAK+H,EAAO9H,GACjC,IAAK,aACJ,OAAO2J,GAAGP,WAAWrJ,EAAK+H,EAAO9H,GAClC,IAAK,aACJ,OAAO2J,GAAGtD,OAAOtG,EAAK+H,EAAO9H,GAC9B,IAAK,MACJ,OAAO2J,GAAGN,QAAQtJ,EAAK+H,GACxB,IAAK,OACJ,OAAO6B,GAAGY,KAAKxK,EAAK+H,EAAO9H,GAC5B,QACC,MAAMxC,MAAM,QAIR,aAAauC,EAAkB6J,GACrC,IAAK,CAAC,UAAW,UAAW,OAAOI,SAASjK,EAAIU,OAE/C,MADA7C,QAAQC,IAAIkC,GACNvC,MAAM,oBAIb,IAAIsK,EAAQ8B,EAEZ,OAAQ7J,EAAIU,OACX,IAAK,UACJ,OAAOkJ,GAAGa,QAAQzK,EAAK+H,GACxB,IAAK,UACJ,OAAO6B,GAAG3G,IAAIjD,EAAK+H,GACpB,IAAK,MACJ,OAAO6B,GAAGpH,SAASxC,EAAK+H,GACzB,QACC,MAAMtK,MAAM,QAIR,eAAeuC,EAAgB6J,GACrC,GAAiB,OAAb7J,EAAIU,MACP,MAAMjD,MAAM,oBAGb,IAAIsK,EAAQ8B,EAEZ,OAAQ7J,EAAIL,MACX,IAAK,IACJ,GAAIK,EAAI3E,KAAKgD,MAAM,aAAc,CAChC,IAAIqM,EAASC,OAAO3K,EAAI3E,KAAK+M,MAAM,IAAM,EACzC,GAAIsC,GAAU3C,EAAM1H,WAAWzC,OAC9B,MAAMmK,EAAMvK,MAAM,eAAekN,EAAS,eAG3C,OAAO3C,EAAM1H,WAAWqK,GAGzB,MAAM3C,EAAMvK,MAAM,0BAA0BmM,eAAe3J,IAC5D,IAAK,IACJ,IAAK+H,EAAM6C,KAAK5K,EAAI3E,MACnB,MAAM0M,EAAMvK,MAASmM,eAAe3J,GAAlB,mBAGnB,OAAO+H,EAAM8C,KAAK7K,EAAI3E,MACvB,IAAK,SACJ,IAAK0M,EAAMkB,UAAUjJ,EAAI3E,MACxB,MAAM0M,EAAMvK,MAAM,UAAUmM,eAAe3J,qBAE5C,OAAO+H,EAAM+C,UAAU9K,EAAI3E,MAC5B,QACC,MAAM0M,EAAMvK,MAAM,gBAAgBwC,EAAIL,OAIlC,YAAYK,EAAiB6J,EAAoB5J,GACvD,GAAiB,QAAbD,EAAIU,MACP,MAAMjD,MAAM,oBAGb,IAAIsK,EAAQ8B,EAAYC,OAAO,OAAQ,KAAM9J,EAAI+J,UAE7CO,EAAKV,GAAGpH,SAASxC,EAAIwK,KAAMzC,GAE/B,GAAIA,EAAMwC,eAAeD,EAAGjP,MAC3B,MAAM0M,EAAMvK,MAAM,aAAa8M,EAAGjP,kCAEnC,KAAMiP,aAAc,WACnB,MAAM7M,MAAM,qBAGbsK,EAAMgB,YAAYuB,GAElB,IAAI5G,EAAQ1D,EAAI0D,MAAMpC,KAAIsC,IACzB,IAAImH,EAAKnB,GAAGoB,KAAKpH,EAAGmE,EAAO9H,GAE3B,GAAI8H,EAAMkD,QAAQF,EAAG1P,MACpB,MAAM0M,EAAMvK,MAASoG,EAAEvI,KAAL,8BAGnB,OAAO0M,EAAMmD,KAAKH,MAGflK,EAAO+I,GAAGuB,SAASnL,EAAIa,KAAMkH,EAAO9H,GAExC,OAAO,IAAI,UAAK,CACfuC,SAAU8H,EACV5G,QACA7C,QACEkH,EAAM7K,OAGH,WAAW8C,EAAgB6J,EAAoB5J,GACrD,GAAiB,OAAbD,EAAIU,MACP,MAAMjD,MAAM,oBAEb,IAAIsK,EAAQ8B,EAAYC,OAAO,MAAO,KAAM9J,EAAI+J,UAE5CpD,EAAO3G,EAAI2G,KAAKrF,KAAI/F,GAAKqO,GAAGuB,SAAS5P,EAAGwM,EAAO9H,KAE/CmL,EAAarD,EAAM+B,OAAO,YAAa,KAAM9J,EAAI4G,MAAMmD,UAC3DpD,EAAKhD,SAAQ5I,GAAKqQ,EAAW/K,WAAWwC,KAAK9H,KAE7C,IAAI2I,EAAQ1D,EAAI0D,MAAMpC,KAAIsC,IACzB,IAAImH,EAAKnB,GAAGoB,KAAKpH,EAAGwH,EAAYnL,GAEhC,GAAImL,EAAWH,QAAQF,EAAG1P,MACzB,MAAM+P,EAAW5N,MAASoG,EAAEvI,KAAL,8BAGxB,OAAO+P,EAAWF,KAAKH,MAGpBnE,EAAQgD,GAAGuB,SAASnL,EAAI4G,MAAOwE,EAAYnL,GAE/C,OAAO,IAAI,UAAI,CAAC0G,OAAMjD,QAAOkD,SAAQmB,EAAM7K,OAGrC,YAAY8C,EAAiB6J,EAAoB5J,GACvD,GAAiB,QAAbD,EAAIU,MACP,MAAMjD,MAAM,oBAEb,IAAIsK,EAAQ8B,EAAYC,OAAO,OAAQ9J,EAAI3E,KAAM2E,EAAI+J,UAEjDlJ,EAAO+I,GAAGuB,SAASnL,EAAIa,KAAMkH,EAAO9H,GAExC,OAAO,IAAI,UAAU,CAAC5E,KAAM2E,EAAI3E,KAAMwF,QAAOkH,EAAM7K,OAG7C,cAAc8C,EAAyC6J,EAAoBwB,GACjF,GAAiB,aAAbrL,EAAIU,OAAqC,cAAbV,EAAIU,MACnC,MAAMjD,MAAM,oBAEb,IAAIpC,EAAoB,aAAb2E,EAAIU,MAAuBV,EAAI3E,KAAO,KAE7C0M,EAAQ8B,EAAYC,OAAO,SAAUzO,EAAM2E,EAAI+J,UAE/CrF,EAAyB,SAC5BvH,EAAc,KACd+E,EAAwB,GACxBjC,EAAUoL,EAEX,GAAiB,aAAbrL,EAAIU,MAAsB,CAK7B,GAJAgE,EAAa1E,EAAI0E,WACjBvH,EAAM6C,EAAI7C,IACV+E,EAAclC,EAAIkC,YAEdmJ,EAEH,MADAxN,QAAQC,IAAIuN,GACN5N,MAAM,OAGb,IAAI6N,EAAkCtL,EAAIsL,MAAMhK,KAAIjG,IACnD,IAAK0M,EAAMe,YAAYzN,GACtB,MAAM0M,EAAMvK,MAAM,YAAYnC,oBAG/B,IAAI4H,EAAM8E,EAAMmC,YAAY7O,GAE5B,IAAK4H,EAAIpC,KACR,MAAMkH,EAAMvK,MAASnC,EAAH,mBAGnB,OAAO4H,KAGRhD,EAAU,IAAI,UAAiBqL,GAGhC,IAAIjJ,EAASrC,EAAIqC,OAAOf,KAAI+I,IAC3B,IAAIC,EAAKV,GAAGpH,SAAS6H,EAAKtC,GAE1B,GAAIA,EAAMwC,eAAeD,EAAGjP,MAC3B,MAAM0M,EAAMvK,MAAM,aAAa8M,EAAGjP,kCAEnC,KAAMiP,aAAc,WACnB,MAAM7M,MAAM,qBAIb,OADAsK,EAAMgB,YAAYuB,GACXA,KAGJ5G,EAAQ1D,EAAI0D,MAAMpC,KAAIsC,IACzB,IAAImH,EAAKnB,GAAGoB,KAAKpH,EAAGmE,EAAO9H,GAE3B,GAAI8H,EAAMkD,QAAQF,EAAG1P,MACpB,MAAM0M,EAAMvK,MAASoG,EAAEvI,KAAL,8BAGnB,OAAO0M,EAAMmD,KAAKH,MAGflK,EAAO+I,GAAGuB,SAASnL,EAAIa,KAAMkH,EAAO9H,GAExC,OAAO,IAAI,UAAO,CAAC9C,MAAKC,IAAK,KAAM8E,cAAawC,aAAYrJ,OAAMgH,SAAQpC,UAASyD,QAAO7C,QAAOkH,EAAM7K,OAGjG,kBAAkB8C,EAAuB6J,EAAoB5J,GACnE,GAAiB,cAAbD,EAAIU,MACP,MAAMjD,MAAM,oBAEb,IAAIsK,EAAQ8B,EAAYC,OAAO,aAAc,SAAU9J,EAAIsG,OAAStG,EAAIsG,OAAOjL,KAAO,KAAM2E,EAAI+J,UAE5F9G,EAAM2G,GAAGuB,SAASnL,EAAIsG,OAAQyB,EAAO9H,GAErCf,EAAOc,EAAId,KAAKoC,KAAItB,GAChB4J,GAAGO,MAAMnK,EAAK+H,KAGtB,OAAO,IAAI,UAAQ,CAClB9E,MACA/D,QACE6I,EAAM7K,OAGH,iBAAiB8C,EAAsB6J,EAAoB5J,GACjE,GAAiB,aAAbD,EAAIU,MACP,MAAMjD,MAAM,oBAEb,IAAKwC,EACJ,MAAMxC,MAAM,OAGb,IAAIsK,EAAQ8B,EAAYC,OAAO,YAAa,SAAU9J,EAAIuL,QAAUvL,EAAIuL,QAAQlQ,KAAO,KAAM2E,EAAI+J,UAE7FwB,EAAU3B,GAAGuB,SAASnL,EAAIuL,QAASxD,EAAO9H,GAE1Cf,EAAQc,EAAId,KAEbc,EAAId,KAAKoC,KAAIkK,GACPA,GAAK5B,GAAGO,MAAMqB,EAAGzD,KAFvB,KAKC0D,EAAczL,EAAIyL,YAAYnK,KAAItB,GAC9B4J,GAAGuB,SAASnL,EAAK+H,EAAO9H,KAG5ByL,EAAK1L,EAAI0L,IAAM9B,GAAGuB,SAASnL,EAAI0L,GAAI3D,EAAO9H,GAE9C,OAAO,IAAI,UAAU,CACpBsL,UACArM,OACAuM,cACAC,MACEzL,EAAS8H,EAAM7K,QA5ZpB,c,8ECrEA,gBAAqByO,iBAIpB,YAAaC,GACZlR,KAAKkR,UAAYA,GAAa,GAGxB,OAAO3I,GACb,OAAOvI,KAAKkR,UAAU3B,SAAShH,M,2rBCPjC,gBACA,UACA,UACA,UACA,QACA,UAEA,WACA,UASA,MAAqB4I,kBAAkB,UAWtC,aAAa,YAACJ,EAAW,QAAEF,EAAO,KAAErM,EAAI,GAAEwM,GAA4BzL,EAA2B/C,GAChG,GAAIgC,EAAM,CACT,IACCmG,EADkBkG,EAAQ5L,KAAKiC,UACLP,KAC1BiE,EAAWpG,EAAKoC,KAAIG,GAAKA,GAAKA,EAAE9B,OAEjC,GAAI0F,EAAWzH,QAAU0H,EAAS1H,OACjC,MAAM,UAAKJ,MAAM,yCAAyC6H,EAAWzH,YAAY0H,EAAS1H,SAAUV,GAErG,IAAK,IAAIpC,EAAI,EAAGA,EAAIuK,EAAWzH,OAAQ9C,IACtC,GAAIwK,EAASxK,KAAOuK,EAAWvK,GAAGoF,OAAOoF,EAASxK,IACjD,MAAM,UAAK0C,MAAM,aAAa1C,EAAI,yCAAyCuK,EAAWvK,QAAQwK,EAASxK,KAAMoC,GAKhH,GAAIqO,aAAmB,UAAK,CAC3BA,EAAQlJ,OAAOsB,SAAQ,CAAC7G,EAAGhC,KAC1B,KAAMoE,GAAQA,EAAKpE,IAAQgC,EAAEgG,UAC5B,MAAM,UAAKtF,MAAM,aAAa1C,EAAI,yBAA0BoC,MAI9D,IAAI4O,EAASP,EAAQlJ,OAAOf,KAAI,CAACxE,EAAGhC,KACnC,GAAIoE,GAAQA,EAAKpE,GAAI,OAAOoE,EAAKpE,GAEjC,IAAIqO,EAAOoC,EAAgB1K,KAAK0D,YAAW,GAE3C,KAAM4E,aAAe,WAAM,MAAM1L,MAAM,OAEvC,OAAOoO,UAAUE,MAChBjP,EAAEgG,SACFqG,EAAIxC,KAAM8E,EACVtC,EAAIvC,MAAO8E,EACXzL,EAAS/C,MAIXqO,EAAU,IAAI,UAAQ,CACrBtI,IAAKsI,EACLrM,KAAM4M,GACJ5O,QACG,GAAIgC,EACV,MAAM,UAAK1B,MAAM,oBAAsBN,GAGxC,KAAMqO,EAAQ5L,gBAAgB,WAAY4L,EAAQ5L,KAAKoC,UACtD,MAAM,UAAKvE,MAAM,2BAA4BN,GAE9C,KAAMuO,aAAuB9N,QACxB8N,EAAYnK,KAAIG,GAAKA,aAAa,YAAMD,MAAKC,IAAMA,IACvD,MAAM,UAAKjE,MAAM,mBAAoBN,GAEtC,IAAImI,EAAakG,EAAQ5L,KAAKgH,KAC7BqF,EAAkBP,EAAYnK,KAAIG,GAAKA,EAAE9B,OAE1C,GAAI0F,EAAWzH,QAAUoO,EAAgBpO,OACxC,MAAM,UAAKJ,MAAM,yCAAyC6H,EAAWzH,YAAYoO,EAAgBpO,SAAUV,GAE5G,IAAK,IAAIpC,EAAI,EAAGA,EAAIuK,EAAWzH,OAAQ9C,IACtC,IAAKuK,EAAWvK,GAAGoF,OAAO8L,EAAgBlR,IACzC,MAAM,UAAK0C,MAAM,mCAAmC6H,EAAWvK,QAAQkR,EAAgBlR,KAAMoC,GAG/F0C,MAAM1C,EAAO,KAAM,KAAMqO,EAAQ5L,KAAKiH,OAEtClM,KAAK6Q,QAAUA,EACf7Q,KAAK+Q,YAAcA,EAEnB,IAAItC,EAAMoC,EAAQhH,YAAW,GAE7B,KAAM4E,aAAe,WACpB,MAAM,UAAK3L,MAAM,mBAAoBN,GAGtCxC,KAAKuR,oBAAsB9C,EAAIxC,KAC/BjM,KAAKwR,wBAA0BvO,MAAMwL,EAAIxC,KAAK/I,QAAQuO,KAAK,GAAG7K,KAAI,IAAM,KAExE,IAAI8K,EAAsBX,EAAYnK,KAAIiE,GAClCA,EAAIhB,YAAW,KAGvB,IAAK,IAAIzJ,EAAI,EAAGA,EAAIqO,EAAIxC,KAAK/I,OAAQ9C,IAAK,CAEzC,KADIsJ,EAAM+E,EAAIxC,KAAK7L,GAAGoF,OAAOkM,EAAoBtR,GAAImF,IAEpD,MAAM,UAAKzC,MAAM,QAAQ1C,EAAI,2CAG/BqO,EAAIxC,KAAK7L,GAAGyJ,YAAW,6CAIvBkH,EAAY3Q,GAAGyJ,YAAW,uBACTrH,GAGhBxC,KAAKwR,wBAAwBpR,GAAKsJ,EAKnC,GAFA1J,KAAK2R,oBAAsBlD,EAAIvC,MAE3B8E,EAAI,CACP,IAAItH,EACJ,KADIA,EAAM+E,EAAIvC,MAAM1G,OAAOwL,EAAIzL,IAE9B,MAAM,UAAKzC,MAAM,6CAGnB2L,EAAIvC,MAAMrC,YAAW,6DAIrBmH,EAAGnH,YAAW,uBACGrH,GAGhBxC,KAAK4R,kBAAoBlI,EACzB1J,KAAK6R,WAAab,OAElBhR,KAAK6R,WAAapD,EAAIvC,MAId,iBAAiBvG,GAC1B,OAAO3F,KAAK6Q,QAAQ9I,SAASpC,IACzB3F,KAAK+Q,YAAYrF,OAAMrL,GAAKA,EAAE0H,SAASpC,KAGrC,WAAWiB,GACjB,OAAO5G,KAAK6R,WAAWjJ,WAAWhC,GAGzB,mBAAmBzB,GAC5B,OAAOnF,KAAK6R,WAAWhI,WAAW1E,GAGzB,oBACT,OAAO,EAAAJ,eAAe+E,KAGb,eAAexE,EAAeC,GACvC,OAAOvF,KAAK6R,WAAWrM,OAAOF,EAAKC,GAG1B,iBACRM,EACAC,EACAxD,GAED,IAwCGD,EAxCCyP,EAAqC,GACrCC,EAAgD/R,KAAK+Q,YAAYnK,KAAI,CAACvG,EAAGD,KAC5E,IAAKJ,KAAKwR,wBAAwBpR,GAAG8C,OAAQ,CAC5C,GAAI2C,EAAUE,IAAI1F,GAAI,OAAOwF,EAAU5E,IAAIZ,GAC3C,GAAIyF,EAAKC,IAAI1F,GAAI,OAAOyF,EAAK7E,IAAIZ,GAGlC,IAAI2R,EAAMnM,EAAUE,IAAI1F,GACrBwF,EAAU5E,IAAIZ,GACdyF,EAAKC,IAAI1F,GACRyF,EAAK7E,IAAIZ,GACT,KACA8I,EAAQ6I,EAAM,GAAK3R,EAAE+I,SAASvD,EAAWC,EAAMxD,GAanD,OAXItC,KAAKwR,wBAAwBpR,GAAG8C,QACnCiG,EAAMhB,KAAK,CACVnC,MAAO,QACP1D,IAAKA,EAAI2D,OACT+L,IAAKA,GAAO7I,EAAMA,EAAMjG,OAAS,GAAGZ,IACpC6D,KAAMnG,KAAKuR,oBAAoBnR,GAC/B6R,GAAIjS,KAAKwR,wBAAwBpR,KAInC0R,EAAoB3J,KAAKgB,GAClBnJ,KAAKwR,wBAAwBpR,GAAG8C,OACpCZ,EAAIwG,OACJK,EAAMA,EAAMjG,OAAS,GAAGZ,OAGxBkC,EAAgB,KAChB0N,EAA4B,GAC5BC,EAAatM,EAAU5E,IAAIjB,KAAK6Q,UAChC/K,EAAK7E,IAAIjB,KAAK6Q,aAEhB7Q,KAAK6Q,mBAAmB,WAAW/K,EAAKC,IAAI/F,KAAK6Q,QAAQtI,QACrD/D,EAAOxE,KAAK6Q,QAAQrM,KAAMsB,EAAK7E,IAAIjB,KAAK6Q,QAAQtI,SAInDlG,EAGErC,KAAK6Q,mBAFa,WAAOxO,EAAE1B,MACzB0B,aAAa,WAAW,EAAAoI,WAAWpI,EAAEkG,MAAQlG,EAAEkG,IAAI5H,KAErDX,KAAK6Q,SACJqB,EAAelS,KAAK6Q,QAAQzH,SAASvD,EAAWC,EAAMxD,IAAM4P,EAAahP,OAAO,GAAGZ,KAGrFmC,EAAmB,IACnBqN,EAAoBlF,UACpBsF,EACH,CACClM,MAAO,IACP1D,IAAKA,EAAI2D,OACT4K,QAASsB,EACT3N,OACAuM,YAAagB,EACbK,QAASpS,KAAK2R,sBAchB,OAVI3R,KAAK4R,mBAAqB5R,KAAK4R,kBAAkB1O,QACpDuB,EAAI0D,KAAK,CACRnC,MAAO,QACPgM,IAAK1P,EAAIwG,OACTxG,IAAKA,EAAI2D,OACTE,KAAMnG,KAAK6R,WACXI,GAAIjS,KAAK4R,oBAIJnN,EAGD,aACL2D,EACA6D,EAAkB8E,EAClB7E,EAAiB8E,EACjBzL,EAA2B/C,GAE5B,GAAuB,GAAnB4F,EAASlF,OAAa,MAAM,UAAKJ,MAAM,MAAON,GAElD,IAAI6P,EAAqBC,EAEzB,GAAmB,KAAflK,EAAS,GAAW,CACvB,IAAK4I,EACJ,MAAM,UAAKlO,MAAM,uBAAuBsF,kCAA0C5F,GAGnF6P,EAAYnG,EACZoG,EAAWtB,MACL,CACN,IAAInP,EAAIoO,OAAO7H,EAAS,IAExB,KAAM,GAAKvG,GAAKA,GAAKkP,EAAY7N,QAChC,MAAM,UAAKJ,MAAM,uBAAuBsF,mCAA2C5F,GAEpF6P,EAAYpG,EAAKpK,EAAI,GACrByQ,EAAWvB,EAAYlP,EAAI,GAG5B,OAAO,SAAU0Q,QACfC,EACAH,EAAqBC,GAItB,GAFAA,EAAWA,EAASzI,YAAW,GAE3BzB,EAASlF,QAAUsP,EAAK,OAAOF,EAEnC,GAAI,UAAUG,KAAKrK,EAASoK,IAAO,CAClC,IAAI3Q,EAAIoO,OAAO7H,EAASoK,IAExB,GAAIH,aAAqB,WAAOC,aAAoB,UAAK,CACxD,GAAID,EAAUpG,KAAK/I,QAAUoP,EAASrG,KAAK/I,OAC1C,MAAM,UAAKJ,MAAM,uBAAuBsF,gCAAwC5F,GAGjF,KAAM,GAAKX,GAAKA,GAAKyQ,EAASrG,KAAK/I,QAClC,MAAM,UAAKJ,MAAM,uBAAuBsF,mCAA2C5F,GAGpF,OAAO+P,QAAQC,EAAM,EAAGH,EAAUpG,KAAKpK,EAAI,GAAIyQ,EAASrG,KAAKpK,EAAI,IAGlE,OAAa,CACZ,KAAOyQ,aAAoB,WAAYA,EAASnM,MAC/CmM,EAAWA,EAASnM,KAGrB,KAAMkM,aAAqB,WAAWC,aAAoB,WACzD,MAAM,UAAKxP,MAAM,uBAAuBsF,EAAY5F,GAGrD,GAAI6P,EAAU9J,IAAI/C,OAAO8M,EAAS/J,IAAKhD,GACtC,MAGD,IAAK+M,EAASvH,aAAaxF,GAC1B,MAAM,UAAKzC,MAAM,uBAAuBsF,EAAY5F,GAGrD8P,EAAWA,EAASlH,WAAW7F,GAAS2F,SAGzC,KAAM,GAAKrJ,GAAKA,GAAKyQ,EAAS9N,KAAKtB,QAClC,MAAM,UAAKJ,MAAM,uBAAuBsF,EAAY5F,GAErD,OAAO+P,QAAQC,EAAM,EAAGH,EAAU7N,KAAK3C,EAAI,GAAIyQ,EAAS9N,KAAK3C,EAAI,IAC3D,GAAqB,KAAjBuG,EAASoK,GAAa,CAChC,GAAIH,aAAqB,WAAOC,aAAoB,UACnD,OAAOC,QAAQC,EAAM,EAAGH,EAAUnG,MAAOoG,EAASpG,OAGnD,MAAM,UAAKpJ,MAAM,uBAAuBsF,EAAY5F,GAGrD,MAAM,UAAKM,MAAM,uBAAuBsF,EAAY5F,GAvD9C,CAwDJ,EAAG6P,EAAWC,GAGX,iBAAiBlL,EAAgB3H,GACvC,IAAIsR,EAAc/Q,KAAK+Q,YAAYnK,KAAIiE,GAC/BA,EAAIjI,iBAAiBwE,EAAS,KAGtC,OAAI2J,EAAYhN,KAAK,IAAIb,QAAU,IAClC6N,EAAc/Q,KAAK+Q,YAAYnK,KAAIiE,GAC3BA,EAAIjI,iBAAiBwE,KAGtB,CACHpH,KAAK6Q,QAAQjO,iBAAiBwE,GAAjC,IACA2J,EAAYhN,KAAK,MACjB,KACCA,KAAK,KAGD,CACH/D,KAAK6Q,QAAQjO,iBAAiBwE,GAAjC,IACA,KAAO2J,EAAYhN,KAAK,MAAQ,KAAKsG,OAAOjD,EAAS,IACrD,KACCrD,KAAK,KAAO,KAAKsG,OAAOjD,IAIpB,YAAYpE,EAAmBvD,GACrC,MAAO,GAAGO,KAAK6Q,QAAQvJ,aAAY,MAAUtH,KAAK+Q,YAAYnK,KAAIG,GAAKA,EAAEO,YAAY,UAAKzC,cAAad,KAAK,UAzV9G,qB,kKCfA,gBAUA,MAAqB2O,aAAa,UAMjC,aAAY,SAAC5K,EAAQ,MAAEkB,EAAK,KAAE7C,GAAyB3D,GACtD0C,MAAM1C,EAAO,KAAM,KAAM2D,EAAKlB,MAE9BjF,KAAK8H,SAAWA,EAChB9H,KAAKgJ,MAAQA,EACbhJ,KAAKmG,KAAOA,EAGN,WAAWS,GACjB,GAAIA,EAAIb,IAAI/F,KAAK8H,UAChB,MAAM/E,MAAM,uBAIb,OAFA6D,EAAM,IAAI8B,IAAI9B,GAEP5G,KAAK6J,YAAW,GAAOjB,WAAWhC,GAGhC,mBAAmBzB,GAC5B,IAAIyB,EAAM,IAAI8B,IAGd,OAFA9B,EAAI+B,IAAI3I,KAAK8H,SAAU9H,KAAK8H,SAAS3B,MAE9BnG,KAAKmG,KAAKyC,WAAWhC,GAAKiD,WAAW1E,GAGnC,kBAAkBI,GAC3B,MAAM,IAAIxC,MAAM,2BAGP,eAAeuC,EAAeC,GACvC,MAAM,IAAIxC,MAAM,2BAGP,iBAAiB4C,GAC1B,OAAO3F,KAAKmG,KAAK4B,SAASpC,GAGjB,iBAAiBE,EAAkCC,EAAgDxD,EAAc7C,GAiB1H,OAfAqG,EAAO,IAAI4C,IAAI5C,GAeR,CAbc,CACpBE,MAAO,MACP1D,IAAKA,EAAI2D,OACT0M,IAAK3S,KAAK8H,aAGE9H,KAAKgJ,MAAMpC,KAAIsC,IAC3B,IAAIC,EAAQD,EAAE/C,KAAKiD,SAASvD,EAAWC,EAAMxD,GACzC+G,EAAOF,EAAMA,EAAMjG,OAAS,GAAGZ,IAEnC,OADAwD,EAAK6C,IAAIO,EAAGG,GACLF,KACLyD,KAAK,MAKJ5M,KAAKmG,KAAKiD,SAASvD,EAAWC,EAAMxD,IAIlC,iBAAiB8E,EAAgB3H,GACvC,MAAM,IAAIsD,MAAM,2BAGV,YAAYC,EAAmBvD,GACrC,MAAM,IAAIsD,MAAM,4BAvElB,gB,kKCjBA,iBAEA,UAKA,gBAAqB6P,cACb,WAAWvF,EAAc1M,EAAckO,GAC7C,IAAIgE,EAAU,WAId,IAAKxF,EAAMkB,UAAU5N,GACpB,MAAMoC,MAAM,OAGb,IAAIoD,EAAOkH,EAAM+C,UAAUzP,GAE3B,KAAMwF,aAAgB,WACrB,MAAMpD,MAAM,OAGb,SAAS+P,YAAYxQ,EAAsB2J,EAAa8G,EAAYC,EAAuBC,GAO1F,IANA,IAAIC,EAAUjH,EAAK/I,QAEf,IAACiQ,GAAI,EAAK,IAAEC,GAAI,GAASH,GAAW,GAEpCI,EAAWpH,EAAKrF,KAAI,CAACG,EAAG3G,EAAGkT,IAAM,cAAcF,GAAOhT,GAAKkT,EAAEpQ,OAAS,EAAI,MAAQ,UAAU6D,EAAEH,KAAIC,GAAKgI,EAAIhI,EAAE0D,mBAAkB,MAAQxG,KAAK,eAAcA,KAAK,IAE1J3D,EAAI,EAAGA,EAAI6L,EAAK/I,OAAQ9C,IAChC,KAAM6L,EAAK7L,GAAG8C,QAAQ+I,EAAK7L,GAAG0N,MAE/B,MAAO,WAAWxL,SAAW+Q,QAAeF,EAAM,eAAiB,cAAcI,EAAML,MAAYH,SAAUC,aAAc/P,MAAQ+P,EAAGpM,KAAIG,GAAK,OAAOA,WAAUhD,KAAK,IAAM,mBAAmBiP,gBAG/L,SAASQ,WAAWrN,EAA4CsN,GAC/D,MAAmB,iBAARtN,EAAyB,MAAMA,QACtCA,aAAgBlD,MAAc,MAAMkD,EAAK,YAAYA,EAAK,SAC3C0I,EAAf4E,EAAmBtN,EAAK0D,YAAW,GAAMvC,aAAY,GAAM,GAEpDnB,EAAKmB,aAAY,GAAM,IAGnC,IAAIoM,EAAOvN,EAAKiD,SAAS,IAAIV,IAAO,IAAIA,IAAO,IAAI,WAAW,GAE1DiL,EAA0BD,EAAK,GAAW3K,OAAON,OAAQiL,EAAK,GAAWvK,OAEzEoK,EAAQ,SAAUhB,QAAQmB,GAC7B,OAAOE,KAAKC,OAAOH,EAAK9M,KAAItF,IAC3B,OAAQA,EAAE0E,OACT,IAAK,IACJ,OAAO4N,KAAKC,IACXtB,QAAQjR,EAAEyH,QACVwJ,QAAQjR,EAAE6H,QACP,EACL,IAAK,IACJ,OAAOyK,KAAKC,IACXtB,QAAQjR,EAAEoL,WACV6F,QAAQjR,EAAEqL,aACP,EACL,QACC,OAAO,OAdC,CAiBTgH,GAECG,EAAO,2BA8GX,OA7GAA,GAAQ,8BAA8BP,6CAEtCO,GAAQ,SAAUC,UAAU5K,EAAoB8C,GAC/C,OAAO9C,EAAMvC,KAAImH,IAChB,OAAQA,EAAK/H,OACZ,IAAK,IAGJ,IAAI2B,EAASoG,EAAKpG,OAAO+F,QACzB,OAAOqG,UAAUhG,EAAKhF,OAAQkD,EAAKxD,OAAO,CAACd,KACxCoM,UAAUhG,EAAK5E,MAAO8C,EAAKxD,OAAO,CAACd,KACvC,IAAK,IACJ,IAAIqM,EAAU/H,EAAKxD,OAAO,CAAC,KAEvBhE,EAAM,GAEV,GAA6B,GAAzBsJ,EAAKrB,UAAUxJ,OAGlBuB,GAAOqO,YACN,GAHe7P,MAAMgJ,EAAK/I,OAAS,GAAGuO,KAAK,IAG5B,GAAI,GAAI,CAAC0B,KAAK,EAAMC,KAAK,SAGzC3O,GAAOsJ,EAAKrB,UAAU9F,KAAI,CAACmH,EAAM3N,EAAGkT,IAC5BR,YACN/E,EAAKzL,IACL0R,EACAR,WAAWzF,EAAK5H,MAAM,GACtB,aACA,CAACgN,IAAK/S,GAAKkT,EAAEpQ,OAAS,EAAGkQ,KAAK,MAE7BrP,KAAK,IAQT,OALAU,GAAOsP,UACNhG,EAAKpB,WACLqH,GAIF,IAAK,IACJ,OAAOlB,YACN/E,EAAKzL,IACL2J,EACAuH,WAAWzF,EAAK5H,MAAM,GACtB,OAEF,IAAK,IACJ,MAAMpD,MAAM,MACb,IAAK,IACJ,OAAO+P,YACN/E,EAAKzL,IACL2J,EACAuH,WAAWzF,EAAK5H,MAAM,GACtB,CAAC0M,EAASW,WAAWzF,EAAK7H,OAE5B,IAAK,KACL,IAAK,MACJ,OAAO4M,YACN/E,EAAKzL,IACL2J,EACAuH,WAAWzF,EAAK5H,MAAM,GACtB,CAAC0M,EAASW,WAAWzF,EAAK5H,QAE5B,IAAK,KACJ,OAAO2M,YACN/E,EAAKzL,IACL2J,EACAuH,WAAWzF,EAAK5H,MAAM,GACtB,CAAC0M,EAAS,GAAGW,WAAWzF,EAAKnC,YAAYmC,EAAKvJ,KAAKoC,KAAI0M,GAAKE,WAAWF,KAAIvP,KAAK,WAElF,IAAK,IACJ,OAAO+O,YACN/E,EAAKzL,IACL2J,EACAuH,WAAWzF,EAAKqE,SAAS,GACzB,CAtIG,WAsII,GAAGoB,WAAWzF,EAAK8C,WAAW9C,EAAKvJ,KAAO,KAAOuJ,EAAKvJ,KAAKoC,KAAI0M,GAAKE,WAAWF,KAAIvP,KAAK,MAAQ,IAAM,OAAOgK,EAAKgD,YAAYnK,KAAI0M,GAAKE,WAAWF,KAAIvP,KAAK,WAEpK,IAAK,KACJ,OAAO+O,YACN/E,EAAKzL,IACL2J,EACAuH,WAAWzF,EAAK5H,MAAM,GACtB,iCAEF,IAAK,MACJ,OAAO2M,YACN/E,EAAKzL,IACL2J,EACAuH,WAAWzF,EAAK4E,KAChB,cAEF,IAAK,QACJ,OAAOG,YACN/E,EAAKzL,IACL2J,EACAuH,WAAWzF,EAAK5H,MAChB,oBAAoB4H,EAAKkE,GAAGrL,KAAIqN,GACxBT,WAAWS,KAChBlQ,KAAK,UAAUyP,WAAWzF,EAAKiE,SAEpC,QACC,MAAMjP,MAAM,gBAAiBgL,EAAa/H,WAE1CjC,KAAK,IAtGD,CAuGL4P,EAAW,IAEdG,GAAQ,c,8EC/KV,gBAAqBI,QAIpB,YAAarL,EAAc,GAC1B7I,KAAK6B,EAAIgH,EAGH,OACN,OAAO7I,KAAK6B,EAGN,OACN,QAAS7B,KAAK6B,K,kKCbhB,gBACA,UAEA,WACA,UAEA,UAEA,WAQA,MAAqBsS,MAiBpB,YAAaxG,EAAiByG,EAAe5R,GAM5C,GAtBe,KAAAyL,UAAgC,IAAIvF,IAEpC,KAAA2L,WAAsC,IAAI3L,IAC1C,KAAA4L,OAA4C,IAAI5L,IAChD,KAAA6L,UAAiC,IAAI7L,IACrC,KAAA5C,KAA+B,IAAI4C,IACnC,KAAA/C,WAAyB,GAWxC3F,KAAK2N,QAAUA,EAEf3N,KAAKoU,OAASA,EACdpU,KAAKP,KAAO2U,EAASA,EAAO3U,KAAOO,KAE/BwC,KAAWA,aAAiB,WAC/B,MAAMO,MAAM,oBAGb/C,KAAKwC,MAAQA,GAAS,IAAI,UAAWmL,GAErC3N,KAAKwU,SAAWJ,EAASA,EAAOI,SAAW,KAGrC,OAAOvP,EAActE,EAAc0O,GACzC,IAAIoF,EAAQ,IAAIN,MAAMnU,KAAK2N,QAAS3N,KAAMA,KAAKwC,MAAM4M,OAAO,CAACnK,OAAMtE,OAAM0O,cAEzE,OADArP,KAAK2F,WAAWsD,SAAQyL,GAAKD,EAAM9O,WAAWwC,KAAKuM,KAC5CD,EAGD,MAAM5R,GACZ,OAAO7C,KAAKwC,MAAMM,MAAMD,GAUlB,WAAWlC,GACjB,GAAmB,iBAARA,EACV,OAAOX,KAAKqU,WAAWtO,IAAIpF,IACvB,IAAIX,KAAKiO,UAAU0G,UAAU7N,MAAKzE,GAAKA,EAAEuS,WAAWjU,KAGzD,KAAMA,aAAgBsC,OACrB,MAAMjD,KAAK8C,MAAM,yBAElB,GAAInC,EAAKuC,OAAS,EACjB,MAAMlD,KAAK8C,MAAM,wBAElB,OAAOnC,EAAKiG,KAAIG,GACR/G,KAAK4U,WAAW7N,KACrB2E,OAAM3E,GAAKA,IAUR,QAAQpG,GACd,GAAmB,iBAARA,EACV,OAAOX,KAAK4U,WAAWjU,MAChBX,KAAKoU,QAAUpU,KAAKoU,OAAOlG,QAAQvN,GAG3C,KAAMA,aAAgBsC,OACrB,MAAMjD,KAAK8C,MAAM,yBAElB,GAAInC,EAAKuC,OAAS,EACjB,MAAMlD,KAAK8C,MAAM,wBAElB,OAAOnC,EAAKiG,KAAIG,GACR/G,KAAKkO,QAAQnH,KAClB2E,OAAM3E,GAAKA,IAGR,QAAQ9B,GACd,KAAMA,aAAgB,WACrB,MAAMjF,KAAK8C,MAAM,yBAElB,IAAKmC,EAAKtE,KACT,MAAMX,KAAK8C,MAAM,qBAElB,GAAI9C,KAAK4U,WAAW3P,EAAKtE,MACxB,MAAMX,KAAK8C,MAAM,QAAQmC,EAAKtE,kCAE/B,GAAIsE,EAAKuB,WAAY,CACpB,GAAIxG,KAAKwU,SACR,MAAMxU,KAAK8C,MAAM,+BAGlB,SAAU+R,UAAUxH,GACnBA,EAAMmH,SAAWvP,EACboI,EAAM+G,QAAQS,UAAUxH,EAAM+G,QAFnC,CAGGpU,MAIJ,OADAA,KAAKqU,WAAW1L,IAAI1D,EAAKtE,KAAMsE,GACxBA,EAUD,QAAQtE,GACd,GAAmB,iBAARA,EAAkB,CAC5B,IAAKX,KAAKkO,QAAQvN,GACjB,MAAMX,KAAK8C,MAAM,QAAQnC,oBAE1B,OAAOX,KAAKqU,WAAWtO,IAAIpF,GACxBX,KAAKqU,WAAWpT,IAAIN,KACjBX,KAAKoU,QAAUpU,KAAKoU,OAAO9E,QAAQ3O,IACpC,IAAIX,KAAKiO,UAAU0G,UAAUG,QAAOzS,GAC/BA,EAAE6L,QAAQvN,KACf,GAAG2O,QAAQ3O,GAGjB,KAAMA,aAAgBsC,OACrB,MAAMjD,KAAK8C,MAAM,yBAElB,GAAInC,EAAKuC,OAAS,EACjB,MAAMlD,KAAK8C,MAAM,wBAElB,IAAI6D,EAAOhG,EAAK+M,MAAM,EAAG/M,EAAKuC,OAAS,GAAG0D,KAAIG,GACtC/G,KAAKsP,QAAQvI,KAGjBC,EAAKhH,KAAKsP,QAAQ3O,EAAKA,EAAKuC,OAAS,IAEzC,OAAO,IAAI,UAAW,CACrBwD,YAAY,EACZC,OACAK,OAIK,eAAerG,GACrB,OAAOX,KAAKsU,OAAOvO,IAAIpF,IACnB,IAAIX,KAAKiO,UAAU0G,UAAU7N,MAAKzE,GAAKA,EAAEwN,eAAelP,KAGtD,YAAYA,GAClB,OAAOX,KAAK6P,eAAelP,MACpBX,KAAKoU,QAAUpU,KAAKoU,OAAOhG,YAAYzN,GAGxC,YAAYmH,GAClB,KAAMA,aAAoB,WACzB,MAAM9H,KAAK8C,MAAM,yBAElB,GAAI9C,KAAK6P,eAAe/H,EAASnH,MAChC,MAAMX,KAAK8C,MAAM,cAAcgF,EAASnH,kCAGzC,OADAX,KAAKsU,OAAO3L,IAAIb,EAASnH,KAAMmH,GACxBA,EAGD,OAAOS,GACb,KAAMA,aAAe,WACpB,MAAMvI,KAAK8C,MAAM,yBAElB,IAAKyF,EAAI5H,KACR,MAAMX,KAAK8C,MAAM,qCAElB,GAAI9C,KAAK6P,eAAetH,EAAI5H,MAC3B,MAAMX,KAAK8C,MAAM,cAAcyF,EAAI5H,kCAGpC,OADAX,KAAKsU,OAAO3L,IAAIJ,EAAI5H,KAAM4H,GACnBA,EAGD,YAAY5H,GAClB,IAAKX,KAAKoO,YAAYzN,GACrB,MAAMX,KAAK8C,MAAM,cAAcnC,oBAEhC,OAAOX,KAAKsU,OAAOvO,IAAIpF,GACpBX,KAAKsU,OAAOrT,IAAIN,KACbX,KAAKoU,QAAUpU,KAAKoU,OAAO5E,YAAY7O,IACxC,IAAIX,KAAKiO,UAAU0G,UAAUG,QAAOzS,GAC/BA,EAAE+L,YAAYzN,KACnB,GAAG6O,YAAY7O,GAGd,aAAaA,GACnB,OAAOX,KAAKuU,UAAUxO,IAAIpF,IAASX,KAAKsU,OAAOvO,IAAIpF,IAC/C,IAAIX,KAAKiO,UAAU0G,UAAU7N,MAAKzE,GAAKA,EAAE0S,aAAapU,KAGpD,UAAUA,GAChB,OAAOX,KAAK+U,aAAapU,MAClBX,KAAKoU,QAAUpU,KAAKoU,OAAO7F,UAAU5N,GAGtC,UAAUiL,GAChB,KAAMA,aAAkB,WACvB,MAAM5L,KAAK8C,MAAM,yBAElB,GAAI9C,KAAK+U,aAAanJ,EAAOjL,MAC5B,MAAMX,KAAK8C,MAAM,UAAU8I,EAAOjL,kCAGnC,OADAX,KAAKuU,UAAU5L,IAAIiD,EAAOjL,KAAMiL,GACzBA,EAGD,UAAUjL,GAChB,IAAKX,KAAKuO,UAAU5N,GACnB,MAAMX,KAAK8C,MAAM,UAAUnC,oBAE5B,OAAOX,KAAKuU,UAAUxO,IAAIpF,GACvBX,KAAKuU,UAAUtT,IAAIN,GACnBX,KAAKsU,OAAOvO,IAAIpF,GACfX,KAAKsU,OAAOrT,IAAIN,KACbX,KAAKoU,QAAUpU,KAAKoU,OAAOhE,UAAUzP,IACtC,IAAIX,KAAKiO,UAAU0G,UAAUG,QAAOzS,GAC/BA,EAAEkM,UAAU5N,KACjB,GAAGyP,UAAUzP,GAGb,QAAQA,GACd,OAAOX,KAAK8F,KAAKC,IAAIpF,IACjB,IAAIX,KAAKiO,UAAU0G,UAAU7N,MAAKzE,GAAKA,EAAEkO,QAAQ5P,KAG/C,KAAKA,GACX,OAAOX,KAAKuQ,QAAQ5P,MACbX,KAAKoU,QAAUpU,KAAKoU,OAAOlE,KAAKvP,GAGjC,KAAKuI,GACX,KAAMA,aAAa,WAClB,MAAMlJ,KAAK8C,MAAM,yBAElB,GAAI9C,KAAKuQ,QAAQrH,EAAEvI,MAClB,MAAMX,KAAK8C,MAAM,cAAcoG,EAAEvI,kCAGlC,OADAX,KAAK8F,KAAK6C,IAAIO,EAAEvI,KAAMuI,GACfA,EAGD,KAAKvI,GACX,IAAKX,KAAKkQ,KAAKvP,GACd,MAAMX,KAAK8C,MAAM,cAAcnC,oBAEhC,OAAOX,KAAK8F,KAAKC,IAAIpF,GAClBX,KAAK8F,KAAK7E,IAAIN,KACXX,KAAKoU,QAAUpU,KAAKoU,OAAOjE,KAAKxP,IACjC,IAAIX,KAAKiO,UAAU0G,UAAUG,QAAOzS,GAC/BA,EAAE6N,KAAKvP,KACZ,GAAGwP,KAAKxP,IA1Qf,iB,8ECRA,MAAqBqU,WAKpB,YAAarH,EAAiBsH,GAC7BjV,KAAK2N,QAAUA,EACf3N,KAAKiV,MAAQA,GAAS,GAGhB,OAAOC,GACb,OAAO,IAAIF,WAAWhV,KAAK2N,QAAS,CAACuH,GAASzM,OAAOzI,KAAKiV,QAGpD,MAAMpS,GACZ,IAAI8K,EAAU3N,KAAK2N,SAAW,YAE9B,OAAO,IAAI5K,MACVF,EACE,WAED7C,KAAKiV,MAAM/R,OACRlD,KAAKiV,MAAMrO,KAAI,EAAE3B,OAAMtE,OAAM0O,cACvB,GAAGpK,KAAQtE,GAAQ,kBAAkBgN,KAAW0B,EAASxG,MAAMkF,QAAQsB,EAASxG,MAAMsM,YAC3FpR,KAAK,WACN,WAAW4J,YAzBlB","file":"math.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"math\"] = factory();\n\telse\n\t\troot[\"math\"] = factory();\n})(typeof self !== 'undefined' ? self : this, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 15);\n","import StackTrace from '../StackTrace';\n\nvar ctr = 0;\n\nexport type Precedence = boolean | number | [number, number];\n\nexport default abstract class Node {\n\tpublic readonly _id: number;\n\n\tpublic readonly trace: StackTrace;\n\tpublic readonly doc: string;\n\tpublic readonly tex: string;\n\tpublic precedence: Precedence;\n\n\tpublic static readonly PREC_FUNEXPR = 1000;\n\tpublic static readonly PREC_COMMA = 1000;\n\tpublic static readonly PREC_COLONEQQ = 100000;\n\n\tconstructor (trace: StackTrace, doc: string, tex: string) {\n\t\tthis._id = ++ctr;\n\t\tthis.trace = trace;\n\t\tthis.doc = doc;\n\t\tthis.tex = tex;\n\t}\n\n\tpublic toString() {\n\t\treturn this.toIndentedString(0);\n\t}\n\n\tpublic abstract toIndentedString(indent: number, root?: boolean): string;\n\tpublic abstract toTeXString(prec?: Precedence, root?: boolean): string;\n\n\tpublic error(message: string) {\n\t\treturn Node.error(message, this.trace);\n\t}\n\n\tpublic static error(message: string, trace: StackTrace) {\n\t\tif (trace) {\n\t\t\treturn trace.error(message);\n\t\t} else {\n\t\t\treturn new Error(message);\n\t\t}\n\t}\n\n\t/*\n\t* false corresponds to 0.\n\t* true corresponds to w * 2.\n\t*/\n\tpublic static normalizePrecedence(prec: Precedence) {\n\t\tif (prec === false) return [0, 0];\n\t\tif (prec === true) return [2, 0];\n\t\tif (typeof prec == 'number') return [0, prec];\n\n\t\tif (!(prec instanceof Array && prec.length == 2)) {\n\t\t\tconsole.log(prec);\n\t\t\tthrow Error('wut');\n\t\t}\n\n\t\treturn prec;\n\t}\n\n\tpublic shouldConsolidate(prec: Precedence): boolean {\n\t\tvar my = Node.normalizePrecedence(this.precedence || false),\n\t\t\tyour = Node.normalizePrecedence(prec || false);\n\n\t\tif (my[0] == 0 && my[1] == 0) return false;\n\n\t\treturn !(my[0] < your[0] || my[0] == your[0] && my[1] < your[1]);\n\t}\n\n\tpublic static escapeTeX(s: string): string {\n\t\treturn s.replace(/&|%|\\$|#|_|{|}|~|\\^|\\\\/g, m => ({\n\t\t\t'&': '\\\\&', '%': '\\\\%', '$': '\\\\$',\n\t\t\t'#': '\\\\#', '_': '\\\\_', '{': '\\\\{',\n\t\t\t'}': '\\\\}',\n\t\t\t'~': '\\\\textasciitilde',\n\t\t\t'^': '\\\\textasciicircum',\n\t\t\t'\\\\': '\\\\textbackslash'\n\t\t})[m]);\n\t}\n\n\tpublic static parseTeX(tex: string) {\n\t\tvar precedence: Precedence = false;\n\n\t\tvar code = tex.replace(/^!<prec=([0-9]+)>/, (match, g1) => {\n\t\t\tprecedence = g1 * 1;\n\t\t\treturn '';\n\t\t});\n\n\t\treturn {precedence, code};\n\t}\n\n\tpublic static makeTeXName(name: string): string {\n\t\tvar alphabet = [\n\t\t\t\"alpha\", \"beta\", \"gamma\", \"delta\",\n\t\t\t\"epsilon\", \"zeta\", \"eta\", \"theta\",\n\t\t\t\"iota\", \"kappa\", \"lambda\", \"mu\",\n\t\t\t\"nu\", \"xi\", \"omicron\", \"pi\",\n\t\t\t\"rho\", \"sigma\", \"tau\", \"upsilon\",\n\t\t\t\"phi\", \"chi\", \"psi\", \"omega\"\n\t\t];\n\n\t\tvar regex = new RegExp(`^(?:([a-z])|(${alphabet.join('|')}))([0-9]*)$`, 'i');\n\t\tvar match = name.match(regex);\n\n\t\tif (match) {\n\t\t\tvar letter = (() => {\n\t\t\t\tif (match[1]) return match[1];\n\t\t\t\t\n\t\t\t\tvar capitalize = match[2].charCodeAt(0) <= 'Z'.charCodeAt(0);\n\t\t\t\tvar commandName = match[2].toLowerCase();\n\n\t\t\t\tif (capitalize) {\n\t\t\t\t\tcommandName = commandName[0].toUpperCase() + commandName.substring(1);\n\t\t\t\t}\n\n\t\t\t\treturn '\\\\' + commandName;\n\t\t\t})();\n\n\t\t\tvar subscript = (() => {\n\t\t\t\tif (!match[3]) return '';\n\t\t\t\tif (match[3].length == 1) return '_' + match[3];\n\t\t\t\treturn `_{${match[3]}}`;\n\t\t\t})();\n\n\t\t\treturn letter + subscript;\n\t\t}\n\n\t\tif (name.length == 1) {\n\t\t\treturn Node.escapeTeX(name);\n\t\t}\n\n\t\treturn `\\\\mathrm{${Node.escapeTeX(name)}}`;\n\t}\n\n\tpublic makeTeX(id, args, prec) {\n\t\targs = args || [];\n\t\tprec = prec || false;\n\t\t\n\t\tvar ret = this.tex;\n\n\t\tif (this.shouldConsolidate(prec)) {\n\t\t\tret = '\\\\left(' + ret + '\\\\right)';\n\t\t}\n\n\t\treturn ret.replace(/#([0-9]+)/g, (match, g1) => {\n\t\t\treturn args[g1 * 1 - 1] || `\\\\texttt{\\\\textcolor{red}{\\\\#${g1}}}`;\n\t\t}).replace(/<<(.+?)>>/, (_match, g1) => {\n\t\t\treturn `\\\\href{#${id}}{${g1}}`;\n\t\t});\n\t}\n}","import Counter from \"../Counter\";\nimport ExecutionContext from \"../ExecutionContext\";\nimport { ProofType } from \"../ProofType\";\nimport StackTrace from \"../StackTrace\";\nimport Expr0 from \"./Expr0\";\nimport Fun from \"./Fun\";\nimport Node from \"./Node\";\nimport Type from \"./Type\";\nimport Variable from \"./Variable\";\n\n/**\n *     .\n */\nexport enum EqualsPriority {\n\t/** Variable (primitive) */\n\tZERO,\n\t/** Fun */\n\tONE,\n\t/** Tee */\n\tTWO,\n\t/** Funcall */\n\tTHREE,\n\t/** Variable (macro) */\n\tFOUR,\n\t/** $Variable, Reduction */\n\tFIVE\n}\n\nexport default abstract class Metaexpr extends Node {\n\t\n\tpublic readonly type: Type;\n\tprivate expandMetaCache: Metaexpr;\n\n\tconstructor(trace: StackTrace, doc: string, tex: string, type: Type) {\n\t\tsuper(trace, doc, tex);\n\n\t\tif (!type) throw Node.error('Assertion failed', trace);\n\n\t\tthis.type = type;\n\t}\n\n\tpublic abstract substitute(map: Map<Variable, Expr0>): Metaexpr;\n\n\t/**\n\t * \n\t * @param andFuncalls   Funcall .\n\t */\n\tpublic expandMeta(andFuncalls: boolean): Metaexpr {\n\t\tif (this.expandMetaCache) return this.expandMetaCache;\n\t\treturn this.expandMetaCache = this.expandMetaInternal(andFuncalls);\n\t}\n\n\tprotected abstract expandMetaInternal(andFuncalls: boolean): Metaexpr;\n\n\t/**\n\t * \n\t * @return   `false`.       .\n\t */\n\tpublic equals(obj: Metaexpr, context: ExecutionContext): (Fun | Variable)[] | false {\n\t\t// console.log(`${this}\\n\\n${obj}`);\n\t\t// var ret = (() => {\n\t\t\n\t\tif (this === obj) return [];\n\t\tif (!this.type.equals(obj.type)) return false;\n\n\t\tif (obj.getEqualsPriority(context) > this.getEqualsPriority(context))\n\t\t\treturn obj.equalsInternal(this, context);\n\t\t\n\t\treturn this.equalsInternal(obj, context);\n\n\t\t// })();\n\t\t// console.log(`${this}\\n\\n${obj}\\n\\nresult:`, ret);\n\t\t// return ret;\n\t}\n\n\t/**\n\t * \n\t * @return   `false`.       .\n\t */\n\tprotected abstract equalsInternal(obj: Metaexpr, context: ExecutionContext): (Fun | Variable)[] | false;\n\n\tprotected abstract getEqualsPriority(context: ExecutionContext): EqualsPriority;\n\n\tpublic isProved(hypotheses?: Metaexpr[]): boolean {\n\t\thypotheses = hypotheses || [];\n\n\t\tfor (var i = 0; i < hypotheses.length; i++) {\n\t\t\tif (hypotheses[i] == this) return true;\n\t\t}\n\n\t\treturn this.isProvedInternal(hypotheses);\n\t}\n\n\tprotected abstract isProvedInternal(hypotheses: Metaexpr[]): boolean;\n\n\tpublic getProof(\n\t\t\thypnumMap: Map<Metaexpr, number>,\n\t\t\t$Map: Map<Metaexpr, number | [number, number]>,\n\t\t\tctr: Counter,\n\t\t\troot: boolean=false): ProofType[] {\n\t\t\n\t\tif (hypnumMap.has(this)) {\n\t\t\treturn [{\n\t\t\t\t_type: 'R',\n\t\t\t\tctr: ctr.next(),\n\t\t\t\tnum: hypnumMap.get(this),\n\t\t\t\texpr: this\n\t\t\t}];\n\t\t}\n\n\t\tif ($Map.has(this)) {\n\t\t\treturn [{\n\t\t\t\t_type: 'R',\n\t\t\t\tctr: ctr.next(),\n\t\t\t\tnum: $Map.get(this),\n\t\t\t\texpr: this\n\t\t\t}];\n\t\t}\n\n\t\treturn this.getProofInternal(hypnumMap, $Map, ctr, root);\n\t}\n\n\tprotected abstract getProofInternal(\n\t\t\thypnumMap: Map<Metaexpr, number>,\n\t\t\t$Map: Map<Metaexpr, number | [number, number]>,\n\t\t\tctr: Counter,\n\t\t\troot?: boolean): ProofType[];\n}","import Nameable from './Nameable';\nimport Node from './Node';\nimport Type from './Type';\n\nexport default class ObjectType extends Type implements Nameable {\n\n\tpublic readonly isBaseType: boolean;\n\tpublic readonly name: string;\n\tpublic readonly origin: ObjectType;\n\tpublic readonly from: ObjectType[];\n\tpublic readonly to: ObjectType;\n\n\tconstructor (o) {\n\t\tif (o.origin) {\n\t\t\tsuper(null, o.doc, null, o.origin.isFunctional);\n\n\t\t\tthis.isBaseType = !!o.base;\n\n\t\t\tif (typeof o.name != 'string')\n\t\t\t\tthrow Node.error('typeof o.name != \\'string\\'', null);\n\t\t\tthis.name = o.name;\n\n\t\t\tif (!(o.origin instanceof ObjectType))\n\t\t\t\tthrow Node.error('!(o.origin instanceof ObjectType)', null);\n\n\t\t\tthis.origin = o.origin;\n\t\t} else {\n\t\t\tsuper(null, o.doc, null, o.functional);\n\n\t\t\tthis.isBaseType = !!o.base;\n\n\t\t\tif (typeof o.functional != 'boolean')\n\t\t\t\tthrow Node.error('typeof o.functional != \\'boolean\\'', null);\n\n\t\t\tif (!o.functional) {\n\t\t\t\tif (typeof o.name != 'string')\n\t\t\t\t\tthrow Node.error('typeof o.name != \\'string\\'', null);\n\t\t\t\tthis.name = o.name;\n\t\t\t} else {\n\t\t\t\tif (o.from.map(f => f instanceof ObjectType).some(e => !e))\n\t\t\t\t\tthrow Node.error('o.from.map(f => f instanceof ObjectType).some(e => !e)', null);\n\t\t\t\tif (!(o.to instanceof ObjectType))\n\t\t\t\t\tthrow Node.error('!(o.to instanceof ObjectType)', null);\n\n\t\t\t\tthis.from = o.from;\n\t\t\t\tthis.to = o.to;\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic toSimpleString() {\n\t\tif (this.name) return this.name;\n\n\t\tvar resolved = this.resolve();\n\n\t\treturn `[${resolved.from.map(e => e.toSimpleString()).join(', ')} -> ${resolved.to.toSimpleString()}]`;\n\t}\n\n\tpublic toIndentedString(indent): string {\n\t\tif (this.isSimple) return this.name;\n\n\t\treturn `${this.name ? this.name + ': ' : ''}[${this.resolve().from.join(', ')} -> ${this.resolve().to}]`;\n\t}\n\n\tpublic toTeXString(root?: boolean) {\n\t\tif (this.isSimple) return `\\\\href{#type-${this.name}}\\\\mathsf{${this.name}}`;\n\n\t\tif (!root && this.name) {\n\t\t\treturn `\\\\href{#type-${this.name}}\\\\mathsf{${this.name}}`;\n\t\t}\n\n\t\treturn `${this.name ? `\\\\href{#type-${this.name}}\\\\mathsf{${this.name}}: ` : ''}`\n\t\t\t+ `\\\\left[${this.resolve().from.map(e => e.toTeXString()).join(' \\\\times ')}`\n\t\t\t+ ` \\\\to ${this.resolve().to.toTeXString()} \\\\right]`;\n\t}\n\n\tpublic resolve(): ObjectType {\n\t\treturn this.origin ? this.origin.resolve() : this;\n\t}\n\n\tpublic equals(t: Type): boolean {\n\t\tif (!(t instanceof ObjectType)) return false;\n\n\t\tif (this.origin) return this.origin.equals(t);\n\t\tif (t.origin) return this.equals(t.origin);\n\n\t\tif (this.isSimple != t.isSimple) return false;\n\n\t\tif (this.isSimple) return this === t;\n\n\t\tif (this.from.length != t.from.length) return false;\n\n\t\tfor (var i = 0; i < this.from.length; i++)\n\t\t\tif (!this.from[i].equals(t.from[i])) return false;\n\n\t\treturn this.to.equals(t.to);\n\t}\n}","import Expr0 from './Expr0';\nimport Nameable from './Nameable';\n\nexport default abstract class Fun extends Expr0 implements Nameable {\n\n\tpublic readonly annotations: string[];\n\tpublic readonly sealed: boolean;\n\tpublic readonly name: string;\n\tpublic readonly params: Parameter[];\n\tpublic readonly expr: Metaexpr;\n\n\tconstructor ({doc, tex, annotations, sealed, rettype, name, params, expr}: FunArgumentType, trace: StackTrace) {\n\t\tif (!name && !expr)\n\t\t\tthrow Node.error('Anonymous fun cannot be primitive', trace);\n\n\t\tif (rettype && expr) {\n\t\t\tif (!rettype.equals(expr.type)) {\n\t\t\t\tthrow Node.error(`Expression type ${expr.type} failed to match the return type ${rettype} of fun ${name}`, trace);\n\t\t\t}\n\t\t}\n\n\t\tif (!rettype && !expr) {\n\t\t\tthrow Node.error('Cannot guess the return type of a primitive fun', trace);\n\t\t}\n\t\t\n\t\tif (sealed && !expr) {\n\t\t\tthrow Node.error('Cannot seal a primitive fun', trace);\n\t\t}\n\t\t\n\t\tvar precedence = false;\n\n\t\tif (tex) {\n\t\t\tvar parsed = Node.parseTeX(tex);\n\t\t\tprecedence = parsed.precedence;\n\t\t\ttex = parsed.code;\n\t\t} else {\n\t\t\ttex = null;\n\t\t}\n\t\t\n\t\tsuper(\n\t\t\ttrace, doc, tex,\n\t\t\tnew ((rettype || expr.type) instanceof ObjectType ? ObjectType : MetaType)({\n\t\t\t\tfunctional: true,\n\t\t\t\tfrom: params.map(variable => variable.type),\n\t\t\t\tto: rettype || expr.type as any\n\t\t\t})\n\t\t);\n\n\t\tthis.annotations = annotations;\n\t\tthis.sealed = sealed;\n\t\tthis.precedence = precedence;\n\t\tthis.name = name;\n\t\tthis.params = params;\n\t\tthis.expr = expr;\n\t}\n\n\tprotected isProvedInternal(hypotheses: Metaexpr[]): boolean {\n\t\treturn this.expr && this.expr.isProved(hypotheses);\n\t}\n\n\tprotected getEqualsPriority(): EqualsPriority {\n\t\treturn EqualsPriority.ONE;\n\t}\n\t\n\tprotected equalsInternal(obj: Metaexpr, context: ExecutionContext): (Fun | Variable)[] | false {\n\t\tif (!(this.expr && !this.sealed)\n\t\t\t\t&& !(obj instanceof Fun && obj.expr && !obj.sealed)) {\n\t\t\treturn false;\n\t\t}\n\n\t\tvar placeholders = [];\n\t\tvar types = (this.type.resolve() as ObjectType | MetaType).from;\n\n\t\tfor (var i = 0; i < types.length; i++) {\n\t\t\tplaceholders.push(new Parameter({\n\t\t\t\ttype: types[i],\n\t\t\t\tname: '$' + i,\n\t\t\t\tselector: null\n\t\t\t}, this.trace));\n\t\t}\n\n\t\tvar usedMacrosList = [];\n\n\t\tvar thisCall = this.expr && !this.sealed\n\t\t\t? (this.name && usedMacrosList.push(this), this.call(placeholders))\n\t\t\t: new Funcall({\n\t\t\t\tfun: this,\n\t\t\t\targs: placeholders\n\t\t\t}, this.trace);\n\n\t\tvar objCall = obj instanceof Fun && obj.expr && !obj.sealed\n\t\t\t? (obj.name && usedMacrosList.push(obj), obj.call(placeholders))\n\t\t\t: new Funcall({\n\t\t\t\tfun: obj,\n\t\t\t\targs: placeholders\n\t\t\t}, this.trace);\n\t\t\n\t\tvar ret = thisCall.equals(objCall, context);\n\t\treturn ret && ret.concat(usedMacrosList);\n\t}\n\n\tpublic abstract isCallable(context: ExecutionContext): boolean;\n\n\tpublic call(args: Expr0[]): Metaexpr {\n\t\tif (!this.expr) {\n\t\t\tthrow Error('Cannot call a primitive fun');\n\t\t}\n\n\t\tif (this.params.length != args.length) {\n\t\t\tthrow Error('Illegal arguments length');\n\t\t}\n\n\t\tvar map: Map<Variable, Expr0> = new Map();\n\n\t\tfor (var i = 0; i < this.params.length; i++) {\n\t\t\tmap.set(this.params[i], args[i]);\n\t\t}\n\n\t\treturn this.expr.substitute(map);\n\t}\n\n\tprotected getProofInternal(\n\t\t\thypnumMap: Map<Metaexpr, number>,\n\t\t\t$Map: Map<Metaexpr, number | [number, number]>,\n\t\t\tctr: Counter,\n\t\t\troot: boolean=false): ProofType[] {\n\t\t\n\t\tif (this instanceof Schema && this.name && !root) {\n\t\t\treturn [{\n\t\t\t\t_type: 'RS',\n\t\t\t\tctr: ctr.next(),\n\t\t\t\texpr: this\n\t\t\t}];\n\t\t}\n\n\t\tif (!this.expr) {\n\t\t\treturn [{\n\t\t\t\t_type: 'NP',\n\t\t\t\tctr: ctr.next(),\n\t\t\t\texpr: this\n\t\t\t}];\n\t\t}\n\n\t\t$Map = new Map($Map);\n\n\t\tvar start = ctr.peek() + 1;\n\n\t\tvar $lines: ProofType[] = [];\n\t\t\n\t\tif (this instanceof Schema) {\n\t\t\tthis.def$s.forEach($ => {\n\t\t\t\tvar lines = $.expr.getProof(hypnumMap, $Map, ctr);\n\t\t\t\t$lines = $lines.concat(lines);\n\n\t\t\t\tvar $num = lines[lines.length - 1].ctr;\n\t\t\t\t$Map.set($, $num);\n\t\t\t});\n\t\t}\n\n\t\treturn [{\n\t\t\t_type: 'V',\n\t\t\t$lines,\n\t\t\tlines: this.expr.getProof(hypnumMap, $Map, ctr),\n\t\t\tparams: this.params,\n\t\t\tctr: [start, ctr.peek()]\n\t\t}];\n\t}\n}\n\nimport Funcall from './Funcall';\nimport Metaexpr, { EqualsPriority } from './Metaexpr';\nimport MetaType from './MetaType';\nimport Node from './Node';\nimport ObjectType from './ObjectType';\nimport Type from './Type';\nimport Variable from './Variable';\nimport StackTrace from '../StackTrace';\nimport ExecutionContext from '../ExecutionContext';\nimport Counter from '../Counter';\nimport { ProofType } from '../ProofType';\nimport Schema from './Schema';\nimport Parameter from './Parameter';\n\ninterface FunArgumentType {\n\tdoc: string;\n\ttex: string;\n\tannotations: string[];\n\tsealed: boolean;\n\trettype: Type;\n\tname: string;\n\tparams: Parameter[];\n\texpr: Metaexpr;\n}","import Counter from '../Counter';\nimport ExecutionContext from '../ExecutionContext';\nimport { ProofType } from '../ProofType';\nimport StackTrace from '../StackTrace';\nimport Expr0 from './Expr0';\nimport Fun from './Fun';\nimport Metaexpr, { EqualsPriority } from './Metaexpr';\nimport Nameable from './Nameable';\nimport Node, { Precedence } from './Node';\nimport ObjectType from './ObjectType';\n\ninterface VariableArgumentType {\n\tdoc?: string;\n\ttex?: string;\n\tsealed: boolean;\n\ttype: ObjectType;\n\tname: string;\n\texpr: Expr0;\n}\n\nexport default class Variable extends Expr0 implements Nameable {\n\n\tpublic readonly sealed: boolean;\n\tpublic readonly type: ObjectType;\n\tpublic readonly name: string;\n\tpublic readonly expr: Expr0 | null;\n\n\tconstructor ({doc, tex, sealed, type, name, expr}: VariableArgumentType, trace: StackTrace) {\n\t\tsuper(trace, doc, tex, type);\n\t\t\n\t\tif (typeof name != 'string')\n\t\t\tthrow Node.error('Assertion failed', trace);\n\t\t\n\t\tif (sealed && !expr) {\n\t\t\tthrow Node.error('Cannot seal a primitive fun', trace);\n\t\t}\n\n\t\tif (expr && !type.equals(expr.type)) {\n\t\t\tthrow Node.error(`Expression type ${expr.type} failed to match the type ${type} of variable ${name}`, trace);\n\t\t}\n\n\t\tthis.sealed = sealed;\n\t\tthis.name = name;\n\t\tthis.expr = expr;\n\t}\n\n\tprotected isProvedInternal(hypotheses: Metaexpr[]): boolean {\n\t\treturn false;\n\t}\n\n\tpublic substitute(map: Map<Variable, Expr0>): Metaexpr {\n\t\tif (map.has(this)) return map.get(this);\n\n\t\t//          \n\t\t//   .\n\t\treturn this;\n\t}\n\n\tprotected expandMetaInternal(andFuncalls: boolean): Metaexpr {\n\t\treturn this;\n\t}\n\n\tprotected getEqualsPriority(context: ExecutionContext): EqualsPriority {\n\t\treturn this.expr && (!this.sealed || context.canUse(this))\n\t\t\t? EqualsPriority.FOUR\n\t\t\t: EqualsPriority.ZERO;\n\t}\n\n\tprotected equalsInternal(obj: Metaexpr, context: ExecutionContext): (Fun | Variable)[] | false {\n\t\tif (!this.expr) return false;\n\n\t\tif (!this.sealed || context.canUse(this)) {\n\t\t\tvar tmp = this.expr.equals(obj, context);\n\t\t\tif (!tmp) return tmp;\n\t\t\treturn tmp.push(this), tmp;\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tprotected getProofInternal(\n\t\t\thypnumMap: Map<Metaexpr, number>,\n\t\t\t$Map: Map<Metaexpr, number | [number, number]>,\n\t\t\tctr: Counter): ProofType[] {\n\t\t\n\t\treturn [{\n\t\t\t_type: 'NP',\n\t\t\tctr: ctr.next(),\n\t\t\texpr: this\n\t\t}];\n\t}\n\n\t// pr f\n\tpublic toSimpleString() {\n\t\treturn this.type.toSimpleString() + ' ' + this.name;\n\t}\n\n\tpublic toIndentedString(indent: number, root?: boolean): string {\n\t\treturn `${root ? this.type + ' ' : ''}${this.name}<${this._id}>`;\n\t}\n\n\tpublic toTeXString(prec?: Precedence, root?: boolean): string {\n\t\tvar id = this instanceof Parameter ? `id-${this._id}` : `def-${this.name}`;\n\n\t\tvar tex = this.tex || Node.makeTeXName(this.name);\n\t\t\n\t\tvar expr = root && this.expr\n\t\t\t? `\\\\coloneqq ${this.expr.toTeXString(Node.PREC_COLONEQQ)}`\n\t\t\t: '';\n\t\t\n\t\treturn `\\\\href{#${id}}{${tex}}${expr}`;\n\t}\n}\n\nimport Parameter from './Parameter';","import Counter from \"../Counter\";\nimport ExecutionContext from \"../ExecutionContext\";\nimport { ProofType } from \"../ProofType\";\nimport StackTrace from \"../StackTrace\";\nimport Expr0 from \"./Expr0\";\nimport Fun from \"./Fun\";\nimport Metaexpr, { EqualsPriority } from \"./Metaexpr\";\nimport Nameable from \"./Nameable\";\nimport Node, { Precedence } from \"./Node\";\nimport Variable from \"./Variable\";\n\ninterface $VariableArgumentType {\n\tname: string;\n\texpr: Metaexpr;\n}\n\nexport default class $Variable extends Metaexpr implements Nameable {\n\n\tpublic readonly name: string;\n\tpublic readonly expr: Metaexpr;\n\n\tconstructor ({name, expr}: $VariableArgumentType, trace: StackTrace) {\n\t\tsuper(trace, null, null, expr.type);\n\n\t\tif (!name || !expr) {\n\t\t\tthrow Node.error('Assertion failed', trace);\n\t\t}\n\n\t\tthis.name = name;\n\t\tthis.expr = expr;\n\t}\n\n\tprotected isProvedInternal(hypotheses: Metaexpr[]): boolean {\n\t\treturn this.expr.isProved(hypotheses);\n\t}\n\n\tpublic substitute(map: Map<Variable, Expr0>): Metaexpr {\n\t\treturn this.expr.substitute(map);\n\t}\n\n\tprotected expandMetaInternal(andFuncalls: boolean): Metaexpr {\n\t\treturn this.expr.expandMeta(andFuncalls);\n\t}\n\n\tprotected getEqualsPriority(): EqualsPriority {\n\t\treturn EqualsPriority.FIVE;\n\t}\n\n\tprotected equalsInternal(obj: Metaexpr, context: ExecutionContext): (Fun | Variable)[] | false {\n\t\treturn this.expr.equals(obj, context);\n\t}\n\n\tprotected getProofInternal(\n\t\t\thypnumMap: Map<Metaexpr, number>,\n\t\t\t$Map: Map<Metaexpr, number | [number, number]>,\n\t\t\tctr: Counter): ProofType[] {\n\t\t\n\t\tif (!$Map.has(this)) {\n\t\t\tthrow Error(`${this.name} is not defined`);\n\t\t}\n\n\t\treturn [{\n\t\t\t_type: 'R',\n\t\t\tctr: ctr.next(),\n\t\t\tnum: $Map.get(this),\n\t\t\texpr: this.expr\n\t\t}];\n\t}\n\n\tpublic toIndentedString(indent: number, root?: boolean): string {\n\t\treturn this.name;\n\t}\n\t\n\tpublic toTeXString(prec?: Precedence, root?: boolean): string {\n\t\treturn `\\\\mathtt{${Node.escapeTeX(this.name)}}`;\n\t}\n}","import Fun from \"./Fun\";\n\nexport type SchemaType = 'axiom' | 'theorem' | 'schema';\n\nexport default class Schema extends Fun {\n\n\tpublic readonly schemaType: SchemaType;\n\tpublic readonly using: ObjectFun[];\n\tpublic readonly def$s: $Variable[];\n\tpublic readonly context: ExecutionContext;\n\tprivate isProvedCache: boolean;\n\n\tconstructor ({doc, tex, annotations, schemaType, name, params, context, def$s, expr}: SchemaArgumentType, trace: StackTrace) {\n\t\tif (!expr) {\n\t\t\tthrow Node.error('wut', trace);\n\t\t}\n\n\t\tif (schemaType != 'schema' && !name) {\n\t\t\tthrow Node.error(`wut`, trace);\n\t\t}\n\n\t\tsuper({doc, tex, annotations, sealed: false, rettype: null, name, params, expr}, trace);\n\t\t\n\t\tthis.schemaType = schemaType;\n\t\tthis.def$s = def$s || [];\n\t\tthis.context = context;\n\n\t\tif (schemaType == 'theorem') {\n\t\t\tif (!this.isProved()) {\n\t\t\t\tthrow Node.error(`Schema ${name} is marked as a theorem but it is not proved`, trace);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tpublic isProved(hyps?) {\n\t\tif (this.isProvedCache) return true;\n\n\t\tif (!hyps && typeof this.isProvedCache == 'boolean') {\n\t\t\treturn this.isProvedCache;\n\t\t}\n\n\t\tvar cache = !hyps || !hyps.length;\n\t\thyps = hyps || [];\n\t\t\n\t\tvar ret = this.schemaType == 'axiom' || super.isProved(hyps);\n\t\tif (cache) this.isProvedCache = ret;\n\t\treturn ret;\n\t}\n\n\tpublic substitute(map: Map<Variable, Expr0>): Metaexpr {\n\t\tif (!this.expr) return this;\n\n\t\t//         \n\t\t//     .\n\t\tif (this.name) return this;\n\n\t\t//  this.name       .\n\t\tif (this.params.some(e => map.has(e)))\n\t\t\tthrow Error('Parameter collision');\n\n\t\treturn new Schema({\n\t\t\tdoc: null,\n\t\t\ttex: null,\n\t\t\tannotations: this.annotations,\n\t\t\tschemaType: 'schema',\n\t\t\tname: null,\n\t\t\tparams: this.params,\n\t\t\tcontext: this.context,\n\t\t\tdef$s: this.def$s,\n\t\t\texpr: this.expr.substitute(map)\n\t\t}, this.trace);\n\t}\n\n\tprotected expandMetaInternal(andFuncalls: boolean): Metaexpr {\n\t\tif (!this.expr) return this;\n\t\tif (this.type instanceof ObjectType && this.name) return this;\n\n\t\treturn new Schema({\n\t\t\tdoc: null,\n\t\t\ttex: null,\n\t\t\tannotations: this.annotations,\n\t\t\tschemaType: 'schema',\n\t\t\tname: null,\n\t\t\tparams: this.params,\n\t\t\tcontext: this.context,\n\t\t\tdef$s: this.def$s,\n\t\t\texpr: this.expr.expandMeta(andFuncalls)\n\t\t}, this.trace);\n\t}\n\n\tpublic isCallable(_context: ExecutionContext): boolean {\n\t\treturn true;\n\t}\n\n\tpublic toIndentedString(indent: number, root?: boolean): string {\n\t\treturn [\n\t\t\t` ${this.name || ''}(${this.params.map(p => p.toIndentedString(indent)).join(', ')}) => {`,\n\t\t\t'\\t' + this.expr.expandMeta(true).toIndentedString(indent + 1),\n\t\t\t'}'\n\t\t].join('\\n' + '\\t'.repeat(indent));\n\t}\n\t\n\tpublic toTeXString(prec?: Precedence, root?: boolean): string {\n\t\tif (!this.name) {\n\t\t\tthis.precedence = Node.PREC_FUNEXPR;\n\t\t\treturn [\n\t\t\t\t(this.shouldConsolidate(prec) ? '\\\\left(' : ''),\n\n\t\t\t\t(\n\t\t\t\t\tthis.params.length == 1\n\t\t\t\t\t? this.params[0].toTeXString(false)\n\t\t\t\t\t: `\\\\left(${this.params.map(e => e.toTeXString(Node.PREC_COMMA)).join(', ')}\\\\right)`\n\t\t\t\t),\n\t\t\t\t'\\\\mapsto ',\n\t\t\t\tthis.expr.expandMeta(true).toTeXString(false),\n\n\t\t\t\t(this.shouldConsolidate(prec) ? '\\\\right)' : '')\n\t\t\t].join('');\n\t\t}\n\t\t\n\t\tvar id = 'def-' + this.name,\n\t\t\tproved = this.isProved() ? 'p' : 'np';\n\t\n\t\tif (!root)\n\t\t\treturn `\\\\href{#${id}}{\\\\htmlData{proved=${proved}}{\\\\mathsf{${Node.escapeTeX(this.name)}}}}`;\n\t\n\t\treturn `\\\\href{#${id}}{\\\\htmlData{proved=${proved}}{\\\\mathsf{${Node.escapeTeX(this.name)}}}}\\\\mathord{\\\\left(${this.params.map(e => e.toTeXStringWithId(Node.PREC_COMMA) + (e.selector ? `: \\\\texttt{@${e.selector}}` : '')).join(', ')}\\\\right)}:\\\\\\\\\\\\quad`\n\t\t\t\t+ this.expr.expandMeta(true).toTeXString(true);\n\t}\n}\n\nimport $Variable from \"./$Variable\";\nimport Expr0 from \"./Expr0\";\nimport Metaexpr from \"./Metaexpr\";\nimport Node, { Precedence } from \"./Node\";\nimport ObjectType from \"./ObjectType\";\nimport Variable from \"./Variable\";\nimport ObjectFun from \"./ObjectFun\";\nimport StackTrace from \"../StackTrace\";\nimport ExecutionContext from \"../ExecutionContext\";\nimport Parameter from \"./Parameter\";\n\ninterface SchemaArgumentType {\n\tdoc: string;\n\ttex: string;\n\tannotations: string[];\n\tschemaType: SchemaType;\n\tname: string;\n\tparams: Parameter[];\n\tcontext: ExecutionContext;\n\tdef$s: $Variable[];\n\texpr: Metaexpr;\n}","import Counter from '../Counter';\nimport ExecutionContext from '../ExecutionContext';\nimport { ProofType } from '../ProofType';\nimport StackTrace from '../StackTrace';\nimport $Variable from './$Variable';\nimport Expr0 from './Expr0';\nimport Fun from './Fun';\nimport Metaexpr, { EqualsPriority } from './Metaexpr';\nimport MetaType from './MetaType';\nimport { isNameable } from './Nameable';\nimport Node, { Precedence } from './Node';\nimport ObjectFun from './ObjectFun';\nimport ObjectType from './ObjectType';\nimport Schema from './Schema';\nimport Variable from './Variable';\n\ninterface FuncallArgumentType {\n\tfun: Metaexpr;\n\targs: Expr0[];\n}\n\nexport default class Funcall extends Expr0 {\n\t\n\tpublic readonly fun: Metaexpr;\n\tpublic readonly args: Expr0[];\n\n\tconstructor ({fun, args}: FuncallArgumentType, trace: StackTrace) {\n\t\tif (fun.type.isSimple) {\n\t\t\tvar name = isNameable(fun) ? fun.name : '<anonymous>';\n\t\t\tthrow Node.error(`${name} is not callable`, trace);\n\t\t}\n\n\t\tif (!(args instanceof Array) || args.map(e => e instanceof Node).some(e => !e))\n\t\t\tthrow Node.error('Assertion failed', trace);\n\t\t\t \n\t\tvar resolvedType = fun.type.resolve() as ObjectType | MetaType,\n\t\t\tparamTypes = resolvedType.from,\n\t\t\targTypes = args.map(e => e.type);\n\n\t\tif (paramTypes.length != argTypes.length)\n\t\t\tthrow Node.error(`Invalid number of arguments (expected ${paramTypes.length}): ${argTypes.length}`, trace);\n\n\t\tfor (var i = 0; i < paramTypes.length; i++) {\n\t\t\tif (!paramTypes[i].equals(argTypes[i])) {\n\t\t\t\tthrow Node.error(`Argument #${i + 1} has illegal argument type (expected ${paramTypes[i]}): ${argTypes[i]}`, trace);\n\t\t\t}\n\t\t}\n\n\t\tsuper(trace, null, null, resolvedType.to);\n\t\t\n\t\tthis.fun = fun;\n\t\tthis.args = args;\n\t}\n\n\tprotected isProvedInternal(hypotheses: Metaexpr[]): boolean {\n\t\treturn this.fun.isProved(hypotheses);\n\t}\n\n\tpublic substitute(map: Map<Variable, Expr0>): Metaexpr {\n\t\treturn new Funcall({\n\t\t\tfun: this.fun.substitute(map),\n\t\t\targs: this.args.map(arg => arg.substitute(map))\n\t\t}, this.trace);\n\t}\n\n\tprotected expandMetaInternal(andFuncalls: boolean): Metaexpr {\n\t\tvar fun = this.fun.expandMeta(andFuncalls),\n\t\t\targs = this.args.map(arg => arg.expandMeta(andFuncalls));\n\t\t\n\t\tif (!(fun instanceof Fun) || !fun.expr || fun.name && !(fun instanceof Schema))\n\t\t\treturn new Funcall({fun, args}, this.trace);\n\n\t\treturn fun.call(args).expandMeta(andFuncalls);\n\t}\n\n\tpublic isExpandable(context: ExecutionContext): boolean {\n\t\tvar callee: Metaexpr = this.fun;\n\n\t\twhile (callee instanceof $Variable) {\n\t\t\tcallee = callee.expr;\n\t\t}\n\n\t\tif (callee instanceof Variable && callee.expr) {\n\t\t\treturn true;\n\t\t}\n\n\t\tif (callee instanceof Funcall) {\n\t\t\treturn callee.isExpandable(context);\n\t\t}\n\n\t\tif (!(callee instanceof Fun)) return false;\n\n\t\treturn callee.isCallable(context);\n\t}\n\t\n\tpublic expandOnce(context: ExecutionContext): {expanded: Metaexpr, used: (Fun | Variable)[]} {\n\t\tif (!this.isExpandable(context)) {\n\t\t\tthrow Error('Cannot expand');\n\t\t}\n\n\t\tvar used: (Fun | Variable)[] = [];\n\n\t\tvar callee: Metaexpr = this.fun;\n\n\t\twhile (callee instanceof $Variable) {\n\t\t\tcallee = callee.expr;\n\t\t}\n\n\t\tif (callee instanceof Variable && callee.expr) {\n\t\t\tused.push(callee);\n\n\t\t\treturn {\n\t\t\t\texpanded: new Funcall({\n\t\t\t\t\tfun: callee.expr,\n\t\t\t\t\targs: this.args\n\t\t\t\t}, this.trace),\n\t\t\t\tused\n\t\t\t};\n\t\t}\n\n\t\tif (callee instanceof Funcall) {\n\t\t\tvar calleeExpanded = callee.expandOnce(context);\n\t\t\tused.push(...calleeExpanded.used);\n\t\t\treturn {\n\t\t\t\texpanded: new Funcall({\n\t\t\t\t\tfun: calleeExpanded.expanded,\n\t\t\t\t\targs: this.args\n\t\t\t\t}, this.trace),\n\t\t\t\tused\n\t\t\t};\n\t\t}\n\n\t\tif (!(callee instanceof Fun)) {\n\t\t\tthrow Error('Something\\'s wrong');\n\t\t}\n\n\t\tif (callee.name) used.push(callee);\n\n\t\treturn {\n\t\t\texpanded: callee.call(this.args),\n\t\t\tused\n\t\t};\n\t}\n\n\tprotected getEqualsPriority(): EqualsPriority {\n\t\treturn EqualsPriority.THREE;\n\t}\n\n\tprotected equalsInternal(obj: Metaexpr, context: ExecutionContext): (Fun | Variable)[] | false {\n\t\tif (!(obj instanceof Funcall)) {\n\t\t\tif (!this.isExpandable(context)) return false;\n\t\t\t\n\t\t\tvar {expanded, used} = this.expandOnce(context);\n\t\t\tvar ret = expanded.equals(obj, context);\n\t\t\treturn ret && ret.concat(used);\n\t\t}\n\n\t\tvar usedMacrosList: (Fun | Variable)[] = [],\n\t\t\tT = (q: (Fun | Variable)[] | false) => { if (q) usedMacrosList.push(...q); return q; };\n\n\t\tif (this.fun == obj.fun || T(this.fun.equals(obj.fun, context))) {\n\t\t\tfor (var i = 0; i < this.args.length; i++) {\n\t\t\t\tif (!T(this.args[i].equals(obj.args[i], context))) return false;\n\t\t\t}\n\n\t\t\treturn usedMacrosList;\n\t\t}\n\n\t\tif (this.fun instanceof Funcall && this.fun.isExpandable(context)) {\n\t\t\tvar {expanded, used} = this.expandOnce(context);\n\t\t\tvar ret = expanded.equals(obj, context);\n\t\t\treturn ret && ret.concat(used);\n\t\t}\n\n\t\tif (obj.fun instanceof Funcall && obj.fun.isExpandable(context)) {\n\t\t\tvar {expanded, used} = obj.expandOnce(context);\n\t\t\tvar ret = this.equals(expanded, context);\n\t\t\treturn ret && ret.concat(used);\n\t\t}\n\n\t\tvar thisIsExpandable = this.isExpandable(context),\n\t\t\tobjIsExpandable = obj.isExpandable(context);\n\t\t\n\t\tif (this.fun == obj.fun || !thisIsExpandable && !objIsExpandable) {\n\t\t\tif (this.fun != obj.fun) return false;\n\n\t\t\tif (!thisIsExpandable && !objIsExpandable) {\n\t\t\t\tfor (var i = 0; i < this.args.length; i++) {\n\t\t\t\t\tif (!T(this.args[i].equals(obj.args[i], context))) return false;\n\t\t\t\t}\n\n\t\t\t\treturn usedMacrosList;\n\t\t\t}\n\n\t\t\tif (this.args.every((_, i) => {\n\t\t\t\treturn T(this.args[i].equals(obj.args[i], context));\n\t\t\t})) {\n\t\t\t\treturn usedMacrosList;\n\t\t\t}\n\t\t}\n\n\t\tif (thisIsExpandable) {\n\t\t\tvar {expanded, used} = this.expandOnce(context);\n\t\t\tvar ret = expanded.equals(obj, context);\n\t\t\treturn ret && ret.concat(used);\n\t\t}\n\n\t\tvar {expanded, used} = obj.expandOnce(context);\n\t\tvar ret = this.equals(expanded, context);\n\t\treturn ret && ret.concat(used);\n\t}\n\n\tprotected getProofInternal(\n\t\t\thypnumMap: Map<Metaexpr, number>,\n\t\t\t$Map: Map<Metaexpr, number | [number, number]>,\n\t\t\tctr: Counter): ProofType[] {\n\n\t\tif (hypnumMap.has(this.fun)) {\n\t\t\treturn [{\n\t\t\t\t_type: 'RC',\n\t\t\t\tctr: ctr.next(),\n\t\t\t\tschema: hypnumMap.get(this.fun),\n\t\t\t\targs: this.args,\n\t\t\t\texpr: this\n\t\t\t}];\n\t\t}\n\n\t\tif ($Map.has(this.fun)) {\n\t\t\treturn [{\n\t\t\t\t_type: 'RC',\n\t\t\t\tctr: ctr.next(),\n\t\t\t\tschema: $Map.get(this.fun),\n\t\t\t\targs: this.args,\n\t\t\t\texpr: this\n\t\t\t}];\n\t\t}\n\n\t\tif (this.fun instanceof Schema && this.fun.name) {\n\t\t\treturn [{\n\t\t\t\t_type: 'RCX',\n\t\t\t\tctr: ctr.next(),\n\t\t\t\texpr: this\n\t\t\t}];\n\t\t}\n\n\t\tif (!(this.fun instanceof Schema)) {\n\t\t\treturn [{\n\t\t\t\t_type: 'NP',\n\t\t\t\tctr: ctr.next(),\n\t\t\t\texpr: this\n\t\t\t}];\n\t\t}\n\n\t\tvar schemalines = this.fun.getProof(hypnumMap, $Map, ctr);\n\n\t\treturn [\n\t\t\t...schemalines,\n\t\t\t{\n\t\t\t\t_type: 'RC',\n\t\t\t\tctr: ctr.next(),\n\t\t\t\tschema: schemalines[schemalines.length - 1].ctr,\n\t\t\t\targs: this.args,\n\t\t\t\texpr: this\n\t\t\t}\n\t\t];\n\t}\n\n\tpublic toIndentedString(indent: number, root?: boolean): string {\n\t\tvar args: any = this.args.map(arg => {\n\t\t\tif (arg instanceof Variable) return `${arg.name}<${arg._id}>`;\n\t\t\treturn arg.toIndentedString(indent + 1);\n\t\t});\n\t\n\t\tif (args.join('').length <= 50) {\n\t\t\targs = this.args.map(arg => {\n\t\t\t\tif (arg instanceof Variable) return `${arg.name}<${arg._id}>`;\n\t\t\t\treturn arg.toIndentedString(indent);\n\t\t\t});\n\t\n\t\t\targs = args.join(', ');\n\t\t\t\n\t\t\tif (this.fun instanceof Schema) {\n\t\t\t\treturn `${this.fun.name || `(${this.fun})`}(${args})`;\n\t\t\t} else {\n\t\t\t\treturn [\n\t\t\t\t\t!(this.fun instanceof Fun) || !this.fun.name\n\t\t\t\t\t\t? '(' + this.fun.toIndentedString(indent) + ')'\n\t\t\t\t\t\t: this.fun.name,\n\t\t\t\t\t`(${args})`\n\t\t\t\t].join('');\n\t\t\t}\n\t\t} else {\n\t\t\targs = args.join(',\\n' + '\\t'.repeat(indent + 1));\n\t\t\t\n\t\t\tif (this.fun instanceof Schema) {\n\t\t\t\treturn [\n\t\t\t\t\tthis.fun.name || `(${this.fun.toIndentedString(indent)})`,\n\t\t\t\t\t'(',\n\t\t\t\t\t'\\t' + args,\n\t\t\t\t\t')'\n\t\t\t\t].join('\\n' + '\\t'.repeat(indent));\n\t\t\t} else {\n\t\t\t\treturn [\n\t\t\t\t\t(\n\t\t\t\t\t\t!(this.fun instanceof Fun) || !('name' in this.fun && this.fun.name)\n\t\t\t\t\t\t\t? '(' + this.fun.toIndentedString(indent) + ')'\n\t\t\t\t\t\t\t: this.fun.name\n\t\t\t\t\t) + '(',\n\t\t\t\t\t'\\t' + args,\n\t\t\t\t\t')'\n\t\t\t\t].join('\\n' + '\\t'.repeat(indent));\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic toTeXString(prec?: Precedence, root?: boolean): string {\n\t\tif (this.fun instanceof Schema) {\n\t\t\treturn (\n\t\t\t\tthis.fun.name\n\t\t\t\t\t? `\\\\href{#def-${this.fun.name}}{\\\\htmlData{proved=${this.fun.isProved() ? 'p' : 'np'}}{\\\\textsf{${Node.escapeTeX(this.fun.name)}}}}`\n\t\t\t\t\t: this.fun.toTeXString(false)\n\t\t\t) + `\\\\mathord{\\\\left(${this.args.map(arg => {\n\t\t\t\treturn arg.toTeXString(Node.PREC_COMMA);\n\t\t\t}).join(', ')}\\\\right)}`;\n\t\t}\n\n\t\tif (this.fun instanceof ObjectFun)\n\t\t\treturn this.fun.funcallToTeXString(this.args, prec);\n\t\t\n\t\tvar args = this.args.map(arg => {\n\t\t\treturn arg.toTeXString(Node.PREC_COMMA);\n\t\t});\n\n\t\treturn (\n\t\t\t!(isNameable(this.fun) && this.fun.name) || this.fun instanceof Variable\n\t\t\t\t? this.fun.toTeXString(false)\n\t\t\t\t: Node.makeTeXName(this.fun.name)\n\t\t) + `\\\\mathord{\\\\left(${args.join(', ')}\\\\right)}`;\n\t}\n}","import Metaexpr from \"./Metaexpr\";\n\nexport default abstract class Expr0 extends Metaexpr {\n\t\n}","import Node, { Precedence } from './Node';\nimport ObjectType from './ObjectType';\nimport Type from './Type';\n\ninterface SimpleMetaTypeArgumentType {\n\tfunctional: false;\n\tleft: Type[];\n\tright: Type;\n}\n\ninterface FunctionalMetaTypeArgumentType {\n\tfunctional: true;\n\tfrom: ObjectType[];\n\tto: MetaType;\n}\n\ntype MetaTypeArgumentType = SimpleMetaTypeArgumentType | FunctionalMetaTypeArgumentType;\n\nexport default class MetaType extends Type {\n\t\n\tpublic readonly left: Type[];\n\tpublic readonly right: Type;\n\tpublic readonly from: ObjectType[];\n\tpublic readonly to: MetaType;\n\n\tconstructor (o: MetaTypeArgumentType) {\n\t\tsuper(null, null, null, o.functional);\n\n\t\tif (typeof o.functional != 'boolean')\n\t\t\tthrow Node.error('typeof o.functional != \\'boolean\\'', null);\n\n\t\tif (o.functional == false) {\n\t\t\tif (!(o.left instanceof Array))\n\t\t\t\tthrow Node.error('left should be an array', null);\n\n\t\t\tthis.left = o.left;\n\t\t\tthis.right = o.right;\n\t\t} else {\n\t\t\tif (o.from.some(f => !(f instanceof ObjectType)))\n\t\t\t\tthrow Node.error('o.from.some(f => !(f instanceof ObjectType))', null);\n\t\t\tif (!(o.to instanceof MetaType))\n\t\t\t\tthrow Node.error('!(o.to instanceof MetaType)', null);\n\n\t\t\tif (o.to.isFunctional)\n\t\t\t\tthrow Node.error('Functional metatype in functional metatype is not supported', null);\n\n\t\t\tthis.from = o.from;\n\t\t\tthis.to = o.to;\n\t\t}\n\t}\n\n\tpublic resolve(): MetaType {\n\t\treturn this;\n\t}\n\n\tpublic toIndentedString(indent: number) {\n\t\tif (this.isSimple) return `[${this.left.join(', ')} |- ${this.right}]`;\n\n\t\treturn `[${this.from.join(', ')} -> ${this.to}]`;\n\t}\n\n\tpublic toTeXString(prec?: Precedence, root?: boolean): string {\n\t\tthrow new Error('Method not implemented.');\n\t}\n\n\tpublic equals(t: Type): boolean {\n\t\tif (!(t instanceof MetaType)) return false;\n\n\t\tif (this.isSimple != t.isSimple) return false;\n\n\t\tif (this.isSimple) {\n\t\t\tif (this.left.length != t.left.length) return false;\n\n\t\t\tfor (let i = 0; i < this.left.length; i++) {\n\t\t\t\tif (!this.left[i].equals(t.left[i])) return false;\n\t\t\t}\n\n\t\t\tif (!this.right.equals(t.right)) return false;\n\n\t\t\treturn true;\n\t\t}\n\n\t\tif (this.from.length != t.from.length) return false;\n\n\t\tfor (let i = 0; i < this.from.length; i++)\n\t\t\tif (!this.from[i].equals(t.from[i])) return false;\n\n\t\treturn this.to.equals(t.to);\n\t}\n}","import StackTrace from \"../StackTrace\";\nimport { Precedence } from \"./Node\";\nimport ObjectType from \"./ObjectType\";\nimport Variable from \"./Variable\";\n\ninterface ParameterArgumentType {\n\tdoc?: string;\n\ttex?: string;\n\ttype: ObjectType;\n\tname: string;\n\tselector: string;\n}\n\nexport default class Parameter extends Variable {\n\n\tpublic readonly selector: string;\n\n\tconstructor ({doc, tex, type, name, selector}: ParameterArgumentType, trace: StackTrace) {\n\t\tsuper({doc, tex, sealed: false, type, name, expr: null}, trace);\n\n\t\tthis.selector = selector;\n\t}\n\n\tpublic toTeXStringWithId(prec?: Precedence, root?: boolean): string {\n\t\tvar id =`id-${this._id}`;\n\n\t\treturn [\n\t\t\t`\\\\htmlId{${id}}{`,\n\t\t\tthis.toTeXString(prec, root),\n\t\t\t`}`\n\t\t].join('');\n\t}\n}","import ExecutionContext from \"../ExecutionContext\";\nimport StackTrace from \"../StackTrace\";\nimport Expr0 from \"./Expr0\";\nimport Fun from \"./Fun\";\nimport Metaexpr from \"./Metaexpr\";\nimport Node, { Precedence } from \"./Node\";\nimport ObjectType from \"./ObjectType\";\nimport Parameter from \"./Parameter\";\nimport Type from \"./Type\";\nimport Variable from \"./Variable\";\n\ninterface ObjectFunArgumentType {\n\tdoc: string;\n\ttex: string;\n\tannotations: string[];\n\tsealed: boolean;\n\trettype: Type;\n\tname: string;\n\tparams: Parameter[];\n\texpr: Expr0;\n}\n\nexport default class ObjectFun extends Fun {\n\t\n\tconstructor ({doc, tex, annotations, sealed, rettype, name, params, expr}: ObjectFunArgumentType, trace: StackTrace) {\n\t\tsuper({doc, tex, annotations, sealed, rettype, name, params, expr}, trace);\n\t}\n\n\tpublic substitute(map: Map<Variable, Expr0>): Metaexpr {\n\t\tif (!this.expr) return this;\n\n\t\t//         \n\t\t//     .\n\t\tif (this.name) return this;\n\n\t\t//  this.name       .\n\t\tif (this.params.some(e => map.has(e)))\n\t\t\tthrow Error('Parameter collision');\n\n\t\treturn new ObjectFun({\n\t\t\tdoc: null,\n\t\t\ttex: null,\n\t\t\tannotations: this.annotations,\n\t\t\tsealed: this.sealed,\n\t\t\trettype: null,\n\t\t\tname: null,\n\t\t\tparams: this.params,\n\t\t\texpr: this.expr.substitute(map)\n\t\t}, this.trace);\n\t}\n\n\tprotected expandMetaInternal(andFuncalls: boolean): Metaexpr {\n\t\tif (!this.expr) return this;\n\t\tif (this.type instanceof ObjectType && this.name) return this;\n\n\t\treturn new ObjectFun({\n\t\t\tdoc: null,\n\t\t\ttex: null,\n\t\t\tannotations: this.annotations,\n\t\t\tsealed: this.sealed,\n\t\t\trettype: null,\n\t\t\tname: null,\n\t\t\tparams: this.params,\n\t\t\texpr: this.expr.expandMeta(andFuncalls)\n\t\t}, this.trace);\n\t}\n\n\tpublic isCallable(context: ExecutionContext): boolean {\n\t\treturn this.expr && (!this.sealed || context.canUse(this));\n\t}\n\n\tpublic toIndentedString(indent: number, root?: boolean): string {\n\t\tif (this.name) return this.name;\n\t\t\n\t\treturn [\n\t\t\t` ${this.name || ''}(${this.params.map(p => p.toIndentedString(indent)).join(', ')}) => {`,\n\t\t\t'\\t' + this.expr.toIndentedString(indent + 1),\n\t\t\t'}'\n\t\t].join('\\n' + '\\t'.repeat(indent));\n\t}\n\n\tpublic toTeXString(prec?: Precedence, root?: boolean): string {\n\t\tif (!this.name) {\n\t\t\tthis.precedence = Node.PREC_FUNEXPR;\n\t\t\treturn [\n\t\t\t\t(this.shouldConsolidate(prec) ? '\\\\left(' : ''),\n\n\t\t\t\t(\n\t\t\t\t\tthis.params.length == 1\n\t\t\t\t\t? this.params[0].toTeXString(false)\n\t\t\t\t\t: `\\\\left(${this.params.map(e => e.toTeXString(Node.PREC_COMMA)).join(', ')}\\\\right)`\n\t\t\t\t),\n\t\t\t\t'\\\\mapsto ',\n\t\t\t\tthis.expr.expandMeta(true).toTeXString(false),\n\n\t\t\t\t(this.shouldConsolidate(prec) ? '\\\\right)' : '')\n\t\t\t].join('');\n\t\t}\n\n\t\tif (!root)\n\t\t\treturn `\\\\href{#def-${this.name}}{${Node.makeTeXName(this.name)}}`;\n\t\n\t\tif (!this.expr)\n\t\t\treturn this.funcallToTeXString(this.params, prec);\n\t\n\t\treturn this.funcallToTeXString(this.params, Node.PREC_COLONEQQ)\n\t\t\t\t+ `\\\\coloneqq ${this.expr.toTeXString(Node.PREC_COLONEQQ)}`;\n\t}\n\n\tpublic funcallToTeXString(args, prec) {\n\t\targs = args.map(arg => {\n\t\t\treturn arg.toTeXString(this.tex ? this.precedence : Node.PREC_COMMA);\n\t\t});\n\t\n\t\tif (this.tex) {\n\t\t\treturn this.makeTeX('def-' + this.name, args, prec);\n\t\t}\n\t\n\t\treturn (\n\t\t\t!this.name\n\t\t\t\t? this.toTeXString(false)\n\t\t\t\t: `\\\\href{#def-${this.name}}{${Node.makeTeXName(this.name)}}`\n\t\t) + `\\\\mathord{\\\\left(${args.join(', ')}\\\\right)}`;\n\t}\n}","import StackTrace from \"../StackTrace\";\nimport Node from \"./Node\";\n\nexport default abstract class Type extends Node {\n\tpublic readonly isFunctional: boolean;\n\tpublic readonly isSimple: boolean;\n\t\n\tpublic abstract equals(t: Type): boolean;\n\n\tconstructor (trace: StackTrace, doc: string, tex: string, isFunctional: boolean) {\n\t\tsuper(trace, doc, tex);\n\t\tthis.isFunctional = isFunctional;\n\t\tthis.isSimple = !isFunctional;\n\t}\n\n\tpublic abstract resolve(): Type;\n}","export default interface Nameable {\n\tname: string;\n}\n\nexport function isNameable(obj: object): obj is Nameable {\n\treturn 'name' in obj;\n}","import Counter from '../Counter';\nimport ExecutionContext from '../ExecutionContext';\nimport { ProofType } from '../ProofType';\nimport StackTrace from '../StackTrace';\nimport $Variable from './$Variable';\nimport Expr0 from './Expr0';\nimport Fun from './Fun';\nimport Metaexpr, { EqualsPriority } from './Metaexpr';\nimport MetaType from './MetaType';\nimport Node, { Precedence } from './Node';\nimport ObjectType from './ObjectType';\nimport Variable from './Variable';\n\ninterface TeeArgumentType {\n\tleft: Metaexpr[];\n\tdef$s: $Variable[];\n\tright: Metaexpr;\n}\n\nexport default class Tee extends Metaexpr {\n\n\tpublic readonly left: Metaexpr[];\n\tpublic readonly def$s: $Variable[];\n\tpublic readonly right: Metaexpr;\n\n\tconstructor ({left, def$s, right}: TeeArgumentType, trace: StackTrace) {\n\t\tif (!(left instanceof Array\n\t\t\t\t&& left.every(l => {\n\t\t\t\t\treturn l.type instanceof ObjectType\n\t\t\t\t\t\t|| l.type instanceof MetaType;\n\t\t\t\t}))) {\n\t\t\tconsole.log(left);\n\t\t\tthrow Node.error('Assertion failed', trace);\n\t\t}\n\n\t\tif (def$s && !(def$s instanceof Array && def$s.every($ => $ instanceof $Variable)))\n\t\t\tthrow Node.error('Assertion failed', trace);\n\n\t\tif (!(right.type instanceof ObjectType || right.type instanceof MetaType)) {\n\t\t\tconsole.log(right);\n\t\t\tthrow Node.error('Assertion failed', trace);\n\t\t}\n\n\t\tif (right.type.isFunctional) {\n\t\t\tthrow Node.error('RHS of a rule cannot be a schema', trace);\n\t\t}\n\n\t\tsuper(trace, null, null, new MetaType({\n\t\t\tfunctional: false,\n\t\t\tleft: left.map(e => e.type),\n\t\t\tright: right.type\n\t\t}));\n\n\t\tthis.left = left;\n\t\tthis.def$s = def$s || [];\n\t\tthis.right = right;\n\t\tthis.precedence = Node.PREC_COMMA;\n\t}\n\n\tprotected isProvedInternal(hypotheses: Metaexpr[]): boolean {\n\t\treturn this.right.isProved(hypotheses.concat(this.left));\n\t}\n\n\tpublic substitute(map: Map<Variable, Expr0>): Metaexpr {\n\t\tvar left = this.left.map(e => e.substitute(map));\n\t\tvar right = this.right.substitute(map);\n\n\t\treturn new Tee({\n\t\t\tleft,\n\t\t\tdef$s: null,\n\t\t\tright\n\t\t}, this.trace);\n\t}\n\n\tprotected expandMetaInternal(andFuncalls: boolean): Metaexpr {\n\t\tvar left = this.left.map(lef => lef.expandMeta(andFuncalls));\n\t\tvar right = this.right.expandMeta(andFuncalls);\n\n\t\treturn new Tee({left, def$s: null, right}, this.trace);\n\t}\n\n\tprotected getEqualsPriority(): EqualsPriority {\n\t\treturn EqualsPriority.TWO;\n\t}\n\n\tprotected equalsInternal(obj: Metaexpr, context: ExecutionContext): (Fun | Variable)[] | false {\n\t\tif (!(obj instanceof Tee)) {\n\t\t\tthrow Error('Assertion failed');\n\t\t}\n\n\t\tif (this.left.length != obj.left.length) {\n\t\t\tthrow Error('Assertion failed');\n\t\t}\n\n\t\tfor (var i = 0; i < this.left.length; i++) {\n\t\t\tif (!this.left[i].equals(obj.left[i], context)) return false;\n\t\t}\n\n\t\treturn this.right.equals(obj.right, context);\n\t}\n\n\tprotected getProofInternal(\n\t\t\thypnumMap: Map<Metaexpr, number>,\n\t\t\t$Map: Map<Metaexpr, number | [number, number]>,\n\t\t\tctr: Counter): ProofType[] {\n\t\t\n\t\thypnumMap = new Map(hypnumMap);\n\n\t\tvar start = ctr.peek() + 1;\n\n\t\tvar leftlines: ProofType[] = this.left.map(l => {\n\t\t\thypnumMap.set(l, ctr.next());\n\t\t\t\n\t\t\treturn {\n\t\t\t\t_type: 'H',\n\t\t\t\tctr: ctr.peek(),\n\t\t\t\texpr: l\n\t\t\t};\n\t\t});\n\n\t\t$Map = new Map($Map);\n\n\t\tvar $lines = this.def$s.map($ => {\n\t\t\tvar lines = $.expr.getProof(hypnumMap, $Map, ctr);\n\t\t\tvar $num = lines[lines.length - 1].ctr;\n\t\t\t$Map.set($, $num);\n\t\t\treturn lines;\n\t\t}).flat(1);\n\n\t\treturn [{\n\t\t\t_type: 'T',\n\t\t\tleftlines: leftlines as any,\n\t\t\trightlines: $lines.concat(this.right.getProof(hypnumMap, $Map, ctr)),\n\t\t\tctr: [start, ctr.peek()]\n\t\t}];\n\t}\n\n\tpublic toIndentedString(indent: number, root?: boolean): string {\n\t\tif (!this.left.length) {\n\t\t\treturn '|- ' + this.right.toIndentedString(indent);\n\t\t}\n\t\n\t\treturn [\n\t\t\t'\\t' + this.left.map(e => e.toIndentedString(indent + 1)).join(',\\n' + '\\t'.repeat(indent + 1)),\n\t\t\t'|-',\n\t\t\t'\\t' + this.right.toIndentedString(indent + 1)\n\t\t].join('\\n' + '\\t'.repeat(indent));\n\t}\n\t\n\tpublic toTeXString(prec?: Precedence, root?: boolean): string {\n\t\tvar expanded = this.expandMeta(true) as Tee;\n\n\t\treturn [\n\t\t\t(this.shouldConsolidate(prec) ? '\\\\left(' : ''),\n\t\t\t`{${expanded.left.map(e => e.toTeXString(Node.PREC_COMMA)).join(', ')} \\\\vdash ${expanded.right.toTeXString(Node.PREC_COMMA)}}`,\n\t\t\t(this.shouldConsolidate(prec) ? '\\\\right)' : '')\n\t\t].join('');\n\t}\n}","var grammar;\n\nif (process.env.__webpack__) {\n\tgrammar = require('raw-loader!./grammar.pegjs').default;\n} else {\n\tvar fs = require('fs');\n\tvar path = require('path');\n\n\tgrammar = fs.readFileSync(path.join(__dirname, 'grammar.pegjs'), 'utf-8');\n}\n\nvar Program = require('./Program').default;\n\nmodule.exports = {grammar, Program};","export default \"start =\\n\\t_\\n\\timports:(i:import _ {return i})*\\n\\tlines:(a:line _ {return a})*\\n\\t{return imports.concat(lines)}\\n\\nline =\\n\\ttypedef\\n\\t/ defv\\n\\t/ defun\\n\\t/ defschema\\n\\nevaluable =\\n\\t_ e:evaluable_internal _ {return e}\\n\\nevaluable_internal =\\n\\ttypedef\\n\\t/ defv\\n\\t/ defun\\n\\t/ defschema\\n\\t/ metaexpr\\n\\nimport =\\n\\t'import' __\\n\\tfilename:ident _\\n\\tsem\\n\\t{\\n\\t\\treturn {\\n\\t\\t\\t_type: 'import',\\n\\t\\t\\tfilename,\\n\\t\\t\\tlocation: location()\\n\\t\\t}\\n\\t}\\n\\ntypedef =\\n\\tdoc:(documentation __)?\\n\\tbase:(\\\"base\\\" __)?\\n\\t\\\"type\\\" __\\n\\torigin:(o:ftype __ {return o})?\\n\\tname:ident _ sem\\n\\t{\\n\\t\\treturn {\\n\\t\\t\\t_type: 'typedef',\\n\\t\\t\\tdoc: doc ? doc[0] : null,\\n\\t\\t\\tbase: !!base,\\n\\t\\t\\torigin,\\n\\t\\t\\tname,\\n\\t\\t\\tlocation: location()\\n\\t\\t}\\n\\t}\\n\\ndefv =\\n\\tdoc:(documentation __)?\\n\\ttex:(tex __)?\\n\\tsealed:('sealed' __)?\\n\\ttype:type __\\n\\tname:ident _\\n\\texpr:(\\n\\t\\t\\\"=\\\" _\\n\\t\\texpr:expr0 _\\n\\t\\tsem\\n\\t\\t{return expr}\\n\\t\\t/ sem {return null}\\n\\t)\\n\\t{\\n\\t\\treturn {\\n\\t\\t\\t_type: 'defv',\\n\\t\\t\\tisParam: false,\\n\\t\\t\\tdoc: doc ? doc[0] : null,\\n\\t\\t\\ttex: tex ? tex[0] : null,\\n\\t\\t\\tsealed: !!sealed,\\n\\t\\t\\ttype,\\n\\t\\t\\tname,\\n\\t\\t\\texpr,\\n\\t\\t\\tlocation: location()\\n\\t\\t}\\n\\t}\\n\\ndefparam =\\n\\ttex:(tex __)? type:type __ name:ident\\n\\t{\\n\\t\\treturn {\\n\\t\\t\\t_type: 'defv',\\n\\t\\t\\tisParam: true,\\n\\t\\t\\tdoc: null,\\n\\t\\t\\ttex: tex ? tex[0] : null,\\n\\t\\t\\ttype,\\n\\t\\t\\tname,\\n\\t\\t\\tlocation: location()\\n\\t\\t}\\n\\t}\\n\\ndefschemaparam =\\n\\ttex:(tex __)? type:type __ name:ident\\n\\tselector:(_ ':' _ '@' g:$[a-z0-9_]+ {return g})?\\n\\t{\\n\\t\\treturn {\\n\\t\\t\\t_type: 'defv',\\n\\t\\t\\tisParam: true,\\n\\t\\t\\tdoc: null,\\n\\t\\t\\ttex: tex ? tex[0] : null,\\n\\t\\t\\ttype,\\n\\t\\t\\tname,\\n\\t\\t\\tselector,\\n\\t\\t\\tlocation: location()\\n\\t\\t}\\n\\t}\\n \\ndefun =\\n\\tdoc:(documentation __)?\\n\\ttex:(tex __)?\\n\\tsealed:('sealed' __)?\\n\\trettype:type __\\n\\tname:ident _\\n\\tparams:(\\n\\t\\t\\\"(\\\" _\\n\\t\\tp:(\\n\\t\\t\\thead:defparam _\\n\\t\\t\\ttail:(\\\",\\\" _ tv:defparam _ {return tv})*\\n\\t\\t\\t{return [head].concat(tail)}\\n\\t\\t)?\\n\\t\\t\\\")\\\" _\\n\\t\\t{return p || []}\\n\\t)\\n\\texpr:(\\n\\t\\t\\\"{\\\" _\\n\\t\\texpr:expr0 _\\n\\t\\t\\\"}\\\"\\n\\t\\t{return expr}\\n\\t\\t/ sem {return null}\\n\\t)\\n\\t{\\n\\t\\treturn {\\n\\t\\t\\t_type: 'defun',\\n\\t\\t\\tdoc: doc ? doc[0] : null,\\n\\t\\t\\ttex: tex ? tex[0] : null,\\n\\t\\t\\tsealed: !!sealed,\\n\\t\\t\\trettype,\\n\\t\\t\\tname,\\n\\t\\t\\tparams,\\n\\t\\t\\texpr,\\n\\t\\t\\tlocation: location()\\n\\t\\t}\\n\\t}\\n\\ndefschema =\\n\\tdoc:(documentation __)?\\n\\tannotations: (a:annotation __ {return a})*\\n\\tschemaType:('axiom' / 'theorem' / 'schema') __\\n\\tname:ident _\\n\\tparams:(\\n\\t\\t\\\"(\\\" _\\n\\t\\tp:(\\n\\t\\t\\thead:defschemaparam _\\n\\t\\t\\ttail:(\\\",\\\" _ tv:defschemaparam _ {return tv})*\\n\\t\\t\\t{return [head].concat(tail)}\\n\\t\\t)?\\n\\t\\t\\\")\\\" _\\n\\t\\t{return p || []}\\n\\t)\\n\\tusing:(\\n\\t\\t'using' __\\n\\t\\tx:(\\n\\t\\t\\thead:ident _\\n\\t\\t\\ttail:(',' _ n:ident _ {return n})*\\n\\t\\t\\t{return [head].concat(tail)}\\n\\t\\t)\\n\\t\\t{return x}\\n\\t)?\\n\\t\\\"{\\\" _\\n\\tdefdollars: (d:defdollar _ {return d})* _\\n\\texpr:metaexpr _\\n\\t\\\"}\\\"\\n\\t{\\n\\t\\treturn {\\n\\t\\t\\t_type: 'defschema',\\n\\t\\t\\tdoc: doc ? doc[0] : null,\\n\\t\\t\\tannotations,\\n\\t\\t\\tschemaType,\\n\\t\\t\\tname,\\n\\t\\t\\tparams,\\n\\t\\t\\tusing: using || [],\\n\\t\\t\\tdef$s: defdollars,\\n\\t\\t\\texpr,\\n\\t\\t\\tlocation: location()\\n\\t\\t}\\n\\t}\\n\\n// var[...]\\n// foo(...)[...]\\n// foo[...][...]\\n// (metaexpr)[...]\\n// schema(?, ...)[...]\\nreduction =\\n\\tantecedents:(\\n\\t\\ta:metaexpr_internal_2 {return [a]}\\n\\t\\t/ \\\"[\\\" _\\n\\t\\tb:(\\n\\t\\t\\thead:metaexpr _\\n\\t\\t\\ttail:(\\\";\\\" _ e:metaexpr _ {return e})*\\n\\t\\t\\t{return [head].concat(tail)}\\n\\t\\t)?\\n\\t\\t\\\"]\\\"\\n\\t\\t{return b || []}\\n\\t)\\n\\tright:(\\n\\t\\t_ '>' _\\n\\t\\tsubject:(\\n\\t\\t\\tschemacall\\n\\t\\t\\t/ var\\n\\t\\t\\t/ \\\"(\\\" _\\n\\t\\t\\te:metaexpr _\\n\\t\\t\\t\\\")\\\"\\n\\t\\t\\t{return e}\\n\\t\\t)\\n\\t\\targs:(\\n\\t\\t\\t_ \\\"(\\\" _\\n\\t\\t\\ta:(\\n\\t\\t\\t\\thead:('?' {return null} / expr0) _\\n\\t\\t\\t\\ttail:(\\\",\\\" _ e:('?' {return null} / expr0) _ {return e})*\\n\\t\\t\\t\\t{return [head].concat(tail)}\\n\\t\\t\\t)?\\n\\t\\t\\t\\\")\\\"\\n\\t\\t\\t{return a || []}\\n\\t\\t)?\\n\\t\\tas_:(\\n\\t\\t\\t__ 'as' __\\n\\t\\t\\tm:metaexpr_internal_2\\n\\t\\t\\t{return m}\\n\\t\\t)?\\n\\t\\t{return {subject, args, as_: as_ || null};}\\n\\t)+\\n\\t{\\n\\t\\tvar ret = {\\n\\t\\t\\t_type: 'reduction',\\n\\t\\t\\tsubject: right[0].subject,\\n\\t\\t\\targs: right[0].args,\\n\\t\\t\\tantecedents,\\n\\t\\t\\tas: right[0].as_,\\n\\t\\t\\tlocation: location()\\n\\t\\t};\\n\\n\\t\\tfor (var i = 1; i < right.length; i++) {\\n\\t\\t\\tret = {\\n\\t\\t\\t\\t_type: 'reduction',\\n\\t\\t\\t\\tsubject: right[i].subject,\\n\\t\\t\\t\\targs: right[i].args,\\n\\t\\t\\t\\tantecedents: [ret],\\n\\t\\t\\t\\tas: right[i].as_,\\n\\t\\t\\t\\tlocation: location()\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t\\n\\t\\treturn ret;\\n\\t}\\n\\n// var(...)\\n// (metaexpr)(...)\\nschemacall =\\n\\tschema:(\\n\\t\\tvar\\n\\t\\t/ \\\"(\\\" _ e:metaexpr _ \\\")\\\"\\n\\t\\t{return e}\\n\\t) _\\n\\targs:(\\n\\t\\t\\\"(\\\" _\\n\\t\\ta:(\\n\\t\\t\\thead:expr0 _\\n\\t\\t\\ttail:(\\\",\\\" _ e:expr0 _ {return e})*\\n\\t\\t\\t{return [head].concat(tail)}\\n\\t\\t)?\\n\\t\\t\\\")\\\"\\n\\t\\t{return a || []}\\n\\t)\\n\\t{\\n\\t\\treturn {\\n\\t\\t\\t_type: 'schemacall',\\n\\t\\t\\tschema,\\n\\t\\t\\targs,\\n\\t\\t\\tlocation: location()\\n\\t\\t}\\n\\t}\\n\\n// forall(f, g)\\n// (expr0)(f, g)\\nfuncall =\\n\\tschema:(\\n\\t\\tvar\\n\\t\\t/ \\\"(\\\" _\\n\\t\\te:expr0 _\\n\\t\\t\\\")\\\"\\n\\t\\t{return e}\\n\\t) _\\n\\targs:(\\n\\t\\t\\\"(\\\" _\\n\\t\\ta:(\\n\\t\\t\\thead:expr0 _\\n\\t\\t\\ttail:(\\\",\\\" _ e:expr0 _ {return e})*\\n\\t\\t\\t{return [head].concat(tail)}\\n\\t\\t)?\\n\\t\\t\\\")\\\"\\n\\t\\t{return a || []}\\n\\t)\\n\\t{\\n\\t\\treturn {\\n\\t\\t\\t_type: 'funcall',\\n\\t\\t\\tschema,\\n\\t\\t\\targs,\\n\\t\\t\\tlocation: location()\\n\\t\\t}\\n\\t}\\n\\n// (T t) => expr0\\n// (T t) => { expr0 }\\nfunexpr =\\n\\tparams:(\\n\\t\\t\\\"(\\\" _\\n\\t\\tp:(\\n\\t\\t\\thead:defparam _\\n\\t\\t\\ttail:(\\\",\\\" _ tv:defparam _ {return tv})*\\n\\t\\t\\t{return [head].concat(tail)}\\n\\t\\t)?\\n\\t\\t\\\")\\\" _\\n\\t\\t{return p || []}\\n\\t)\\n\\t\\\"=>\\\" _\\n\\texpr:(\\n\\t\\texpr0\\n\\t\\t/ \\\"{\\\" _ e:expr0 _ \\\"}\\\" {return e}\\n\\t)\\n\\t{\\n\\t\\treturn {\\n\\t\\t\\t_type: 'funexpr',\\n\\t\\t\\tparams,\\n\\t\\t\\texpr,\\n\\t\\t\\tlocation: location()\\n\\t\\t}\\n\\t}\\n\\n// (T t) => metaexpr_internal_1\\n// (T t) => { $foo = ...; metaexpr }\\nschemaexpr =\\n\\tparams:(\\n\\t\\t\\\"(\\\" _\\n\\t\\tp:(\\n\\t\\t\\thead:defparam _\\n\\t\\t\\ttail:(\\\",\\\" _ tv:defparam _ {return tv})*\\n\\t\\t\\t{return [head].concat(tail)}\\n\\t\\t)?\\n\\t\\t\\\")\\\" _\\n\\t\\t{return p || []}\\n\\t)\\n\\t\\\"=>\\\" _\\n\\tfoo:(\\n\\t\\texpr:metaexpr_internal_1\\n\\t\\t{return {defdollars: [], expr}}\\n\\t\\t/ \\\"{\\\" _\\n\\t\\tdefdollars: (d:defdollar _ {return d})* _\\n\\t\\texpr:metaexpr _\\n\\t\\t\\\"}\\\"\\n\\t\\t{return {defdollars, expr}}\\n\\t)\\n\\t{\\n\\t\\treturn {\\n\\t\\t\\t_type: 'schemaexpr',\\n\\t\\t\\tparams,\\n\\t\\t\\tdef$s: foo.defdollars,\\n\\t\\t\\texpr: foo.expr,\\n\\t\\t\\tlocation: location()\\n\\t\\t}\\n\\t}\\n\\ntee =\\n\\tleft:(\\n\\t\\tl:(\\n\\t\\t\\thead:metaexpr_internal_1 _\\n\\t\\t\\ttail:(\\\",\\\" _ e:metaexpr_internal_1 _ {return e})*\\n\\t\\t\\t{return [head].concat(tail)}\\n\\t\\t)? {return l || []}\\n\\t)\\n\\t\\\"|-\\\" _\\n\\tfoo:(\\n\\t\\texpr:metaexpr_internal_2\\n\\t\\t{return {defdollars: [], expr}}\\n\\t\\t/ \\\"{\\\" _\\n\\t\\tdefdollars: (d:defdollar _ {return d})* _\\n\\t\\texpr:metaexpr _\\n\\t\\t\\\"}\\\"\\n\\t\\t{return {defdollars, expr}}\\n\\t)\\n\\t{\\n\\t\\treturn {\\n\\t\\t\\t_type: 'tee',\\n\\t\\t\\tdef$s: foo.defdollars,\\n\\t\\t\\tleft,\\n\\t\\t\\tright: foo.expr,\\n\\t\\t\\tlocation: location()\\n\\t\\t}\\n\\t}\\n\\nwith =\\n\\t'with' _ '(' _\\n\\ttex:(tex __)?\\n\\ttype:type __\\n\\tvarname:ident _\\n\\t\\\"=\\\" _\\n\\tvarexpr:expr0 _\\n\\t')' _ '{' _\\n\\tdefdollars: (d:defdollar _ {return d})* _\\n\\texpr:metaexpr _\\n\\t'}'\\n\\t{\\n\\t\\treturn {\\n\\t\\t\\t_type: 'with',\\n\\t\\t\\twith: {\\n\\t\\t\\t\\t_type: 'defv',\\n\\t\\t\\t\\tisParam: false,\\n\\t\\t\\t\\tdoc: null,\\n\\t\\t\\t\\ttex: tex ? tex[0] : null,\\n\\t\\t\\t\\tsealed: false,\\n\\t\\t\\t\\ttype,\\n\\t\\t\\t\\tname: varname,\\n\\t\\t\\t\\texpr: varexpr,\\n\\t\\t\\t\\tlocation: location()\\n\\t\\t\\t},\\n\\t\\t\\tdef$s: defdollars,\\n\\t\\t\\texpr,\\n\\t\\t\\tlocation: location()\\n\\t\\t}\\n\\t}\\n\\nmetaexpr =\\n\\tmetaexpr_internal_3\\n\\nmetaexpr_internal_3 =\\n\\treduction\\n\\t/ metaexpr_internal_2\\n\\nmetaexpr_internal_2 =\\n\\ttee\\n\\t/ metaexpr_internal_1\\n\\n/*\\n * The following should hold:\\n *\\n * - `schemacall` should precede `var`.\\n *\\n */\\nmetaexpr_internal_1 =\\n\\tschemacall\\n\\t/ var\\n\\t/ schemaexpr\\n\\t/ with\\n\\t/ \\\"(\\\" _ e:metaexpr _ \\\")\\\" {return e}\\n\\nexpr0 =\\n\\tfuncall\\n\\t/ funexpr\\n\\t/ var\\n\\t/ \\\"(\\\" _ e:expr0 _ \\\")\\\" {return e}\\n\\ndefdollar =\\n\\tname:dollar_ident _\\n\\t'=' _\\n\\texpr:metaexpr _\\n\\tsem\\n\\t{\\n\\t\\treturn {\\n\\t\\t\\t_type: 'def$',\\n\\t\\t\\tname,\\n\\t\\t\\texpr,\\n\\t\\t\\tlocation: location()\\n\\t\\t};\\n\\t}\\n\\ntype =\\n\\tstype\\n\\t/ ftype\\n\\nstype =\\n\\tname:ident\\n\\t{\\n\\t\\treturn {\\n\\t\\t\\t_type: 'type',\\n\\t\\t\\tftype: false,\\n\\t\\t\\tname,\\n\\t\\t\\tlocation: location()\\n\\t\\t}\\n\\t}\\n\\nftype =\\n\\t\\\"[\\\" _\\n\\tfrom:(\\n\\t\\ttype:type {return [type]}\\n\\t\\t/ (\\n\\t\\t\\ttt:(\\n\\t\\t\\t\\t\\\"(\\\" _\\n\\t\\t\\t\\thead: type\\n\\t\\t\\t\\ttail:(_ \\\",\\\" _ t:type {return t})*\\n\\t\\t\\t\\t_ \\\")\\\"\\n\\t\\t\\t\\t{return [head].concat(tail)}\\n\\t\\t\\t)\\n\\t\\t\\t{return tt}\\n\\t\\t)\\n\\t) _\\n\\t\\\"->\\\" _\\n\\tto:type _\\n\\t\\\"]\\\"\\n\\t{\\n\\t\\treturn {\\n\\t\\t\\t_type: 'type',\\n\\t\\t\\tftype: true,\\n\\t\\t\\tfrom,\\n\\t\\t\\tto,\\n\\t\\t\\tlocation: location()\\n\\t\\t}\\n\\t}\\n\\nvar =\\n\\tat_var\\n\\t/ dollar_var\\n\\t/ plain_var\\n\\nat_var =\\n\\tname:at_ident\\n\\t{\\n\\t\\treturn {\\n\\t\\t\\t_type: 'var',\\n\\t\\t\\ttype: '@',\\n\\t\\t\\tname: name.slice(1),\\n\\t\\t\\tlocation: location()\\n\\t\\t}\\n\\t}\\n\\ndollar_var =\\n\\tname:dollar_ident\\n\\t{\\n\\t\\treturn {\\n\\t\\t\\t_type: 'var',\\n\\t\\t\\ttype: '$',\\n\\t\\t\\tname: name,\\n\\t\\t\\tlocation: location()\\n\\t\\t}\\n\\t}\\n\\nplain_var =\\n\\tname:ident\\n\\t{\\n\\t\\treturn {\\n\\t\\t\\t_type: 'var',\\n\\t\\t\\ttype: 'normal',\\n\\t\\t\\tname,\\n\\t\\t\\tlocation: location()\\n\\t\\t}\\n\\t}\\n\\nkeyword =\\n\\t'as'\\n\\t/ 'axiom'\\n\\t/ 'base'\\n\\t/ 'import'\\n\\t/ 'schema'\\n\\t/ 'sealed'\\n\\t/ 'type'\\n\\t/ 'using'\\n\\t/ 'with'\\n\\nannotation =\\n\\t'@discouraged'\\n\\t/ '@deprecated'\\n\\nident =\\n\\t$(!(keyword ![a-zA-Z0-9_]) [a-zA-Z0-9_]+)\\n\\nat_ident =\\n\\t$('@' [a-zA-Z0-9_]+)\\n\\ndollar_ident =\\n\\t$('$' [a-zA-Z0-9_]+)\\n\\ndocumentation =\\n\\t'\\\"' b:$(!'\\\"' a:. {return a})* '\\\"' {\\n\\t\\treturn b.replace(/\\\\r\\\\n|\\\\r/g, '\\\\n');\\n\\t}\\n\\ntex =\\n\\t'$' b:$(!'$' a:. {return a})* '$' {\\n\\t\\treturn b.replace(/\\\\r\\\\n|\\\\r/g, '\\\\n');\\n\\t}\\n\\ncomment =\\n\\t\\\"//\\\" (!newline .)*\\n\\t/ \\\"/*\\\" (!\\\"*/\\\" .)* \\\"*/\\\"\\n\\nnewline =\\n\\t\\\"\\\\r\\\\n\\\" / \\\"\\\\r\\\" / \\\"\\\\n\\\"\\n\\n// optional whitespace\\n_ =\\n\\t([ \\\\t\\\\n\\\\r] / comment)*\\n\\n// mandatory whitespace\\n__ =\\n\\t([ \\\\t\\\\n\\\\r] / comment)+\\n\\nsem =\\n\\t\\\";\\\"\";","import PegInterface from './PegInterface';\nimport { EvaluableObject, ImportOrLineObject } from './PegInterfaceDefinitions';\nimport ProofExplorer from './ProofExplorer';\nimport Scope from './Scope';\n\ninterface LoaderReturnType {\n\tfileUri?: string;\n\tcode: string;\n}\n\ntype LoaderType = (packageName: string) => (LoaderReturnType | Promise<LoaderReturnType>);\n\nexport default class Program {\n\t\n\tpublic scope: Scope;\n\tpublic readonly parser;\n\tpublic readonly scopeMap: Map<string, Scope> = new Map();\n\n\t/**\n\t * A temporary list used by {@link loadModuleInternal} method.\n\t * \n\t * This is the list of filenames of the files with a temporary mark during a\n\t * depth-first topological sort. Node that the file is considered to be\n\t * marked with a permanent mark if {@code this.scopeMap} has the filename.\n\t * \n\t * See https://en.wikipedia.org/wiki/Topological_sorting#Depth-first_search.\n\t */\n\tprivate loadingModules: string[];\n\t\n\tconstructor (parser) {\n\t\tif (!parser) throw Error('no');\n\t\tthis.parser = parser;\n\t}\n\n\tpublic async loadModule(filename: string, loader: LoaderType): Promise<Scope> {\n\t\tthis.loadingModules = [];\n\t\treturn this.scope = await this.loadModuleInternal(filename, loader);\n\t}\n\n\tprivate async loadModuleInternal(filename: string, loader: LoaderType): Promise<Scope> {\n\t\t// the file has a permanent mark\n\t\tif (this.scopeMap.has(filename)) {\n\t\t\treturn this.scopeMap.get(filename);\n\t\t}\n\n\t\tvar loadingModuleIndex = this.loadingModules.indexOf(filename);\n\n\t\t// the file has a temporary mark\n\t\tif (loadingModuleIndex >= 0) {\n\t\t\tif (loadingModuleIndex == this.loadingModules.length - 1) {\n\t\t\t\tthrow Error(`Cannot self import (${filename})`);\n\t\t\t}\n\n\t\t\tvar cycle = this.loadingModules.slice(loadingModuleIndex).concat(filename);\n\n\t\t\tthrow Error(`Circular import detected (${cycle.join(' -> ')}). Sadly, circular import is currently not supported.`);\n\t\t}\n\n\t\t// mark the file with a temporary mark\n\t\tthis.loadingModules.push(filename);\n\n\t\tvar {fileUri, code} = await loader(filename);\n\n\t\tvar scope = new Scope(fileUri, null);\n\t\tvar parsed = this.parser.parse(code);\n\n\t\tawait this.feed(parsed, scope, loader);\n\n\t\t// remove temporary mark\n\t\tif (this.loadingModules.pop() != filename) {\n\t\t\tthrow Error('Something\\'s wrong');\n\t\t}\n\n\t\t// mark the file with a permanent mark\n\t\tthis.scopeMap.set(filename, scope);\n\t\treturn scope;\n\t}\n\n\tpublic async feed(lines: ImportOrLineObject[], scope: Scope=this.scope, loader: LoaderType) {\n\t\tfor (var i = 0; i < lines.length; i++) {\n\t\t\tvar line = lines[i];\n\t\t\t\n\t\t\tswitch (line._type) {\n\t\t\t\tcase 'import':\n\t\t\t\t\tvar scope2 = await this.loadModuleInternal(line.filename, loader);\n\t\t\t\t\tscope.importMap.set(line.filename, scope2);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'typedef':\n\t\t\t\t\tvar type = PegInterface.type(line, scope);\n\n\t\t\t\t\tif (scope.hasType(type.name)) {\n\t\t\t\t\t\tthrow scope.error(`Type ${type.name} has already been declared`);\n\t\t\t\t\t}\n\n\t\t\t\t\tscope.addType(type);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'defv':\n\t\t\t\t\tvar variable = PegInterface.variable(line, scope);\n\n\t\t\t\t\tif (scope.hasVariable(variable.name)) {\n\t\t\t\t\t\tthrow scope.error(`Definition ${variable.name} has already been declared`);\n\t\t\t\t\t}\n\n\t\t\t\t\tscope.addVariable(variable);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'defun':\n\t\t\t\t\tvar fun = PegInterface.fun(line, scope);\n\n\t\t\t\t\tif (scope.hasVariable(fun.name)) {\n\t\t\t\t\t\tthrow scope.error(`Definition ${fun.name} has already been declared`);\n\t\t\t\t\t}\n\n\t\t\t\t\tscope.addFun(fun);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'defschema':\n\t\t\t\t\tvar schema = PegInterface.schema(line, scope, null);\n\n\t\t\t\t\tif (scope.hasSchema(schema.name)) {\n\t\t\t\t\t\tthrow scope.error(`Schema ${schema.name} has already been declared`);\n\t\t\t\t\t}\n\n\t\t\t\t\tscope.addSchema(schema);\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tthrow Error(`Unknown line type ${(line as any)._type}`);\n\t\t\t}\n\t\t};\n\t}\n\n\tpublic evaluate(line: EvaluableObject) {\n\t\tvar scope = new Scope('<repl>', this.scope);\n\n\t\tswitch (line._type) {\n\t\t\tcase 'typedef':\n\t\t\t\treturn PegInterface.type(line, scope);\n\t\t\tcase 'defv':\n\t\t\t\treturn PegInterface.variable(line, scope);\n\t\t\tcase 'defun':\n\t\t\t\treturn PegInterface.fun(line, scope);\n\t\t\tcase 'defschema':\n\t\t\tcase 'schemaexpr':\n\t\t\t\treturn PegInterface.schema(line, scope, null);\n\t\t\tcase 'tee':\n\t\t\t\treturn PegInterface.tee(line, scope, null);\n\t\t\tcase 'reduction':\n\t\t\t\treturn PegInterface.reduction(line, scope, null);\n\t\t\tcase 'schemacall':\n\t\t\t\treturn PegInterface.schemacall(line, scope, null);\n\t\t\tcase 'var':\n\t\t\t\treturn PegInterface.metavar(line, scope);\n\t\t\tdefault:\n\t\t\t\tthrow Error(`Unknown line type ${(line as any)._type}`);\n\t\t}\n\t}\n\n\tpublic getProofExplorer(name: string, ktx) {\n\t\treturn ProofExplorer.get(this.scope, name, ktx);\n\t}\n}","/*\n * PEG.js      .\n * PEG.js    .\n */\n\nimport ExecutionContext from './ExecutionContext';\nimport $Variable from './nodes/$Variable';\nimport Expr0 from './nodes/Expr0';\nimport Fun from './nodes/Fun';\nimport Funcall from './nodes/Funcall';\nimport Metaexpr from './nodes/Metaexpr';\nimport ObjectFun from './nodes/ObjectFun';\nimport ObjectType from './nodes/ObjectType';\nimport Parameter from './nodes/Parameter';\nimport Reduction from './nodes/Reduction';\nimport Schema, { SchemaType } from './nodes/Schema';\nimport Tee from './nodes/Tee';\nimport Variable from './nodes/Variable';\nimport With from './nodes/With';\nimport { Def$Object, DefschemaObject, DefunObject, DefvObject, Expr0Object, FuncallObject, FunexprObject, MetaexprObject, ReductionObject, SchemacallObject, SchemaexprObject, StypeObject, TeeObject, TypedefObject, TypeObject, VarObject, WithObject } from './PegInterfaceDefinitions';\nimport Scope, { NestedTypeInput } from './Scope';\n\nfunction typeObjToString(obj: TypeObject): string {\n\tif (obj._type != 'type')\n\t\tthrow Error('Assertion failed');\n\n\tif (!obj.ftype) return (obj as StypeObject).name;\n\treturn '[' + obj.from.map(typeObjToString).join(', ') + ' -> '\n\t\t\t+ typeObjToString(obj.to) + ']';\n}\n\n/*\n * Scope#getType Scope#hasType    .\n * st\t\t\t\t\t\t-> 'st'\n * [cls -> st]\t\t\t\t-> ['cls', 'st']\n * [(cls, cls) -> st]\t\t-> ['cls', 'cls', 'st']\n * [[cls -> st] -> st]\t\t-> [['cls', 'st'], 'st']\n */\nfunction typeObjToNestedArr(obj: TypeObject): NestedTypeInput {\n\tif (obj._type != 'type')\n\t\tthrow Error('Assertion failed');\n\n\tif (!obj.ftype) {\n\t\tobj = obj as StypeObject;\n\n\t\tif (!obj.name)\n\t\t\tthrow Error('Assertion failed');\n\n\t\treturn obj.name;\n\t} else {\n\t\tif (!obj.from || !obj.to)\n\t\t\tthrow Error('Assertion failed');\n\n\t\treturn obj.from.map(typeObjToNestedArr).concat(\n\t\t\t[typeObjToNestedArr(obj.to)]\n\t\t);\n\t}\n}\n\nfunction varObjToString(obj: VarObject): string {\n\tswitch (obj.type) {\n\t\tcase '@':\n\t\t\treturn `@${obj.name}`;\n\t\tcase '$':\n\t\t\treturn `${obj.name}`;\n\t\tcase 'normal':\n\t\t\treturn `${obj.name}`;\n\t\tdefault:\n\t\t\tthrow Error(`Unknown type ${obj.type}`);\n\t}\n}\n\nexport default class PI {\n\tpublic static type(obj: TypedefObject, parentScope: Scope): ObjectType {\n\t\tif (obj._type != 'typedef')\n\t\t\tthrow Error('Assertion failed');\n\n\t\tvar scope: Scope = parentScope.extend('type', obj.name, obj.location);\n\n\t\tvar origin: ObjectType = obj.origin ? scope.getType(typeObjToNestedArr(obj.origin)) : null;\n\n\t\tvar name: string = obj.name;\n\t\tvar doc: string = obj.doc;\n\t\tvar base: boolean = obj.base;\n\n\t\tif (base && origin) {\n\t\t\tthrow scope.error('Base type should not be an alias');\n\t\t}\n\n\t\tif (origin) {\n\t\t\treturn new ObjectType({\n\t\t\t\tname,\n\t\t\t\tdoc,\n\t\t\t\tbase,\n\t\t\t\torigin\n\t\t\t});\n\t\t}\n\n\t\treturn new ObjectType({\n\t\t\tfunctional: false,\n\t\t\tname,\n\t\t\tdoc,\n\t\t\tbase\n\t\t});\n\t}\n\n\tpublic static variable(obj: DefvObject | VarObject, parentScope: Scope): Variable | Fun {\n\t\tif (!['defv', 'var'].includes(obj._type)) {\n\t\t\tthrow Error('Assertion failed');\n\t\t}\n\n\t\tvar scope = parentScope.extend('variable', obj.name, obj.location);\n\n\t\tif (obj._type == 'var') {\n\t\t\tif (obj.type != 'normal') {\n\t\t\t\tthrow scope.error(`Variable type ${obj.type} not allowed`);\n\t\t\t}\n\n\t\t\tif (!scope.hasVariable(obj.name))\n\t\t\t\tthrow scope.error(`Undefined identifier ${varObjToString(obj)}`);\n\t\t\treturn scope.getVariable(obj.name);\n\t\t}\n\n\t\tif (!scope.hasType(typeObjToNestedArr(obj.type)))\n\t\t\tthrow scope.error(`Type ${typeObjToString(obj.type)} is not defined`);\n\n\t\tvar type = scope.getType(typeObjToNestedArr(obj.type));\n\n\t\tvar expr = obj.expr ? PI.expr0(obj.expr, scope) : null;\n\n\t\tif (obj.isParam) {\n\t\t\treturn new Parameter({\n\t\t\t\tdoc: obj.doc,\n\t\t\t\ttex: obj.tex,\n\t\t\t\ttype,\n\t\t\t\tname: obj.name,\n\t\t\t\tselector: obj.selector || null\n\t\t\t}, scope.trace);\n\t\t}\n\n\t\treturn new Variable({\n\t\t\tdoc: obj.doc,\n\t\t\ttex: obj.tex,\n\t\t\tsealed: !!obj.sealed,\n\t\t\ttype,\n\t\t\tname: obj.name,\n\t\t\texpr: expr || null\n\t\t}, scope.trace);\n\t}\n\n\tpublic static fun(obj: DefunObject | FunexprObject, parentScope: Scope): ObjectFun {\n\t\tif (obj._type != 'defun' && obj._type != 'funexpr')\n\t\t\tthrow Error('Assertion failed');\n\t\t\n\t\tvar scope = parentScope.extend('fun', obj._type == 'defun' ? obj.name : '<anonymous>', obj.location);\n\n\t\tvar doc = null,\n\t\t\ttex = null,\n\t\t\tsealed = false,\n\t\t\trettype: ObjectType = null,\n\t\t\tname = null,\n\t\t\texpr = null;\n\n\t\tif (obj._type == 'defun') {\n\t\t\tdoc = obj.doc;\n\t\t\ttex = obj.tex;\n\t\t\tsealed = obj.sealed;\n\t\t\t\n\t\t\tif (!scope.hasType(typeObjToNestedArr(obj.rettype))) {\n\t\t\t\tthrow scope.error(`Type ${typeObjToString(obj.rettype)} is not defined`);\n\t\t\t}\n\n\t\t\trettype = scope.getType(typeObjToNestedArr(obj.rettype));\n\t\t\tname = obj.name;\n\t\t}\n\n\t\tvar params = obj.params.map(tvo => {\n\t\t\tvar tv = PI.variable(tvo, scope);\n\n\t\t\tif (scope.hasOwnVariable(tv.name))\n\t\t\t\tthrow scope.error(`Parameter ${tv.name} has already been declared`);\n\t\t\t\n\t\t\tif (!(tv instanceof Parameter)) {\n\t\t\t\tthrow Error('Something\\'s wrong');\n\t\t\t}\n\n\t\t\tscope.addVariable(tv);\n\t\t\treturn tv;\n\t\t});\n\n\t\tif (obj.expr) {\n\t\t\texpr = PI.expr0(obj.expr, scope);\n\t\t}\n\n\t\treturn new ObjectFun({annotations: [], sealed, rettype, name, params, expr, doc, tex}, scope.trace);\n\t}\n\n\tpublic static funcall(obj: FuncallObject, parentScope: Scope): Funcall {\n\t\tif (obj._type != 'funcall')\n\t\t\tthrow Error('Assertion failed');\n\n\t\tvar scope = parentScope.extend('funcall', 'name' in obj.schema ? obj.schema.name : null, obj.location);\n\n\t\tvar fun = PI.expr0(obj.schema, scope);\n\n\t\tvar args = obj.args.map(arg => {\n\t\t\treturn PI.expr0(arg, scope);\n\t\t});\n\n\t\treturn new Funcall({fun, args}, scope.trace);\n\t}\n\n\tpublic static metaexpr(obj: MetaexprObject, parentScope: Scope, context: ExecutionContext): Metaexpr {\n\t\tif (!['tee', 'reduction', 'schemacall', 'schemaexpr', 'var', 'with'].includes(obj._type)) {\n\t\t\tthrow Error('Assertion failed');\n\t\t}\n\n\t\t// don't extend scope\n\t\tvar scope = parentScope;\n\n\t\tswitch (obj._type) {\n\t\t\tcase 'tee':\n\t\t\t\treturn PI.tee(obj, scope, context);\n\t\t\tcase 'reduction':\n\t\t\t\treturn PI.reduction(obj, scope, context);\n\t\t\tcase 'schemacall':\n\t\t\t\treturn PI.schemacall(obj, scope, context);\n\t\t\tcase 'schemaexpr':\n\t\t\t\treturn PI.schema(obj, scope, context);\n\t\t\tcase 'var':\n\t\t\t\treturn PI.metavar(obj, scope);\n\t\t\tcase 'with':\n\t\t\t\treturn PI.with(obj, scope, context);\n\t\t\tdefault:\n\t\t\t\tthrow Error('wut');\n\t\t}\n\t}\n\n\tpublic static expr0(obj: Expr0Object, parentScope: Scope): Expr0 {\n\t\tif (!['funcall', 'funexpr', 'var'].includes(obj._type)) {\n\t\t\tconsole.log(obj);\n\t\t\tthrow Error('Assertion failed');\n\t\t}\n\n\t\t// don't extend scope\n\t\tvar scope = parentScope;\n\n\t\tswitch (obj._type) {\n\t\t\tcase 'funcall':\n\t\t\t\treturn PI.funcall(obj, scope);\n\t\t\tcase 'funexpr':\n\t\t\t\treturn PI.fun(obj, scope);\n\t\t\tcase 'var':\n\t\t\t\treturn PI.variable(obj, scope);\n\t\t\tdefault:\n\t\t\t\tthrow Error('wut');\n\t\t}\n\t}\n\n\tpublic static metavar(obj: VarObject, parentScope: Scope): Metaexpr {\n\t\tif (obj._type != 'var')\n\t\t\tthrow Error('Assertion failed');\n\n\t\t// don't extend scope\n\t\tvar scope = parentScope;\n\n\t\tswitch (obj.type) {\n\t\t\tcase '@':\n\t\t\t\tif (obj.name.match(/^h[0-9]+$/)) {\n\t\t\t\t\tvar hypnum = Number(obj.name.slice(1)) - 1;\n\t\t\t\t\tif (hypnum >= scope.hypotheses.length) {\n\t\t\t\t\t\tthrow scope.error(`Hypothesis #${hypnum + 1} not found`);\n\t\t\t\t\t}\n\n\t\t\t\t\treturn scope.hypotheses[hypnum];\n\t\t\t\t}\n\n\t\t\t\tthrow scope.error(`Unknown selector query ${varObjToString(obj)}`);\n\t\t\tcase '$':\n\t\t\t\tif (!scope.has$(obj.name)) {\n\t\t\t\t\tthrow scope.error(`${varObjToString(obj)} is not defined`);\n\t\t\t\t}\n\n\t\t\t\treturn scope.get$(obj.name);\n\t\t\tcase 'normal':\n\t\t\t\tif (!scope.hasSchema(obj.name))\n\t\t\t\t\tthrow scope.error(`Schema ${varObjToString(obj)} is not defined`);\n\n\t\t\t\treturn scope.getSchema(obj.name);\n\t\t\tdefault:\n\t\t\t\tthrow scope.error(`Unknown type ${obj.type}`);\n\t\t}\n\t}\n\n\tpublic static with(obj: WithObject, parentScope: Scope, context: ExecutionContext): With {\n\t\tif (obj._type != 'with') {\n\t\t\tthrow Error('Assertion failed');\n\t\t}\n\n\t\tvar scope = parentScope.extend('with', null, obj.location);\n\n\t\tvar tv = PI.variable(obj.with, scope);\n\n\t\tif (scope.hasOwnVariable(tv.name))\n\t\t\tthrow scope.error(`Parameter ${tv.name} has already been declared`);\n\t\t\n\t\tif (!(tv instanceof Variable)) {\n\t\t\tthrow Error('Something\\'s wrong');\n\t\t}\n\n\t\tscope.addVariable(tv);\n\n\t\tvar def$s = obj.def$s.map($ => {\n\t\t\tvar $v = PI.def$($, scope, context);\n\n\t\t\tif (scope.hasOwn$($v.name)) {\n\t\t\t\tthrow scope.error(`${$.name} has already been declared`);\n\t\t\t}\n\n\t\t\treturn scope.add$($v);\n\t\t});\n\n\t\tvar expr = PI.metaexpr(obj.expr, scope, context);\n\n\t\treturn new With({\n\t\t\tvariable: tv,\n\t\t\tdef$s,\n\t\t\texpr\n\t\t}, scope.trace);\n\t}\n\n\tpublic static tee(obj: TeeObject, parentScope: Scope, context: ExecutionContext): Tee {\n\t\tif (obj._type != 'tee')\n\t\t\tthrow Error('Assertion failed');\n\n\t\tvar scope = parentScope.extend('tee', null, obj.location);\n\n\t\tvar left = obj.left.map(o => PI.metaexpr(o, scope, context));\n\n\t\tvar scopeRight = scope.extend('tee.right', null, obj.right.location);\n\t\tleft.forEach(l => scopeRight.hypotheses.push(l));\n\n\t\tvar def$s = obj.def$s.map($ => {\n\t\t\tvar $v = PI.def$($, scopeRight, context);\n\n\t\t\tif (scopeRight.hasOwn$($v.name)) {\n\t\t\t\tthrow scopeRight.error(`${$.name} has already been declared`);\n\t\t\t}\n\n\t\t\treturn scopeRight.add$($v);\n\t\t});\n\n\t\tvar right = PI.metaexpr(obj.right, scopeRight, context);\n\n\t\treturn new Tee({left, def$s, right}, scope.trace);\n\t}\n\n\tpublic static def$(obj: Def$Object, parentScope: Scope, context: ExecutionContext): $Variable {\n\t\tif (obj._type != 'def$')\n\t\t\tthrow Error('Assertion failed');\n\t\t\n\t\tvar scope = parentScope.extend('def$', obj.name, obj.location);\n\t\t\n\t\tvar expr = PI.metaexpr(obj.expr, scope, context);\n\n\t\treturn new $Variable({name: obj.name, expr}, scope.trace);\n\t}\n\n\tpublic static schema(obj: DefschemaObject | SchemaexprObject, parentScope: Scope, oldContext: ExecutionContext): Schema {\n\t\tif (obj._type != 'defschema' && obj._type != 'schemaexpr')\n\t\t\tthrow Error('Assertion failed');\n\t\t\n\t\tvar name = obj._type == 'defschema' ? obj.name : null;\n\n\t\tvar scope = parentScope.extend('schema', name, obj.location);\n\n\t\tvar schemaType: SchemaType = 'schema',\n\t\t\tdoc: string = null,\n\t\t\tannotations: string[] = [],\n\t\t\tcontext = oldContext;\n\n\t\tif (obj._type == 'defschema') {\n\t\t\tschemaType = obj.schemaType;\n\t\t\tdoc = obj.doc;\n\t\t\tannotations = obj.annotations;\n\n\t\t\tif (oldContext) {\n\t\t\t\tconsole.log(oldContext);\n\t\t\t\tthrow Error('duh');\n\t\t\t}\n\n\t\t\tvar using: (Variable | ObjectFun)[] = obj.using.map(name => {\n\t\t\t\tif (!scope.hasVariable(name)) {\n\t\t\t\t\tthrow scope.error(`Variable ${name} is not defined`);\n\t\t\t\t}\n\n\t\t\t\tvar fun = scope.getVariable(name);\n\n\t\t\t\tif (!fun.expr) {\n\t\t\t\t\tthrow scope.error(`${name} is not a macro`);\n\t\t\t\t}\n\n\t\t\t\treturn fun;\n\t\t\t});\n\n\t\t\tcontext = new ExecutionContext(using);\n\t\t}\n\n\t\tvar params = obj.params.map(tvo => {\n\t\t\tvar tv = PI.variable(tvo, scope);\n\n\t\t\tif (scope.hasOwnVariable(tv.name))\n\t\t\t\tthrow scope.error(`Parameter ${tv.name} has already been declared`);\n\t\t\t\n\t\t\tif (!(tv instanceof Parameter)) {\n\t\t\t\tthrow Error('Something\\'s wrong');\n\t\t\t}\n\n\t\t\tscope.addVariable(tv);\n\t\t\treturn tv;\n\t\t});\n\n\t\tvar def$s = obj.def$s.map($ => {\n\t\t\tvar $v = PI.def$($, scope, context);\n\n\t\t\tif (scope.hasOwn$($v.name)) {\n\t\t\t\tthrow scope.error(`${$.name} has already been declared`);\n\t\t\t}\n\n\t\t\treturn scope.add$($v);\n\t\t});\n\n\t\tvar expr = PI.metaexpr(obj.expr, scope, context);\n\n\t\treturn new Schema({doc, tex: null, annotations, schemaType, name, params, context, def$s, expr}, scope.trace);\n\t}\n\n\tpublic static schemacall(obj: SchemacallObject, parentScope: Scope, context: ExecutionContext): Funcall {\n\t\tif (obj._type != 'schemacall')\n\t\t\tthrow Error('Assertion failed');\n\n\t\tvar scope = parentScope.extend('schemacall', 'name' in obj.schema ? obj.schema.name : null, obj.location);\n\n\t\tvar fun = PI.metaexpr(obj.schema, scope, context);\n\n\t\tvar args = obj.args.map(obj => {\n\t\t\treturn PI.expr0(obj, scope);\n\t\t});\n\n\t\treturn new Funcall({\n\t\t\tfun,\n\t\t\targs\n\t\t}, scope.trace);\n\t}\n\n\tpublic static reduction(obj: ReductionObject, parentScope: Scope, context: ExecutionContext): Reduction {\n\t\tif (obj._type != 'reduction')\n\t\t\tthrow Error('Assertion failed');\n\t\t\n\t\tif (!context) {\n\t\t\tthrow Error('duh');\n\t\t}\n\n\t\tvar scope = parentScope.extend('reduction', 'name' in obj.subject ? obj.subject.name : null, obj.location);\n\n\t\tvar subject = PI.metaexpr(obj.subject, scope, context);\n\n\t\tvar args = !obj.args\n\t\t\t? null\n\t\t\t: obj.args.map(g => {\n\t\t\t\treturn g && PI.expr0(g, scope);\n\t\t\t});\n\n\t\tvar antecedents = obj.antecedents.map(obj => {\n\t\t\treturn PI.metaexpr(obj, scope, context);\n\t\t});\n\n\t\tvar as = obj.as && PI.metaexpr(obj.as, scope, context);\n\n\t\treturn new Reduction({\n\t\t\tsubject,\n\t\t\targs,\n\t\t\tantecedents,\n\t\t\tas\n\t\t}, context, scope.trace);\n\t}\n}","import ObjectFun from \"./nodes/ObjectFun\";\nimport Variable from \"./nodes/Variable\";\n\nexport default class ExecutionContext {\n\n\tpublic readonly usingList: (Variable | ObjectFun)[];\n\n\tconstructor (usingList?: (Variable | ObjectFun)[]) {\n\t\tthis.usingList = usingList || [];\n\t}\n\n\tpublic canUse(fun: Variable | ObjectFun) {\n\t\treturn this.usingList.includes(fun);\n\t}\n}","import Counter from '../Counter';\nimport ExecutionContext from '../ExecutionContext';\nimport { ProofType } from '../ProofType';\nimport StackTrace from '../StackTrace';\nimport Expr0 from './Expr0';\nimport Fun from './Fun';\nimport Funcall from './Funcall';\nimport Metaexpr, { EqualsPriority } from './Metaexpr';\nimport MetaType from './MetaType';\nimport { isNameable } from './Nameable';\nimport Node, { Precedence } from './Node';\nimport ObjectType from './ObjectType';\nimport Tee from './Tee';\nimport Variable from './Variable';\n\ninterface ReductionArgumentType {\n\tantecedents: Metaexpr[];\n\tsubject: Metaexpr;\n\targs: (Expr0 | null)[];\n\tas: Metaexpr;\n}\n\nexport default class Reduction extends Metaexpr {\n\t\n\tpublic readonly antecedents: Metaexpr[];\n\tpublic readonly requiredAntecedents: Metaexpr[];\n\tpublic readonly subject: Metaexpr;\n\tpublic readonly args: (Expr0 | null)[];\n\tpublic readonly preFormatConsequent: Metaexpr;\n\tpublic readonly consequent: Metaexpr;\n\tprivate readonly antecedentEqualsResults: (Fun | Variable)[][];\n\tprivate readonly rightEqualsResult: (Fun | Variable)[];\n\n\tconstructor ({antecedents, subject, args, as}: ReductionArgumentType, context: ExecutionContext, trace: StackTrace) {\n\t\tif (args) {\n\t\t\tlet resolvedType = subject.type.resolve() as ObjectType | MetaType,\n\t\t\t\tparamTypes = resolvedType.from,\n\t\t\t\targTypes = args.map(e => e && e.type);\n\n\t\t\tif (paramTypes.length != argTypes.length)\n\t\t\t\tthrow Node.error(`Invalid number of arguments (expected ${paramTypes.length}): ${argTypes.length}`, trace);\n\n\t\t\tfor (var i = 0; i < paramTypes.length; i++) {\n\t\t\t\tif (argTypes[i] && !paramTypes[i].equals(argTypes[i])) {\n\t\t\t\t\tthrow Node.error(`Argument #${i + 1} has illegal argument type (expected ${paramTypes[i]}): ${argTypes[i]}`, trace);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (subject instanceof Fun) {\n\t\t\tsubject.params.forEach((p, i) => {\n\t\t\t\tif (!(args && args[i]) && !p.selector) {\n\t\t\t\t\tthrow Node.error(`Argument #${i + 1} could not be guessed`, trace);\n\t\t\t\t}\n\t\t\t});\n\t\n\t\t\tvar derefs = subject.params.map((p, i) => {\n\t\t\t\tif (args && args[i]) return args[i];\n\n\t\t\t\tvar tee = (subject as Fun).expr.expandMeta(false);\n\n\t\t\t\tif (!(tee instanceof Tee)) throw Error('wut');\n\t\n\t\t\t\treturn Reduction.guess(\n\t\t\t\t\tp.selector,\n\t\t\t\t\ttee.left, antecedents,\n\t\t\t\t\ttee.right, as,\n\t\t\t\t\tcontext, trace\n\t\t\t\t);\n\t\t\t});\n\t\n\t\t\tsubject = new Funcall({\n\t\t\t\tfun: subject,\n\t\t\t\targs: derefs,\n\t\t\t}, trace);\n\t\t} else if (args) {\n\t\t\tthrow Node.error('Something\\'s wrong', trace);\n\t\t}\n\t\n\t\tif (!(subject.type instanceof MetaType && subject.type.isSimple))\n\t\t\tthrow Node.error('Subject is not reducible', trace);\n\t\n\t\tif (!(antecedents instanceof Array)\n\t\t\t\t|| antecedents.map(e => e instanceof Node).some(e => !e))\n\t\t\tthrow Node.error('Assertion failed', trace);\n\n\t\tvar paramTypes = subject.type.left,\n\t\t\tantecedentTypes = antecedents.map(e => e.type);\n\n\t\tif (paramTypes.length != antecedentTypes.length)\n\t\t\tthrow Node.error(`Invalid number of arguments (expected ${paramTypes.length}): ${antecedentTypes.length}`, trace);\n\n\t\tfor (let i = 0; i < paramTypes.length; i++) {\n\t\t\tif (!paramTypes[i].equals(antecedentTypes[i]))\n\t\t\t\tthrow Node.error(`Illegal argument type (expected ${paramTypes[i]}): ${antecedentTypes[i]}`, trace);\n\t\t}\n\n\t\tsuper(trace, null, null, subject.type.right);\n\n\t\tthis.subject = subject;\n\t\tthis.antecedents = antecedents;\n\n\t\tvar tee = subject.expandMeta(true);\n\n\t\tif (!(tee instanceof Tee)) {\n\t\t\tthrow Node.error('Assertion failed', trace);\n\t\t}\n\n\t\tthis.requiredAntecedents = tee.left;\n\t\tthis.antecedentEqualsResults = Array(tee.left.length).fill(0).map(() => []);\n\n\t\tvar antecedentsExpanded = antecedents.map(arg => {\n\t\t\treturn arg.expandMeta(true);\n\t\t});\n\n\t\tfor (let i = 0; i < tee.left.length; i++) {\n\t\t\tvar tmp = tee.left[i].equals(antecedentsExpanded[i], context);\n\t\t\tif (!tmp) {\n\t\t\t\tthrow Node.error(`LHS #${i + 1} failed to match:\n\n--- EXPECTED ---\n${tee.left[i].expandMeta(true)}\n----------------\n\n--- RECEIVED ---\n${antecedents[i].expandMeta(true)}\n----------------`, trace);\n\t\t\t}\n\n\t\t\tthis.antecedentEqualsResults[i] = tmp;\n\t\t}\n\n\t\tthis.preFormatConsequent = tee.right;\n\n\t\tif (as) {\n\t\t\tvar tmp = tee.right.equals(as, context);\n\t\t\tif (!tmp) {\n\t\t\t\tthrow Node.error(`RHS failed to match:\n\n--- EXPECTED ---\n${tee.right.expandMeta(true)}\n----------------\n\n--- RECEIVED (from [as ...]) ---\n${as.expandMeta(true)}\n----------------`, trace);\n\t\t\t}\n\n\t\t\tthis.rightEqualsResult = tmp;\n\t\t\tthis.consequent = as;\n\t\t} else {\n\t\t\tthis.consequent = tee.right;\n\t\t}\n\t}\n\n\tprotected isProvedInternal(hypotheses: Metaexpr[]): boolean {\n\t\treturn this.subject.isProved(hypotheses)\n\t\t\t&& this.antecedents.every(l => l.isProved(hypotheses));\n\t}\n\n\tpublic substitute(map: Map<Variable, Expr0>): Metaexpr {\n\t\treturn this.consequent.substitute(map);\n\t}\n\n\tprotected expandMetaInternal(andFuncalls: boolean): Metaexpr {\n\t\treturn this.consequent.expandMeta(andFuncalls);\n\t}\n\n\tprotected getEqualsPriority(): EqualsPriority {\n\t\treturn EqualsPriority.FIVE;\n\t}\n\n\tprotected equalsInternal(obj: Metaexpr, context: ExecutionContext): (Fun | Variable)[] | false {\n\t\treturn this.consequent.equals(obj, context);\n\t}\n\n\tprotected getProofInternal(\n\t\t\thypnumMap: Map<Metaexpr, number>,\n\t\t\t$Map: Map<Metaexpr, number | [number, number]>,\n\t\t\tctr: Counter): ProofType[] {\n\t\t\n\t\tvar antecedentLinesList: ProofType[][] = [];\n\t\tvar antecedentNums: (number | [number, number])[] = this.antecedents.map((l, i) => {\n\t\t\tif (!this.antecedentEqualsResults[i].length) {\n\t\t\t\tif (hypnumMap.has(l)) return hypnumMap.get(l);\n\t\t\t\tif ($Map.has(l)) return $Map.get(l);\n\t\t\t}\n\n\t\t\tvar ref = hypnumMap.has(l)\n\t\t\t\t? hypnumMap.get(l)\n\t\t\t\t: $Map.has(l)\n\t\t\t\t\t? $Map.get(l)\n\t\t\t\t\t: null;\n\t\t\tvar lines = ref ? [] : l.getProof(hypnumMap, $Map, ctr);\n\n\t\t\tif (this.antecedentEqualsResults[i].length) {\n\t\t\t\tlines.push({\n\t\t\t\t\t_type: 'bydef',\n\t\t\t\t\tctr: ctr.next(),\n\t\t\t\t\tref: ref || lines[lines.length - 1].ctr,\n\t\t\t\t\texpr: this.requiredAntecedents[i],\n\t\t\t\t\tof: this.antecedentEqualsResults[i]\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tantecedentLinesList.push(lines);\n\t\t\treturn this.antecedentEqualsResults[i].length\n\t\t\t\t? ctr.peek()\n\t\t\t\t: lines[lines.length - 1].ctr;\n\t\t});\n\t\t\n\t\tvar args: Expr0[] = null;\n\t\tvar subjectlines: ProofType[] = [];\n\t\tvar subjectnum = hypnumMap.get(this.subject)\n\t\t\t|| $Map.get(this.subject)\n\t\t\t|| (\n\t\t\t\tthis.subject instanceof Funcall && $Map.has(this.subject.fun)\n\t\t\t\t\t? (args = this.subject.args, $Map.get(this.subject.fun))\n\t\t\t\t\t: false\n\t\t\t)\n\t\t\t|| (\n\t\t\t\t(s => {\n\t\t\t\t\treturn s instanceof Fun && s.name\n\t\t\t\t\t\t|| s instanceof Funcall && isNameable(s.fun) && s.fun.name;\n\t\t\t\t})(this.subject)\n\t\t\t\t\t? this.subject\n\t\t\t\t\t: (subjectlines = this.subject.getProof(hypnumMap, $Map, ctr))[subjectlines.length-1].ctr\n\t\t\t);\n\n\t\tvar ret: ProofType[] = [\n\t\t\t...antecedentLinesList.flat(),\n\t\t\t...subjectlines,\n\t\t\t{\n\t\t\t\t_type: 'E',\n\t\t\t\tctr: ctr.next(),\n\t\t\t\tsubject: subjectnum,\n\t\t\t\targs,\n\t\t\t\tantecedents: antecedentNums,\n\t\t\t\treduced: this.preFormatConsequent\n\t\t\t}\n\t\t];\n\n\t\tif (this.rightEqualsResult && this.rightEqualsResult.length) {\n\t\t\tret.push({\n\t\t\t\t_type: 'bydef',\n\t\t\t\tref: ctr.peek(),\n\t\t\t\tctr: ctr.next(),\n\t\t\t\texpr: this.consequent,\n\t\t\t\tof: this.rightEqualsResult\n\t\t\t});\n\t\t}\n\t\t\n\t\treturn ret;\n\t}\n\n\tpublic static guess(\n\t\t\tselector: string,\n\t\t\tleft: Metaexpr[], antecedents: Metaexpr[],\n\t\t\tright: Metaexpr, as: Metaexpr,\n\t\t\tcontext: ExecutionContext, trace: StackTrace): Metaexpr {\n\t\t\n\t\tif (selector.length == 0) throw Node.error('wut', trace);\n\n\t\tvar parameter: Metaexpr, argument: Metaexpr;\n\n\t\tif (selector[0] == 'r') {\n\t\t\tif (!as) {\n\t\t\t\tthrow Node.error(`Cannot dereference @${selector}: expected output is not given`, trace);\n\t\t\t}\n\n\t\t\tparameter = right;\n\t\t\targument = as;\n\t\t} else {\n\t\t\tvar n = Number(selector[0]);\n\n\t\t\tif (!(1 <= n && n <= antecedents.length))\n\t\t\t\tthrow Node.error(`Cannot dereference @${selector}: antecedent index out of range`, trace);\n\n\t\t\tparameter = left[n - 1];\n\t\t\targument = antecedents[n - 1];\n\t\t}\n\n\t\treturn (function recurse(\n\t\t\t\tptr: number,\n\t\t\t\tparameter: Metaexpr, argument: Metaexpr): Metaexpr {\n\t\t\t\n\t\t\targument = argument.expandMeta(true);\n\t\t\t\n\t\t\tif (selector.length <= ptr) return argument;\n\n\t\t\tif (/^[0-9]$/.test(selector[ptr])) {\n\t\t\t\tvar n = Number(selector[ptr]);\n\n\t\t\t\tif (parameter instanceof Tee && argument instanceof Tee) {\n\t\t\t\t\tif (parameter.left.length != argument.left.length) {\n\t\t\t\t\t\tthrow Node.error(`Cannot dereference @${selector}: antecedent length mismatch`, trace);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (!(1 <= n && n <= argument.left.length)) {\n\t\t\t\t\t\tthrow Node.error(`Cannot dereference @${selector}: antecedent index out of range`, trace);\n\t\t\t\t\t}\n\n\t\t\t\t\treturn recurse(ptr + 1, parameter.left[n - 1], argument.left[n - 1]);\n\t\t\t\t}\n\n\t\t\t\twhile (true) {\n\t\t\t\t\twhile (argument instanceof Variable && argument.expr) {\n\t\t\t\t\t\targument = argument.expr;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (!(parameter instanceof Funcall && argument instanceof Funcall)) {\n\t\t\t\t\t\tthrow Node.error(`Cannot dereference @${selector}`, trace);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (parameter.fun.equals(argument.fun, context)) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (!argument.isExpandable(context)) {\n\t\t\t\t\t\tthrow Node.error(`Cannot dereference @${selector}`, trace);\n\t\t\t\t\t}\n\n\t\t\t\t\targument = argument.expandOnce(context).expanded;\n\t\t\t\t}\n\n\t\t\t\tif (!(1 <= n && n <= argument.args.length))\n\t\t\t\t\tthrow Node.error(`Cannot dereference @${selector}`, trace);\n\n\t\t\t\treturn recurse(ptr + 1, parameter.args[n - 1], argument.args[n - 1]);\n\t\t\t} else if (selector[ptr] == 'r') {\n\t\t\t\tif (parameter instanceof Tee && argument instanceof Tee) {\n\t\t\t\t\treturn recurse(ptr + 1, parameter.right, argument.right);\n\t\t\t\t}\n\n\t\t\t\tthrow Node.error(`Cannot dereference @${selector}`, trace);\n\t\t\t}\n\n\t\t\tthrow Node.error(`Cannot dereference @${selector}`, trace);\n\t\t})(1, parameter, argument);\n\t}\n\n\tpublic toIndentedString(indent: number, root?: boolean): string {\n\t\tvar antecedents = this.antecedents.map(arg => {\n\t\t\treturn arg.toIndentedString(indent + 1);\n\t\t});\n\t\n\t\tif (antecedents.join('').length <= 50) {\n\t\t\tantecedents = this.antecedents.map(arg => {\n\t\t\t\treturn arg.toIndentedString(indent);\n\t\t\t});\n\t\n\t\t\treturn [\n\t\t\t\t`${this.subject.toIndentedString(indent)}[`,\n\t\t\t\tantecedents.join(', '),\n\t\t\t\t']'\n\t\t\t].join('');\n\t\t}\n\n\t\treturn [\n\t\t\t`${this.subject.toIndentedString(indent)}[`,\n\t\t\t'\\t' + antecedents.join(',\\n' + '\\t'.repeat(indent + 1)),\n\t\t\t']'\n\t\t].join('\\n' + '\\t'.repeat(indent));\n\t\t\n\t}\n\n\tpublic toTeXString(prec?: Precedence, root?: boolean): string {\n\t\treturn `${this.subject.toTeXString(false)}[${this.antecedents.map(e => e.toTeXString(Node.PREC_COMMA)).join(', ')}]`;\n\t}\n}","import Counter from \"../Counter\";\nimport ExecutionContext from \"../ExecutionContext\";\nimport { ProofType } from \"../ProofType\";\nimport StackTrace from \"../StackTrace\";\nimport $Variable from \"./$Variable\";\nimport Expr0 from \"./Expr0\";\nimport Fun from \"./Fun\";\nimport Metaexpr, { EqualsPriority } from \"./Metaexpr\";\nimport { Precedence } from \"./Node\";\nimport Variable from \"./Variable\";\n\ninterface WithArgumentType {\n\tvariable: Variable;\n\tdef$s: $Variable[];\n\texpr: Metaexpr;\n}\n\nexport default class With extends Metaexpr {\n\n\tpublic readonly variable: Variable;\n\tpublic readonly def$s: $Variable[];\n\tpublic readonly expr: Metaexpr;\n\n\tconstructor({variable, def$s, expr}: WithArgumentType, trace: StackTrace) {\n\t\tsuper(trace, null, null, expr.type);\n\n\t\tthis.variable = variable;\n\t\tthis.def$s = def$s;\n\t\tthis.expr = expr;\n\t}\n\n\tpublic substitute(map: Map<Variable, Expr0>): Metaexpr {\n\t\tif (map.has(this.variable))\n\t\t\tthrow Error('Parameter collision');\n\t\t\n\t\tmap = new Map(map);\n\n\t\treturn this.expandMeta(false).substitute(map);\n\t}\n\n\tprotected expandMetaInternal(andFuncalls: boolean): Metaexpr {\n\t\tvar map = new Map<Variable, Expr0>();\n\t\tmap.set(this.variable, this.variable.expr);\n\n\t\treturn this.expr.substitute(map).expandMeta(andFuncalls);\n\t}\n\n\tprotected getEqualsPriority(context: ExecutionContext): EqualsPriority {\n\t\tthrow new Error(\"Method not implemented.\");\n\t}\n\n\tprotected equalsInternal(obj: Metaexpr, context: ExecutionContext): (Fun | Variable)[] | false {\n\t\tthrow new Error(\"Method not implemented.\");\n\t}\n\n\tprotected isProvedInternal(hypotheses: Metaexpr[]): boolean {\n\t\treturn this.expr.isProved(hypotheses);\n\t}\n\n\tprotected getProofInternal(hypnumMap: Map<Metaexpr, number>, $Map: Map<Metaexpr, number | [number, number]>, ctr: Counter, root?: boolean): ProofType[] {\n\n\t\t$Map = new Map($Map);\n\n\t\tvar def: ProofType = {\n\t\t\t_type: 'def',\n\t\t\tctr: ctr.next(),\n\t\t\tvar: this.variable\n\t\t};\n\n\t\tvar $lines = this.def$s.map($ => {\n\t\t\tvar lines = $.expr.getProof(hypnumMap, $Map, ctr);\n\t\t\tvar $num = lines[lines.length - 1].ctr;\n\t\t\t$Map.set($, $num);\n\t\t\treturn lines;\n\t\t}).flat(1);\n\n\t\treturn [\n\t\t\tdef,\n\t\t\t...$lines,\n\t\t\t...this.expr.getProof(hypnumMap, $Map, ctr)\n\t\t];\n\t}\n\n\tpublic toIndentedString(indent: number, root?: boolean): string {\n\t\tthrow new Error(\"Method not implemented.\");\n\t}\n\n\tpublic toTeXString(prec?: Precedence, root?: boolean): string {\n\t\tthrow new Error(\"Method not implemented.\");\n\t}\n}","import Counter from \"./Counter\";\nimport Metaexpr from \"./nodes/Metaexpr\";\nimport Schema from \"./nodes/Schema\";\nimport Variable from \"./nodes/Variable\";\nimport { ProofType } from \"./ProofType\";\nimport Scope from \"./Scope\";\n\nexport default class ProofExplorer {\n\tpublic static get(scope: Scope, name: string, ktx): string {\n\t\tvar DIAMOND = '&#x25C7;',\n\t\t\tDOWN = '&#x25BC;';\n\t\t// var UP = '&#x25B2;';\n\t\t\n\t\tif (!scope.hasSchema(name)) {\n\t\t\tthrow Error('wut');\n\t\t}\n\t\n\t\tvar expr = scope.getSchema(name);\n\n\t\tif (!(expr instanceof Schema)) {\n\t\t\tthrow Error('wut');\n\t\t}\n\n\t\tfunction getHtmlLine(ctr: string | number, left: any[], h1: string, h2: string | string[], options?) {\n\t\t\tvar padding = left.length;\n\n\t\t\tvar {bbb=false, rrb=false} = options || {};\n\t\n\t\t\tvar htmlLeft = left.map((e, i, a) => `<td class=\"${rrb && i == a.length - 1 ? 'rrb' : 'brb'}\">${e.map(f => ktx(f.toTeXStringWithId(true))).join(', ')}</td>`).join('');\n\n\t\t\tfor (var i = 0; i < left.length; i++)\n\t\t\t\twhile(left[i].length) left[i].pop();\n\t\n\t\t\treturn `<tr><th>${ctr}</th>${htmlLeft}<td ${bbb ? 'class=\"bbb\" ' : ''}colspan=\"${ncols-padding}\">${h1}</td>${h2 instanceof Array ? h2.map(e => `<td>${e}</td>`).join('') : `<td colspan=\"2\">${h2}</td>`}</tr>`;\n\t\t}\n\n\t\tfunction exprToHtml(expr: number | [number, number] | Metaexpr, expand?: boolean): string {\n\t\t\tif (typeof expr == 'number') return `<b>${expr}</b>`;\n\t\t\tif (expr instanceof Array) return `<b>${expr[0]}&ndash;${expr[1]}</b>`;\n\t\t\tif (expand) return ktx(expr.expandMeta(true).toTeXString(true, true));\n\t\t\t\n\t\t\treturn ktx(expr.toTeXString(true, true));\n\t\t}\n\n\t\tvar tree = expr.getProof(new Map(), new Map(), new Counter(), true);\n\n\t\tvar innertree: ProofType[] = (tree[0] as any).$lines.concat((tree[0] as any).lines);\n\n\t\tvar ncols = (function recurse(tree: ProofType[]): number {\n\t\t\treturn Math.max(...tree.map(t => {\n\t\t\t\tswitch (t._type) {\n\t\t\t\t\tcase 'V':\n\t\t\t\t\t\treturn Math.max(\n\t\t\t\t\t\t\trecurse(t.$lines),\n\t\t\t\t\t\t\trecurse(t.lines)\n\t\t\t\t\t\t) + 1;\n\t\t\t\t\tcase 'T':\n\t\t\t\t\t\treturn Math.max(\n\t\t\t\t\t\t\trecurse(t.leftlines),\n\t\t\t\t\t\t\trecurse(t.rightlines)\n\t\t\t\t\t\t) + 1;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\treturn 1;\n\t\t\t\t}\n\t\t\t}));\n\t\t})(innertree);\n\n\t\tvar html = '<table class=\"explorer\">';\n\t\thtml += `<tr><th>#</th><th colspan=\"${ncols}\">expr</th><th colspan=\"2\">rule</th></tr>`;\n\t\t\n\t\thtml += (function tree2html(lines: ProofType[], left: Variable[][]) {\n\t\t\treturn lines.map(line => {\n\t\t\t\tswitch (line._type) {\n\t\t\t\t\tcase 'V':\n\t\t\t\t\t\t// getHtmlLine     \n\t\t\t\t\t\t// shallow copy  .\n\t\t\t\t\t\tvar params = line.params.slice();\n\t\t\t\t\t\treturn tree2html(line.$lines, left.concat([params]))\n\t\t\t\t\t\t\t+ tree2html(line.lines, left.concat([params]));\n\t\t\t\t\tcase 'T':\n\t\t\t\t\t\tvar newleft = left.concat([[]]);\n\n\t\t\t\t\t\tvar ret = '';\n\n\t\t\t\t\t\tif (line.leftlines.length == 0) {\n\t\t\t\t\t\t\tvar emptyleft = Array(left.length + 1).fill([]);\n\n\t\t\t\t\t\t\tret += getHtmlLine(\n\t\t\t\t\t\t\t\t'', emptyleft, '', '', {bbb: true, rrb: true}\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tret += line.leftlines.map((line, i, a) => {\n\t\t\t\t\t\t\t\treturn getHtmlLine(\n\t\t\t\t\t\t\t\t\tline.ctr,\n\t\t\t\t\t\t\t\t\tnewleft,\n\t\t\t\t\t\t\t\t\texprToHtml(line.expr, true),\n\t\t\t\t\t\t\t\t\t'assumption',\n\t\t\t\t\t\t\t\t\t{bbb: i == a.length - 1, rrb: true}\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t}).join('');\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tret += tree2html(\n\t\t\t\t\t\t\tline.rightlines,\n\t\t\t\t\t\t\tnewleft\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\treturn ret;\n\t\t\t\t\tcase '?':\n\t\t\t\t\t\treturn getHtmlLine(\n\t\t\t\t\t\t\tline.ctr,\n\t\t\t\t\t\t\tleft,\n\t\t\t\t\t\t\texprToHtml(line.expr, true),\n\t\t\t\t\t\t\t'???'\n\t\t\t\t\t\t);\n\t\t\t\t\tcase 'H':\n\t\t\t\t\t\tthrow Error('no');\n\t\t\t\t\tcase 'R':\n\t\t\t\t\t\treturn getHtmlLine(\n\t\t\t\t\t\t\tline.ctr,\n\t\t\t\t\t\t\tleft,\n\t\t\t\t\t\t\texprToHtml(line.expr, true),\n\t\t\t\t\t\t\t[DIAMOND, exprToHtml(line.num)]\n\t\t\t\t\t\t);\n\t\t\t\t\tcase 'RS':\n\t\t\t\t\tcase 'RCX':\n\t\t\t\t\t\treturn getHtmlLine(\n\t\t\t\t\t\t\tline.ctr,\n\t\t\t\t\t\t\tleft,\n\t\t\t\t\t\t\texprToHtml(line.expr, true),\n\t\t\t\t\t\t\t[DIAMOND, exprToHtml(line.expr)]\n\t\t\t\t\t\t);\n\t\t\t\t\tcase 'RC':\n\t\t\t\t\t\treturn getHtmlLine(\n\t\t\t\t\t\t\tline.ctr,\n\t\t\t\t\t\t\tleft,\n\t\t\t\t\t\t\texprToHtml(line.expr, true),\n\t\t\t\t\t\t\t[DIAMOND, `${exprToHtml(line.schema)} (${line.args.map(a => exprToHtml(a)).join(', ')})`]\n\t\t\t\t\t\t);\n\t\t\t\t\tcase 'E':\n\t\t\t\t\t\treturn getHtmlLine(\n\t\t\t\t\t\t\tline.ctr,\n\t\t\t\t\t\t\tleft,\n\t\t\t\t\t\t\texprToHtml(line.reduced, true),\n\t\t\t\t\t\t\t[DOWN, `${exprToHtml(line.subject)}${line.args ? ' (' + line.args.map(a => exprToHtml(a)).join(', ') + ')' : ''} [${line.antecedents.map(a => exprToHtml(a)).join(', ')}]`]\n\t\t\t\t\t\t);\n\t\t\t\t\tcase 'NP':\n\t\t\t\t\t\treturn getHtmlLine(\n\t\t\t\t\t\t\tline.ctr,\n\t\t\t\t\t\t\tleft,\n\t\t\t\t\t\t\texprToHtml(line.expr, true),\n\t\t\t\t\t\t\t'<b class=\"red\">not proved</b>'\n\t\t\t\t\t\t);\n\t\t\t\t\tcase 'def':\n\t\t\t\t\t\treturn getHtmlLine(\n\t\t\t\t\t\t\tline.ctr,\n\t\t\t\t\t\t\tleft,\n\t\t\t\t\t\t\texprToHtml(line.var),\n\t\t\t\t\t\t\t'definition'\n\t\t\t\t\t\t);\n\t\t\t\t\tcase 'bydef':\n\t\t\t\t\t\treturn getHtmlLine(\n\t\t\t\t\t\t\tline.ctr,\n\t\t\t\t\t\t\tleft,\n\t\t\t\t\t\t\texprToHtml(line.expr),\n\t\t\t\t\t\t\t`by definition of ${line.of.map(v => {\n\t\t\t\t\t\t\t\treturn exprToHtml(v);\n\t\t\t\t\t\t\t}).join(', ')} [${exprToHtml(line.ref)}]`\n\t\t\t\t\t\t);\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tthrow Error(`Unknown type ${(line as any)._type}`);\n\t\t\t\t}\n\t\t\t}).join('');\n\t\t})(innertree, []);\n\t\t\n\t\thtml += '</table>';\n\t\n\t\treturn html;\n\t}\n}","export default class Counter {\n\n\tprivate n: number;\n\n\tconstructor (start: number=0) {\n\t\tthis.n = start;\n\t}\n\n\tpublic peek(): number {\n\t\treturn this.n;\n\t}\n\n\tpublic next(): number {\n\t\treturn ++this.n;\n\t}\n}","import $Variable from './nodes/$Variable';\nimport Fun from './nodes/Fun';\nimport Metaexpr from './nodes/Metaexpr';\nimport ObjectFun from './nodes/ObjectFun';\nimport ObjectType from './nodes/ObjectType';\nimport Schema from './nodes/Schema';\nimport Variable from './nodes/Variable';\nimport { LocationObject } from './PegInterfaceDefinitions';\nimport StackTrace from './StackTrace';\n\nexport type NestedTypeInput = string | NestedTypeInput[];\n\n/**\n *  (scope).\n *    name resolution    .\n */\nexport default class Scope {\n\tpublic readonly importMap: Map<string, Scope> = new Map();\n\n\tpublic readonly typedefMap: Map<string, ObjectType> = new Map();\n\tpublic readonly defMap: Map<string, Variable | ObjectFun> = new Map();\n\tpublic readonly schemaMap: Map<string, Schema> = new Map();\n\tpublic readonly $Map: Map<string, $Variable> = new Map();\n\tpublic readonly hypotheses: Metaexpr[] = [];\n\n\tpublic readonly parent: Scope;\n\tpublic readonly root: Scope;\n\n\tpublic readonly trace: StackTrace;\n\tpublic baseType: ObjectType;\n\n\tpublic readonly fileUri: string;\n\n\tconstructor (fileUri: string, parent: Scope, trace?: StackTrace) {\n\t\tthis.fileUri = fileUri;\n\n\t\tthis.parent = parent;\n\t\tthis.root = parent ? parent.root : this;\n\n\t\tif (trace && !(trace instanceof StackTrace)) {\n\t\t\tthrow Error('Assertion failed');\n\t\t}\n\n\t\tthis.trace = trace || new StackTrace(fileUri);\n\n\t\tthis.baseType = parent ? parent.baseType : null;\n\t}\n\n\tpublic extend(type: string, name: string, location: LocationObject): Scope {\n\t\tvar child = new Scope(this.fileUri, this, this.trace.extend({type, name, location}));\n\t\tthis.hypotheses.forEach(h => child.hypotheses.push(h));\n\t\treturn child;\n\t}\n\n\tpublic error(message: string): Error {\n\t\treturn this.trace.error(message);\n\t}\n\n\t/*\n\t * Possible input values:\n\t * 'st'\t\t\t\t\t\t-> st\n\t * ['cls', 'st']\t\t\t-> [cls -> st]\n\t * ['cls', 'cls', 'st']\t\t-> [(cls, cls) -> st]\n\t * [['cls', 'st'], 'st']\t-> [[cls -> st] -> st]\n\t */\n\tpublic hasOwnType(name: NestedTypeInput): boolean {\n\t\tif (typeof name == 'string') {\n\t\t\treturn this.typedefMap.has(name)\n\t\t\t\t|| [...this.importMap.values()].some(s => s.hasOwnType(name));\n\t\t}\n\n\t\tif (!(name instanceof Array))\n\t\t\tthrow this.error('Argument is malformed');\n\n\t\tif (name.length < 2)\n\t\t\tthrow this.error('Illegal array length');\n\n\t\treturn name.map(e => {\n\t\t\treturn this.hasOwnType(e);\n\t\t}).every(e => e);\n\t}\n\n\t/*\n\t * Possible input values:\n\t * 'st'\t\t\t\t\t\t-> st\n\t * ['cls', 'st']\t\t\t-> [cls -> st]\n\t * ['cls', 'cls', 'st']\t\t-> [(cls, cls) -> st]\n\t * [['cls', 'st'], 'st']\t-> [[cls -> st] -> st]\n\t */\n\tpublic hasType(name: NestedTypeInput): boolean {\n\t\tif (typeof name == 'string') {\n\t\t\treturn this.hasOwnType(name)\n\t\t\t\t|| (!!this.parent && this.parent.hasType(name));\n\t\t}\n\n\t\tif (!(name instanceof Array))\n\t\t\tthrow this.error('Argument is malformed');\n\n\t\tif (name.length < 2)\n\t\t\tthrow this.error('Illegal array length');\n\n\t\treturn name.map(e => {\n\t\t\treturn this.hasType(e);\n\t\t}).every(e => e);\n\t}\n\n\tpublic addType(type: ObjectType): ObjectType {\n\t\tif (!(type instanceof ObjectType))\n\t\t\tthrow this.error('Illegal argument type');\n\n\t\tif (!type.name)\n\t\t\tthrow this.error('Something\\'s wrong');\n\n\t\tif (this.hasOwnType(type.name))\n\t\t\tthrow this.error(`Type ${type.name} has already been declared`);\n\n\t\tif (type.isBaseType) {\n\t\t\tif (this.baseType) {\n\t\t\t\tthrow this.error('A base type already exists');\n\t\t\t}\n\n\t\t\t(function broadcast(scope: Scope) {\n\t\t\t\tscope.baseType = type;\n\t\t\t\tif (scope.parent) broadcast(scope.parent);\n\t\t\t})(this);\n\t\t}\n\n\t\tthis.typedefMap.set(type.name, type);\n\t\treturn type;\n\t}\n\n\t/*\n\t * Possible input values:\n\t * 'st'\t\t\t\t\t\t-> st\n\t * ['cls', 'st']\t\t\t-> [cls -> st]\n\t * ['cls', 'cls', 'st']\t\t-> [(cls, cls) -> st]\n\t * [['cls', 'st'], 'st']\t-> [[cls -> st] -> st]\n\t */\n\tpublic getType(name: NestedTypeInput): ObjectType {\n\t\tif (typeof name == 'string') {\n\t\t\tif (!this.hasType(name))\n\t\t\t\tthrow this.error(`Type ${name} is not defined`);\n\n\t\t\treturn this.typedefMap.has(name)\n\t\t\t\t? this.typedefMap.get(name)\n\t\t\t\t: (!!this.parent && this.parent.getType(name))\n\t\t\t\t\t|| [...this.importMap.values()].filter(s => {\n\t\t\t\t\t\treturn s.hasType(name)\n\t\t\t\t\t})[0].getType(name);\n\t\t}\n\n\t\tif (!(name instanceof Array))\n\t\t\tthrow this.error('Argument is malformed');\n\n\t\tif (name.length < 2)\n\t\t\tthrow this.error('Illegal array length');\n\n\t\tvar from = name.slice(0, name.length - 1).map(e => {\n\t\t\treturn this.getType(e);\n\t\t});\n\n\t\tvar to = this.getType(name[name.length - 1]);\n\n\t\treturn new ObjectType({\n\t\t\tfunctional: true,\n\t\t\tfrom,\n\t\t\tto\n\t\t});\n\t}\n\n\tpublic hasOwnVariable(name: string): boolean {\n\t\treturn this.defMap.has(name)\n\t\t\t|| [...this.importMap.values()].some(s => s.hasOwnVariable(name));\n\t}\n\n\tpublic hasVariable(name: string): boolean {\n\t\treturn this.hasOwnVariable(name)\n\t\t\t|| (!!this.parent && this.parent.hasVariable(name));\n\t}\n\n\tpublic addVariable(variable: Variable | Fun): Variable | Fun {\n\t\tif (!(variable instanceof Variable))\n\t\t\tthrow this.error('Illegal argument type');\n\n\t\tif (this.hasOwnVariable(variable.name))\n\t\t\tthrow this.error(`Definition ${variable.name} has already been declared`);\n\n\t\tthis.defMap.set(variable.name, variable);\n\t\treturn variable;\n\t}\n\n\tpublic addFun(fun: ObjectFun): ObjectFun {\n\t\tif (!(fun instanceof ObjectFun))\n\t\t\tthrow this.error('Illegal argument type');\n\n\t\tif (!fun.name)\n\t\t\tthrow this.error('Cannot add anonymous fun to scope');\n\n\t\tif (this.hasOwnVariable(fun.name))\n\t\t\tthrow this.error(`Definition ${fun.name} has already been declared`);\n\n\t\tthis.defMap.set(fun.name, fun);\n\t\treturn fun;\n\t}\n\n\tpublic getVariable(name: string): Variable | ObjectFun {\n\t\tif (!this.hasVariable(name))\n\t\t\tthrow this.error(`Definition ${name} is not defined`);\n\n\t\treturn this.defMap.has(name)\n\t\t\t? this.defMap.get(name)\n\t\t\t: (!!this.parent && this.parent.getVariable(name))\n\t\t\t\t|| [...this.importMap.values()].filter(s => {\n\t\t\t\t\treturn s.hasVariable(name)\n\t\t\t\t})[0].getVariable(name);\n\t}\n\n\tpublic hasOwnSchema(name: string): boolean {\n\t\treturn this.schemaMap.has(name) || this.defMap.has(name)\n\t\t\t|| [...this.importMap.values()].some(s => s.hasOwnSchema(name));\n\t}\n\n\tpublic hasSchema(name: string): boolean {\n\t\treturn this.hasOwnSchema(name)\n\t\t\t|| (!!this.parent && this.parent.hasSchema(name));\n\t}\n\n\tpublic addSchema(schema: Schema): Schema {\n\t\tif (!(schema instanceof Fun))\n\t\t\tthrow this.error('Illegal argument type');\n\n\t\tif (this.hasOwnSchema(schema.name))\n\t\t\tthrow this.error(`Schema ${schema.name} has already been declared`);\n\n\t\tthis.schemaMap.set(schema.name, schema);\n\t\treturn schema;\n\t}\n\n\tpublic getSchema(name: string): Variable | Fun {\n\t\tif (!this.hasSchema(name))\n\t\t\tthrow this.error(`Schema ${name} is not defined`);\n\n\t\treturn this.schemaMap.has(name)\n\t\t\t? this.schemaMap.get(name)\n\t\t\t: this.defMap.has(name)\n\t\t\t\t? this.defMap.get(name)\n\t\t\t\t: (!!this.parent && this.parent.getSchema(name))\n\t\t\t\t\t|| [...this.importMap.values()].filter(s => {\n\t\t\t\t\t\treturn s.hasSchema(name)\n\t\t\t\t\t})[0].getSchema(name);\n\t}\n\n\tpublic hasOwn$(name: string): boolean {\n\t\treturn this.$Map.has(name)\n\t\t\t|| [...this.importMap.values()].some(s => s.hasOwn$(name));\n\t}\n\n\tpublic has$(name: string): boolean {\n\t\treturn this.hasOwn$(name)\n\t\t\t|| (!!this.parent && this.parent.has$(name));\n\t}\n\n\tpublic add$($: $Variable): $Variable {\n\t\tif (!($ instanceof $Variable))\n\t\t\tthrow this.error('Illegal argument type');\n\n\t\tif (this.hasOwn$($.name))\n\t\t\tthrow this.error(`$ variable ${$.name} has already been declared`);\n\n\t\tthis.$Map.set($.name, $);\n\t\treturn $;\n\t}\n\n\tpublic get$(name: string): $Variable {\n\t\tif (!this.has$(name))\n\t\t\tthrow this.error(`$ variable ${name} is not defined`);\n\n\t\treturn this.$Map.has(name)\n\t\t\t? this.$Map.get(name)\n\t\t\t: (!!this.parent && this.parent.get$(name))\n\t\t\t\t|| [...this.importMap.values()].filter(s => {\n\t\t\t\t\treturn s.has$(name)\n\t\t\t\t})[0].get$(name);\n\t}\n}","import { LocationObject } from \"./PegInterfaceDefinitions\";\n\ninterface StackTraceElement {\n\ttype: string;\n\tname: string;\n\tlocation: LocationObject;\n}\n\nexport default class StackTrace {\n\n\tpublic readonly fileUri: string;\n\tpublic readonly stack: StackTraceElement[];\n\n\tconstructor (fileUri: string, stack?: StackTraceElement[]) {\n\t\tthis.fileUri = fileUri;\n\t\tthis.stack = stack || [];\n\t}\n\n\tpublic extend(element: StackTraceElement): StackTrace {\n\t\treturn new StackTrace(this.fileUri, [element].concat(this.stack));\n\t}\n\n\tpublic error(message: string) {\n\t\tvar fileUri = this.fileUri || '<unknown>';\n\n\t\treturn new Error(\n\t\t\tmessage\n\t\t\t+ '\\n\\tat '\n\t\t\t+ (\n\t\t\t\tthis.stack.length\n\t\t\t\t\t? this.stack.map(({type, name, location}) => {\n\t\t\t\t\t\treturn `${type} ${name || '<anonymous>'} (${fileUri}:${location.start.line}:${location.start.column})`;\n\t\t\t\t\t}).join('\\n\\tat ')\n\t\t\t\t\t: `<root> (${fileUri}:1:1)`\n\t\t\t)\n\t\t);\n\t}\n}"],"sourceRoot":""}