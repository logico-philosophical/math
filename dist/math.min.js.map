{"version":3,"sources":["webpack://math/webpack/universalModuleDefinition","webpack://math/webpack/bootstrap","webpack://math/./src/exprs/Expr.ts","webpack://math/./src/exprs/types.ts","webpack://math/./src/exprs/Fun.ts","webpack://math/./src/exprs/Schema.ts","webpack://math/./src/exprs/Variable.ts","webpack://math/./src/exprs/$Variable.ts","webpack://math/./src/exprs/Parameter.ts","webpack://math/./src/exprs/Funcall.ts","webpack://math/./src/exprs/Expr0.ts","webpack://math/./src/exprs/ObjectFun.ts","webpack://math/./src/ExecutionContext.ts","webpack://math/./src/UniversalCounter.ts","webpack://math/./src/exprs/Nameable.ts","webpack://math/./src/exprs/Tee.ts","webpack://math/./src/entry.js","webpack://math/./src/grammar.pegjs","webpack://math/./src/Program.ts","webpack://math/./src/PegInterface.ts","webpack://math/./src/exprs/Reduction.ts","webpack://math/./src/exprs/With.ts","webpack://math/./src/ProofExplorer.ts","webpack://math/./src/Counter.ts","webpack://math/./src/Scope.ts","webpack://math/./src/StackTrace.ts"],"names":["webpackUniversalModuleDefinition","root","factory","exports","module","define","amd","self","this","installedModules","__webpack_require__","moduleId","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","getDefault","getModuleExports","object","property","prototype","hasOwnProperty","p","s","EqualsPriority","Expr","doc","tex","type","trace","_id","next","error","andFuncalls","expandMetaCache","expandMetaInternal","obj","context","equals","getEqualsPriority","equalsInternal","hypotheses","length","isProvedInternal","hypnumMap","$Map","ctr","has","_type","num","expr","getProofInternal","toIndentedString","message","Error","prec","Array","console","log","my","normalizePrecedence","precedence","your","replace","code","match","g1","regex","RegExp","join","capitalize","charCodeAt","commandName","toLowerCase","toUpperCase","substring","escapeTeX","id","args","ret","shouldConsolidate","_match","PREC_FUNEXPR","PREC_COMMA","PREC_COLONEQQ","Type","TeeType","left","right","SimpleObjectType","FunctionalObjectType","FunctionalMetaType","from","to","super","indent","ObjectType","resolve","toTeXString","isFunctional","map","f","e","Fun","annotations","sealed","rettype","params","parsed","parseTeX","variable","isProved","ONE","placeholders","types","push","selector","usedMacrosList","thisCall","fun","objCall","concat","Map","set","substitute","start","peek","$lines","def$s","forEach","$","lines","getProof","$num","Schema","schemaType","isProvedCache","some","expandMeta","_context","repeat","proved","toTeXStringWithId","Variable","canUse","ZERO","FOUR","tmp","toString","makeTeXName","$Variable","FIVE","Parameter","Funcall","isNameable","resolvedType","paramTypes","argTypes","arg","callee","isExpandable","isCallable","used","expanded","calleeExpanded","expandOnce","THREE","T","q","thisIsExpandable","objIsExpandable","every","_","schema","schemalines","funcallToTeXString","Expr0","ObjectFun","makeTeX","ExecutionContext","usingList","includes","Tee","lef","TWO","leftlines","rightlines","flat","grammar","default","Program","parser","scopeMap","filename","loader","loadingModules","scope","loadModuleInternal","loadingModuleIndex","indexOf","cycle","slice","fileUri","parse","feed","pop","line","scope2","importMap","hasType","addType","hasVariable","addVariable","addFun","hasSchema","addSchema","tee","reduction","schemacall","metavar","ktx","typeObjToString","ftype","typeObjToNestedArr","varObjToString","PI","parentScope","extend","location","getType","getVariable","expr0","isParam","tvo","tv","hasOwnVariable","with","funcall","hypnum","Number","has$","get$","getSchema","$v","def$","hasOwn$","add$","scopeRight","oldContext","using","subject","g","antecedents","as","Reduction","derefs","guess","antecedentTypes","requiredAntecedents","antecedentEqualsResults","fill","antecedentsExpanded","preFormatConsequent","rightEqualsResult","consequent","antecedentLinesList","antecedentNums","ref","of","subjectlines","subjectnum","reduced","pattern","instance","recurse","ptr","test","With","var","ProofExplorer","DIAMOND","getHtmlLine","h1","h2","options","padding","bbb","rrb","htmlLeft","a","ncols","exprToHtml","expand","tree","innertree","Math","max","html","tree2html","newleft","v","Counter","Scope","parent","typedefMap","defMap","schemaMap","child","h","values","hasOwnType","filter","hasOwnSchema","StackTrace","stack","element","column"],"mappings":"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","file":"math.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"math\"] = factory();\n\telse\n\t\troot[\"math\"] = factory();\n})(typeof self !== 'undefined' ? self : this, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 14);\n","import Counter from \"../Counter\";\nimport ExecutionContext from \"../ExecutionContext\";\nimport { ProofType } from \"../ProofType\";\nimport StackTrace from \"../StackTrace\";\nimport UniversalCounter from \"../UniversalCounter\";\nimport Expr0 from \"./Expr0\";\nimport Fun from \"./Fun\";\nimport { Type } from \"./types\";\nimport Variable from \"./Variable\";\n\n/**\n * 숫자가 큰 것이 우선순위가 높다.\n */\nexport enum EqualsPriority {\n\t/** Variable (primitive) */\n\tZERO,\n\t/** Fun */\n\tONE,\n\t/** Tee */\n\tTWO,\n\t/** Funcall */\n\tTHREE,\n\t/** Variable (macro) */\n\tFOUR,\n\t/** $Variable, Reduction */\n\tFIVE\n}\n\nexport type Precedence = boolean | number | [number, number];\n\nexport default abstract class Expr {\n\t\n\tpublic readonly _id: number;\n\n\tpublic readonly doc: string;\n\tpublic readonly tex: string;\n\tpublic readonly trace: StackTrace;\n\tpublic precedence: Precedence;\n\n\tpublic readonly type: Type;\n\tprivate expandMetaCache: Expr;\n\n\tpublic static readonly PREC_FUNEXPR = 1000;\n\tpublic static readonly PREC_COMMA = 1000;\n\tpublic static readonly PREC_COLONEQQ = 100000;\n\n\tconstructor (doc: string, tex: string, type: Type, trace: StackTrace) {\n\t\tthis._id = UniversalCounter.next();\n\t\tthis.doc = doc;\n\t\tthis.tex = tex;\n\t\tthis.trace = trace;\n\n\t\tif (!type) throw Expr.error('Assertion failed', trace);\n\n\t\tthis.type = type;\n\t}\n\n\tpublic abstract substitute(map: Map<Variable, Expr0>): Expr;\n\n\t/**\n\t * \n\t * @param andFuncalls 이름 없는 Funcall도 푼다.\n\t */\n\tpublic expandMeta(andFuncalls: boolean): Expr {\n\t\tif (this.expandMetaCache) return this.expandMetaCache;\n\t\treturn this.expandMetaCache = this.expandMetaInternal(andFuncalls);\n\t}\n\n\tprotected abstract expandMetaInternal(andFuncalls: boolean): Expr;\n\n\t/**\n\t * \n\t * @return 같지 않으면 `false`. 같으면 같음을 보이는 데 사용한 매크로들의 목록.\n\t */\n\tpublic equals(obj: Expr, context: ExecutionContext): (Fun | Variable)[] | false {\n\t\t// console.log(`${this}\\n\\n${obj}`);\n\t\t// var ret = (() => {\n\t\t\n\t\tif (this === obj) return [];\n\t\tif (!this.type.equals(obj.type)) return false;\n\n\t\tif (obj.getEqualsPriority(context) > this.getEqualsPriority(context))\n\t\t\treturn obj.equalsInternal(this, context);\n\t\t\n\t\treturn this.equalsInternal(obj, context);\n\n\t\t// })();\n\t\t// console.log(`${this}\\n\\n${obj}\\n\\nresult:`, ret);\n\t\t// return ret;\n\t}\n\n\t/**\n\t * \n\t * @return 같지 않으면 `false`. 같으면 같음을 보이는 데 사용한 매크로들의 목록.\n\t */\n\tprotected abstract equalsInternal(obj: Expr, context: ExecutionContext): (Fun | Variable)[] | false;\n\n\tprotected abstract getEqualsPriority(context: ExecutionContext): EqualsPriority;\n\n\tpublic isProved(hypotheses?: Expr[]): boolean {\n\t\thypotheses = hypotheses || [];\n\n\t\tfor (var i = 0; i < hypotheses.length; i++) {\n\t\t\tif (hypotheses[i] == this) return true;\n\t\t}\n\n\t\treturn this.isProvedInternal(hypotheses);\n\t}\n\n\tprotected abstract isProvedInternal(hypotheses: Expr[]): boolean;\n\n\tpublic getProof(\n\t\t\thypnumMap: Map<Expr, number>,\n\t\t\t$Map: Map<Expr, number | [number, number]>,\n\t\t\tctr: Counter,\n\t\t\troot: boolean=false): ProofType[] {\n\t\t\n\t\tif (hypnumMap.has(this)) {\n\t\t\treturn [{\n\t\t\t\t_type: 'R',\n\t\t\t\tctr: ctr.next(),\n\t\t\t\tnum: hypnumMap.get(this),\n\t\t\t\texpr: this\n\t\t\t}];\n\t\t}\n\n\t\tif ($Map.has(this)) {\n\t\t\treturn [{\n\t\t\t\t_type: 'R',\n\t\t\t\tctr: ctr.next(),\n\t\t\t\tnum: $Map.get(this),\n\t\t\t\texpr: this\n\t\t\t}];\n\t\t}\n\n\t\treturn this.getProofInternal(hypnumMap, $Map, ctr, root);\n\t}\n\n\tprotected abstract getProofInternal(\n\t\t\thypnumMap: Map<Expr, number>,\n\t\t\t$Map: Map<Expr, number | [number, number]>,\n\t\t\tctr: Counter,\n\t\t\troot?: boolean): ProofType[];\n\t\n\tpublic toString() {\n\t\treturn this.toIndentedString(0);\n\t}\n\n\tpublic abstract toIndentedString(indent: number, root?: boolean): string;\n\tpublic abstract toTeXString(prec?: Precedence, root?: boolean): string;\n\n\tpublic error(message: string) {\n\t\treturn Expr.error(message, this.trace);\n\t}\n\n\tpublic static error(message: string, trace: StackTrace) {\n\t\tif (trace) {\n\t\t\treturn trace.error(message);\n\t\t} else {\n\t\t\treturn new Error(message);\n\t\t}\n\t}\n\n\t/*\n\t* false corresponds to 0.\n\t* true corresponds to w * 2.\n\t*/\n\tpublic static normalizePrecedence(prec: Precedence) {\n\t\tif (prec === false) return [0, 0];\n\t\tif (prec === true) return [2, 0];\n\t\tif (typeof prec == 'number') return [0, prec];\n\n\t\tif (!(prec instanceof Array && prec.length == 2)) {\n\t\t\tconsole.log(prec);\n\t\t\tthrow Error('wut');\n\t\t}\n\n\t\treturn prec;\n\t}\n\n\tpublic shouldConsolidate(prec: Precedence): boolean {\n\t\tvar my = Expr.normalizePrecedence(this.precedence || false),\n\t\t\tyour = Expr.normalizePrecedence(prec || false);\n\n\t\tif (my[0] == 0 && my[1] == 0) return false;\n\n\t\treturn !(my[0] < your[0] || my[0] == your[0] && my[1] < your[1]);\n\t}\n\n\tpublic static escapeTeX(s: string): string {\n\t\treturn s.replace(/&|%|\\$|#|_|{|}|~|\\^|\\\\/g, m => ({\n\t\t\t'&': '\\\\&', '%': '\\\\%', '$': '\\\\$',\n\t\t\t'#': '\\\\#', '_': '\\\\_', '{': '\\\\{',\n\t\t\t'}': '\\\\}',\n\t\t\t'~': '\\\\textasciitilde',\n\t\t\t'^': '\\\\textasciicircum',\n\t\t\t'\\\\': '\\\\textbackslash'\n\t\t})[m]);\n\t}\n\n\tpublic static parseTeX(tex: string) {\n\t\tvar precedence: Precedence = false;\n\n\t\tvar code = tex.replace(/^!<prec=([0-9]+)>/, (match, g1) => {\n\t\t\tprecedence = g1 * 1;\n\t\t\treturn '';\n\t\t});\n\n\t\treturn {precedence, code};\n\t}\n\n\tpublic static makeTeXName(name: string): string {\n\t\tvar alphabet = [\n\t\t\t\"alpha\", \"beta\", \"gamma\", \"delta\",\n\t\t\t\"epsilon\", \"zeta\", \"eta\", \"theta\",\n\t\t\t\"iota\", \"kappa\", \"lambda\", \"mu\",\n\t\t\t\"nu\", \"xi\", \"omicron\", \"pi\",\n\t\t\t\"rho\", \"sigma\", \"tau\", \"upsilon\",\n\t\t\t\"phi\", \"chi\", \"psi\", \"omega\"\n\t\t];\n\n\t\tvar regex = new RegExp(`^(?:([a-z])|(${alphabet.join('|')}))([0-9]*)$`, 'i');\n\t\tvar match = name.match(regex);\n\n\t\tif (match) {\n\t\t\tvar letter = (() => {\n\t\t\t\tif (match[1]) return match[1];\n\t\t\t\t\n\t\t\t\tvar capitalize = match[2].charCodeAt(0) <= 'Z'.charCodeAt(0);\n\t\t\t\tvar commandName = match[2].toLowerCase();\n\n\t\t\t\tif (capitalize) {\n\t\t\t\t\tcommandName = commandName[0].toUpperCase() + commandName.substring(1);\n\t\t\t\t}\n\n\t\t\t\treturn '\\\\' + commandName;\n\t\t\t})();\n\n\t\t\tvar subscript = (() => {\n\t\t\t\tif (!match[3]) return '';\n\t\t\t\tif (match[3].length == 1) return '_' + match[3];\n\t\t\t\treturn `_{${match[3]}}`;\n\t\t\t})();\n\n\t\t\treturn letter + subscript;\n\t\t}\n\n\t\tif (name.length == 1) {\n\t\t\treturn Expr.escapeTeX(name);\n\t\t}\n\n\t\treturn `\\\\mathrm{${Expr.escapeTeX(name)}}`;\n\t}\n\n\tpublic makeTeX(id, args, prec) {\n\t\targs = args || [];\n\t\tprec = prec || false;\n\t\t\n\t\tvar ret = this.tex;\n\n\t\tif (this.shouldConsolidate(prec)) {\n\t\t\tret = '\\\\left(' + ret + '\\\\right)';\n\t\t}\n\n\t\treturn ret.replace(/#([0-9]+)/g, (match, g1) => {\n\t\t\treturn args[g1 * 1 - 1] || `\\\\texttt{\\\\textcolor{red}{\\\\#${g1}}}`;\n\t\t}).replace(/<<(.+?)>>/, (_match, g1) => {\n\t\t\treturn `\\\\href{#${id}}{${g1}}`;\n\t\t});\n\t}\n}","import StackTrace from \"../StackTrace\";\nimport UniversalCounter from \"../UniversalCounter\";\nimport Nameable from \"./Nameable\";\n\nexport abstract class Type {\n\n\tpublic readonly _id: number;\n\tpublic readonly trace: StackTrace;\n\tpublic readonly doc: string;\n\n\tconstructor (doc: string, trace: StackTrace) {\n\t\tthis._id = UniversalCounter.next();\n\t\tthis.doc = doc;\n\t\tthis.trace = trace;\n\t}\n\n\tpublic abstract resolve(): Type;\n\n\tpublic toString() {\n\t\treturn this.toIndentedString(0);\n\t}\n\n\tpublic abstract toIndentedString(indent: number): string;\n\n\tpublic abstract isFunctional(): boolean;\n\n\tpublic equals(t: Type): boolean {\n\t\tif (this === t) return true;\n\n\t\tif (!(t instanceof Type)) return false;\n\n\t\tif ((this instanceof TeeType) != (t instanceof TeeType)) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (this instanceof TeeType && t instanceof TeeType) {\n\t\t\tif (this.left.length != t.left.length) return false;\n\n\t\t\tfor (var i = 0; i < this.left.length; i++) {\n\t\t\t\tif (!this.left[i].equals(t.left[i])) return false;\n\t\t\t}\n\n\t\t\treturn this.right.equals(t.right);\n\t\t}\n\n\t\tif (this instanceof SimpleObjectType && this.expr) {\n\t\t\treturn this.expr.equals(t);\n\t\t}\n\n\t\tif (t instanceof SimpleObjectType && t.expr) {\n\t\t\treturn this.equals(t.expr);\n\t\t}\n\n\t\tif (this instanceof SimpleObjectType || t instanceof SimpleObjectType) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif ((this instanceof FunctionalObjectType || this instanceof FunctionalMetaType)\n\t\t\t\t&& (t instanceof FunctionalObjectType || t instanceof FunctionalMetaType)) {\n\t\t\tif (this.from.length != t.from.length) return false;\n\n\t\t\tfor (var i = 0; i < this.from.length; i++) {\n\t\t\t\tif (!this.from[i].equals(t.from[i])) return false;\n\t\t\t}\n\n\t\t\treturn this.to.equals(t.to);\n\t\t}\n\n\t\tthrow Error('Unknown type format');\n\t}\n}\n\ninterface TeeTypeArgumentType {\n\tleft: Type[];\n\tright: Type;\n}\n\nexport class TeeType extends Type {\n\n\tpublic readonly left: Type[];\n\tpublic readonly right: Type;\n\n\tconstructor ({left, right}: TeeTypeArgumentType, trace: StackTrace) {\n\t\tsuper(null, trace);\n\n\t\tif (!left || !right) {\n\t\t\tthrow Error('duh');\n\t\t}\n\n\t\tthis.left = left;\n\t\tthis.right = right;\n\t}\n\n\tpublic toIndentedString(indent: number): string {\n\t\treturn `[${this.left.join(', ')} |- ${this.right}]`;\n\t}\n\n\tpublic resolve(): Type {\n\t\treturn this;\n\t}\n\n\tpublic isFunctional(): boolean {\n\t\treturn false;\n\t}\n}\n\ninterface FunctionalMetaTypeArgumentType {\n\tfrom: ObjectType[];\n\tto: Type;\n}\n\nexport class FunctionalMetaType extends Type {\n\t\n\tpublic readonly from: ObjectType[];\n\tpublic readonly to: Type;\n\n\tconstructor ({from, to}: FunctionalMetaTypeArgumentType, trace: StackTrace) {\n\t\tsuper(null, trace);\n\n\t\tif (!from || !to) {\n\t\t\tthrow Error('duh');\n\t\t}\n\n\t\tthis.from = from;\n\t\tthis.to = to;\n\t}\n\n\tpublic toIndentedString(indent: number): string {\n\t\treturn `[${this.from.join(', ')} -> ${this.to}]`;\n\t}\n\n\tpublic resolve(): FunctionalMetaType {\n\t\treturn this;\n\t}\n\n\tpublic isFunctional(): boolean {\n\t\treturn true;\n\t}\n}\n\nexport abstract class ObjectType extends Type {\n\n\tconstructor (doc: string, trace: StackTrace) {\n\t\tsuper(doc, trace);\n\t}\n\n\tpublic abstract resolve(): ObjectType;\n\n\tpublic abstract toTeXString(root?: boolean): string;\n}\n\ninterface SimpleObjectTypeArgumentType {\n\tdoc: string;\n\tname: string;\n\texpr: ObjectType;\n}\n\nexport class SimpleObjectType extends ObjectType implements Nameable {\n\n\tpublic readonly name: string;\n\tpublic readonly expr: ObjectType;\n\n\tconstructor ({doc, name, expr}: SimpleObjectTypeArgumentType, trace: StackTrace) {\n\t\tsuper(doc, trace);\n\n\t\tif (!name) throw Error('duh');\n\n\t\tthis.name = name;\n\t\tthis.expr = expr;\n\t}\n\n\tpublic resolve(): ObjectType {\n\t\treturn this.expr ? this.expr.resolve() : this;\n\t}\n\n\tpublic toIndentedString(indent: number): string {\n\t\treturn this.name;\n\t}\n\n\tpublic toTeXString(root?: boolean): string {\n\t\tvar name = `\\\\href{#type-${this.name}}{\\\\mathsf{${this.name}}}`;\n\n\t\tif (root && this.expr) {\n\t\t\treturn name + `\\\\coloneqq${this.expr.toTeXString()}`;\n\t\t}\n\n\t\treturn name;\n\t}\n\n\tpublic isFunctional(): boolean {\n\t\tif (this.expr) return this.expr.isFunctional();\n\n\t\treturn false;\n\t}\n}\n\ninterface FunctionalObjectTypeArgumentType {\n\tfrom: ObjectType[];\n\tto: ObjectType;\n}\n\nexport class FunctionalObjectType extends ObjectType {\n\n\tpublic readonly from: ObjectType[];\n\tpublic readonly to: ObjectType;\n\n\tconstructor ({from, to}: FunctionalObjectTypeArgumentType, trace: StackTrace) {\n\t\tsuper(null, trace);\n\n\t\tthis.from = from;\n\t\tthis.to = to;\n\t}\n\n\tpublic resolve(): FunctionalObjectType {\n\t\treturn new FunctionalObjectType({\n\t\t\tfrom: this.from.map(f => f.resolve()),\n\t\t\tto: this.to.resolve()\n\t\t}, this.trace);\n\t}\n\n\tpublic toIndentedString(indent: number): string {\n\t\treturn `[${this.from.join(', ')} -> ${this.to}]`;\n\t}\n\n\tpublic toTeXString(root?: boolean): string {\n\t\treturn `\\\\left[${this.from.map(e => e.toTeXString()).join('\\\\times ')}`\n\t\t\t+ ` \\\\to ${this.to.toTeXString()}\\\\right]`;\n\t}\n\n\tpublic isFunctional(): boolean {\n\t\treturn true;\n\t}\n}","import Expr0 from './Expr0';\nimport Nameable from './Nameable';\n\nexport default abstract class Fun extends Expr0 implements Nameable {\n\n\tpublic readonly annotations: string[];\n\tpublic readonly sealed: boolean;\n\tpublic readonly name: string;\n\tpublic readonly params: Parameter[];\n\tpublic readonly expr: Expr;\n\n\tconstructor ({doc, tex, annotations, sealed, rettype, name, params, expr}: FunArgumentType, trace: StackTrace) {\n\t\tif (!name && !expr)\n\t\t\tthrow Expr.error('Anonymous fun cannot be primitive', trace);\n\n\t\tif (rettype && expr) {\n\t\t\tif (!rettype.equals(expr.type)) {\n\t\t\t\tthrow Expr.error(`Expression type ${expr.type} failed to match the return type ${rettype} of fun ${name}`, trace);\n\t\t\t}\n\t\t}\n\n\t\tif (!rettype && !expr) {\n\t\t\tthrow Expr.error('Cannot guess the return type of a primitive fun', trace);\n\t\t}\n\t\t\n\t\tif (sealed && !expr) {\n\t\t\tthrow Expr.error('Cannot seal a primitive fun', trace);\n\t\t}\n\t\t\n\t\tvar precedence = false;\n\n\t\tif (tex) {\n\t\t\tvar parsed = Expr.parseTeX(tex);\n\t\t\tprecedence = parsed.precedence;\n\t\t\ttex = parsed.code;\n\t\t} else {\n\t\t\ttex = null;\n\t\t}\n\t\t\n\t\tsuper(\n\t\t\tdoc, tex,\n\t\t\tnew ((rettype || expr.type) instanceof ObjectType ? FunctionalObjectType : FunctionalMetaType)({\n\t\t\t\tfrom: params.map(variable => variable.type),\n\t\t\t\tto: rettype || expr.type as any\n\t\t\t}, trace),\n\t\t\ttrace\n\t\t);\n\n\t\tthis.annotations = annotations;\n\t\tthis.sealed = sealed;\n\t\tthis.precedence = precedence;\n\t\tthis.name = name;\n\t\tthis.params = params;\n\t\tthis.expr = expr;\n\t}\n\n\t/**\n\t * 매개변수의 개수.\n\t */\n\tget length(): number {\n\t\treturn this.params.length;\n\t}\n\n\tprotected isProvedInternal(hypotheses: Expr[]): boolean {\n\t\treturn this.expr && this.expr.isProved(hypotheses);\n\t}\n\n\tprotected getEqualsPriority(): EqualsPriority {\n\t\treturn EqualsPriority.ONE;\n\t}\n\t\n\tprotected equalsInternal(obj: Expr, context: ExecutionContext): (Fun | Variable)[] | false {\n\t\tif (!(this.expr && !this.sealed)\n\t\t\t\t&& !(obj instanceof Fun && obj.expr && !obj.sealed)) {\n\t\t\treturn false;\n\t\t}\n\n\t\tvar placeholders = [];\n\t\tvar types = (this.type.resolve() as FunctionalObjectType | FunctionalMetaType).from;\n\n\t\tfor (var i = 0; i < types.length; i++) {\n\t\t\tplaceholders.push(new Parameter({\n\t\t\t\ttype: types[i],\n\t\t\t\tname: '$' + i,\n\t\t\t\tselector: null\n\t\t\t}, this.trace));\n\t\t}\n\n\t\tvar usedMacrosList = [];\n\n\t\tvar thisCall = this.expr && !this.sealed\n\t\t\t? (this.name && usedMacrosList.push(this), this.call(placeholders))\n\t\t\t: new Funcall({\n\t\t\t\tfun: this,\n\t\t\t\targs: placeholders\n\t\t\t}, this.trace);\n\n\t\tvar objCall = obj instanceof Fun && obj.expr && !obj.sealed\n\t\t\t? (obj.name && usedMacrosList.push(obj), obj.call(placeholders))\n\t\t\t: new Funcall({\n\t\t\t\tfun: obj,\n\t\t\t\targs: placeholders\n\t\t\t}, this.trace);\n\t\t\n\t\tvar ret = thisCall.equals(objCall, context);\n\t\treturn ret && ret.concat(usedMacrosList);\n\t}\n\n\tpublic abstract isCallable(context: ExecutionContext): boolean;\n\n\tpublic call(args: Expr0[]): Expr {\n\t\tif (!this.expr) {\n\t\t\tthrow Error('Cannot call a primitive fun');\n\t\t}\n\n\t\tif (this.params.length != args.length) {\n\t\t\tthrow Error('Arguments length mismatch');\n\t\t}\n\n\t\tfor (var i = 0; i < this.params.length; i++) {\n\t\t\tif (!this.params[i].type.equals(args[i].type)) {\n\t\t\t\tthrow Error('Illegal type');\n\t\t\t}\n\t\t}\n\n\t\tvar map: Map<Variable, Expr0> = new Map();\n\n\t\tfor (var i = 0; i < this.params.length; i++) {\n\t\t\tmap.set(this.params[i], args[i]);\n\t\t}\n\n\t\treturn this.expr.substitute(map);\n\t}\n\n\tprotected getProofInternal(\n\t\t\thypnumMap: Map<Expr, number>,\n\t\t\t$Map: Map<Expr, number | [number, number]>,\n\t\t\tctr: Counter,\n\t\t\troot: boolean=false): ProofType[] {\n\t\t\n\t\tif (this instanceof Schema && this.name && !root) {\n\t\t\treturn [{\n\t\t\t\t_type: 'RS',\n\t\t\t\tctr: ctr.next(),\n\t\t\t\texpr: this\n\t\t\t}];\n\t\t}\n\n\t\tif (!this.expr) {\n\t\t\treturn [{\n\t\t\t\t_type: 'NP',\n\t\t\t\tctr: ctr.next(),\n\t\t\t\texpr: this\n\t\t\t}];\n\t\t}\n\n\t\t$Map = new Map($Map);\n\n\t\tvar start = ctr.peek() + 1;\n\n\t\tvar $lines: ProofType[] = [];\n\t\t\n\t\tif (this instanceof Schema) {\n\t\t\tthis.def$s.forEach($ => {\n\t\t\t\tvar lines = $.expr.getProof(hypnumMap, $Map, ctr);\n\t\t\t\t$lines = $lines.concat(lines);\n\n\t\t\t\tvar $num = lines[lines.length - 1].ctr;\n\t\t\t\t$Map.set($, $num);\n\t\t\t});\n\t\t}\n\n\t\treturn [{\n\t\t\t_type: 'V',\n\t\t\t$lines,\n\t\t\tlines: this.expr.getProof(hypnumMap, $Map, ctr),\n\t\t\tparams: this.params,\n\t\t\tctr: [start, ctr.peek()]\n\t\t}];\n\t}\n}\n\nimport Funcall from './Funcall';\nimport Expr, { EqualsPriority } from './Expr';\nimport Variable from './Variable';\nimport StackTrace from '../StackTrace';\nimport ExecutionContext from '../ExecutionContext';\nimport Counter from '../Counter';\nimport { ProofType } from '../ProofType';\nimport Schema from './Schema';\nimport Parameter from './Parameter';\nimport { ObjectType, FunctionalObjectType, FunctionalMetaType, Type } from './types';\n\ninterface FunArgumentType {\n\tdoc: string;\n\ttex: string;\n\tannotations: string[];\n\tsealed: boolean;\n\trettype: Type;\n\tname: string;\n\tparams: Parameter[];\n\texpr: Expr;\n}","import Fun from \"./Fun\";\n\nexport type SchemaType = 'axiom' | 'theorem' | 'schema';\n\nexport default class Schema extends Fun {\n\n\tpublic readonly schemaType: SchemaType;\n\tpublic readonly using: ObjectFun[];\n\tpublic readonly def$s: $Variable[];\n\tpublic readonly context: ExecutionContext;\n\tprivate isProvedCache: boolean;\n\n\tconstructor ({doc, tex, annotations, schemaType, name, params, context, def$s, expr}: SchemaArgumentType, trace: StackTrace) {\n\t\tif (!expr) {\n\t\t\tthrow Expr.error('wut', trace);\n\t\t}\n\n\t\tif (schemaType != 'schema' && !name) {\n\t\t\tthrow Expr.error(`wut`, trace);\n\t\t}\n\n\t\tsuper({doc, tex, annotations, sealed: false, rettype: null, name, params, expr}, trace);\n\t\t\n\t\tthis.schemaType = schemaType;\n\t\tthis.def$s = def$s || [];\n\t\tthis.context = context;\n\n\t\tif (schemaType == 'theorem') {\n\t\t\tif (!this.isProved()) {\n\t\t\t\tthrow Expr.error(`Schema ${name} is marked as a theorem but it is not proved`, trace);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tprotected isProvedInternal(hypotheses: Expr[]): boolean {\n\t\tif (this.isProvedCache) return true;\n\n\t\tif (hypotheses.length == 0 && typeof this.isProvedCache == 'boolean') {\n\t\t\treturn this.isProvedCache;\n\t\t}\n\n\t\tvar ret = this.schemaType == 'axiom' || this.expr.isProved(hypotheses);\n\t\tif (!hypotheses.length) this.isProvedCache = ret;\n\t\treturn ret;\n\t}\n\n\tpublic substitute(map: Map<Variable, Expr0>): Expr {\n\t\tif (!this.expr) return this;\n\n\t\t// 이름이 있는 것은 스코프 밖에서 보이지 않으므로 치환될 것을\n\t\t// 갖지 않는다는 생각이 들어 있다.\n\t\tif (this.name) return this;\n\n\t\t// 위의 this.name 조건을 지우면 특수한 경우에 이게 발생할지도 모른다.\n\t\tif (this.params.some(e => map.has(e)))\n\t\t\tthrow Error('Parameter collision');\n\n\t\treturn new Schema({\n\t\t\tdoc: null,\n\t\t\ttex: null,\n\t\t\tannotations: this.annotations,\n\t\t\tschemaType: 'schema',\n\t\t\tname: null,\n\t\t\tparams: this.params,\n\t\t\tcontext: this.context,\n\t\t\tdef$s: this.def$s,\n\t\t\texpr: this.expr.substitute(map)\n\t\t}, this.trace);\n\t}\n\n\tprotected expandMetaInternal(andFuncalls: boolean): Expr {\n\t\tif (!this.expr) return this;\n\t\tif (this.type instanceof ObjectType && this.name) return this;\n\n\t\treturn new Schema({\n\t\t\tdoc: null,\n\t\t\ttex: null,\n\t\t\tannotations: this.annotations,\n\t\t\tschemaType: 'schema',\n\t\t\tname: null,\n\t\t\tparams: this.params,\n\t\t\tcontext: this.context,\n\t\t\tdef$s: this.def$s,\n\t\t\texpr: this.expr.expandMeta(andFuncalls)\n\t\t}, this.trace);\n\t}\n\n\tpublic isCallable(_context: ExecutionContext): boolean {\n\t\treturn true;\n\t}\n\n\tpublic toIndentedString(indent: number, root?: boolean): string {\n\t\treturn [\n\t\t\t`∫ ${this.name || ''}(${this.params.map(p => p.toIndentedString(indent)).join(', ')}) => {`,\n\t\t\t'\\t' + this.expr.expandMeta(true).toIndentedString(indent + 1),\n\t\t\t'}'\n\t\t].join('\\n' + '\\t'.repeat(indent));\n\t}\n\t\n\tpublic toTeXString(prec?: Precedence, root?: boolean): string {\n\t\tif (!this.name) {\n\t\t\tthis.precedence = Expr.PREC_FUNEXPR;\n\t\t\treturn [\n\t\t\t\t(this.shouldConsolidate(prec) ? '\\\\left(' : ''),\n\n\t\t\t\t(\n\t\t\t\t\tthis.params.length == 1\n\t\t\t\t\t? this.params[0].toTeXString(false)\n\t\t\t\t\t: `\\\\left(${this.params.map(e => e.toTeXString(Expr.PREC_COMMA)).join(', ')}\\\\right)`\n\t\t\t\t),\n\t\t\t\t'\\\\mapsto ',\n\t\t\t\tthis.expr.expandMeta(true).toTeXString(false),\n\n\t\t\t\t(this.shouldConsolidate(prec) ? '\\\\right)' : '')\n\t\t\t].join('');\n\t\t}\n\t\t\n\t\tvar id = 'def-' + this.name,\n\t\t\tproved = this.isProved() ? 'p' : 'np';\n\t\n\t\tif (!root)\n\t\t\treturn `\\\\href{#${id}}{\\\\htmlData{proved=${proved}}{\\\\mathsf{${Expr.escapeTeX(this.name)}}}}`;\n\t\n\t\treturn `\\\\href{#${id}}{\\\\htmlData{proved=${proved}}{\\\\mathsf{${Expr.escapeTeX(this.name)}}}}\\\\mathord{\\\\left(${this.params.map(e => e.toTeXStringWithId(Expr.PREC_COMMA) + (e.selector ? `: \\\\texttt{@${e.selector}}` : '')).join(', ')}\\\\right)}:\\\\\\\\\\\\quad`\n\t\t\t\t+ this.expr.expandMeta(true).toTeXString(true);\n\t}\n}\n\nimport $Variable from \"./$Variable\";\nimport Expr0 from \"./Expr0\";\nimport Expr, { Precedence } from \"./Expr\";\nimport Variable from \"./Variable\";\nimport ObjectFun from \"./ObjectFun\";\nimport StackTrace from \"../StackTrace\";\nimport ExecutionContext from \"../ExecutionContext\";\nimport Parameter from \"./Parameter\";\nimport { ObjectType } from \"./types\";\n\ninterface SchemaArgumentType {\n\tdoc: string;\n\ttex: string;\n\tannotations: string[];\n\tschemaType: SchemaType;\n\tname: string;\n\tparams: Parameter[];\n\tcontext: ExecutionContext;\n\tdef$s: $Variable[];\n\texpr: Expr;\n}","import Counter from '../Counter';\nimport ExecutionContext from '../ExecutionContext';\nimport { ProofType } from '../ProofType';\nimport StackTrace from '../StackTrace';\nimport Expr0 from './Expr0';\nimport Fun from './Fun';\nimport Expr, { EqualsPriority, Precedence } from './Expr';\nimport Nameable from './Nameable';\n\ninterface VariableArgumentType {\n\tdoc?: string;\n\ttex?: string;\n\tsealed: boolean;\n\ttype: ObjectType;\n\tname: string;\n\texpr: Expr0;\n}\n\nexport default class Variable extends Expr0 implements Nameable {\n\n\tpublic readonly sealed: boolean;\n\tpublic readonly type: ObjectType;\n\tpublic readonly name: string;\n\tpublic readonly expr: Expr0 | null;\n\n\tconstructor ({doc, tex, sealed, type, name, expr}: VariableArgumentType, trace: StackTrace) {\n\t\tsuper(doc, tex, type, trace);\n\t\t\n\t\tif (typeof name != 'string')\n\t\t\tthrow Expr.error('Assertion failed', trace);\n\t\t\n\t\tif (sealed && !expr) {\n\t\t\tthrow Expr.error('Cannot seal a primitive fun', trace);\n\t\t}\n\n\t\tif (expr && !type.equals(expr.type)) {\n\t\t\tthrow Expr.error(`Expression type ${expr.type} failed to match the type ${type} of variable ${name}`, trace);\n\t\t}\n\n\t\tthis.sealed = sealed;\n\t\tthis.name = name;\n\t\tthis.expr = expr;\n\t}\n\n\tprotected isProvedInternal(hypotheses: Expr[]): boolean {\n\t\treturn false;\n\t}\n\n\tpublic substitute(map: Map<Variable, Expr0>): Expr {\n\t\tif (map.has(this)) return map.get(this);\n\n\t\t// 매크로 변수는 스코프 밖에서 보이지 않으므로 치환될 것을 갖지 않는다는\n\t\t// 생각이 들어 있다.\n\t\treturn this;\n\t}\n\n\tprotected expandMetaInternal(andFuncalls: boolean): Expr {\n\t\treturn this;\n\t}\n\n\tprotected getEqualsPriority(context: ExecutionContext): EqualsPriority {\n\t\treturn this.expr && (!this.sealed || context.canUse(this))\n\t\t\t? EqualsPriority.FOUR\n\t\t\t: EqualsPriority.ZERO;\n\t}\n\n\tprotected equalsInternal(obj: Expr, context: ExecutionContext): (Fun | Variable)[] | false {\n\t\tif (!this.expr) return false;\n\n\t\tif (!this.sealed || context.canUse(this)) {\n\t\t\tvar tmp = this.expr.equals(obj, context);\n\t\t\tif (!tmp) return tmp;\n\t\t\treturn tmp.push(this), tmp;\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tprotected getProofInternal(\n\t\t\thypnumMap: Map<Expr, number>,\n\t\t\t$Map: Map<Expr, number | [number, number]>,\n\t\t\tctr: Counter): ProofType[] {\n\t\t\n\t\treturn [{\n\t\t\t_type: 'NP',\n\t\t\tctr: ctr.next(),\n\t\t\texpr: this\n\t\t}];\n\t}\n\n\t// pr f\n\tpublic toSimpleString() {\n\t\treturn this.type.toString() + ' ' + this.name;\n\t}\n\n\tpublic toIndentedString(indent: number, root?: boolean): string {\n\t\treturn `${root ? this.type + ' ' : ''}${this.name}<${this._id}>`;\n\t}\n\n\tpublic toTeXString(prec?: Precedence, root?: boolean): string {\n\t\tvar id = this instanceof Parameter ? `id-${this._id}` : `def-${this.name}`;\n\n\t\tvar tex = this.tex || Expr.makeTeXName(this.name);\n\t\t\n\t\tvar expr = root && this.expr\n\t\t\t? `\\\\coloneqq ${this.expr.toTeXString(Expr.PREC_COLONEQQ)}`\n\t\t\t: '';\n\t\t\n\t\treturn `\\\\href{#${id}}{${tex}}${expr}`;\n\t}\n}\n\nimport Parameter from './Parameter';\nimport { ObjectType } from './types';\n","import Counter from \"../Counter\";\nimport ExecutionContext from \"../ExecutionContext\";\nimport { ProofType } from \"../ProofType\";\nimport StackTrace from \"../StackTrace\";\nimport Expr0 from \"./Expr0\";\nimport Fun from \"./Fun\";\nimport Expr, { EqualsPriority, Precedence } from \"./Expr\";\nimport Nameable from \"./Nameable\";\nimport Variable from \"./Variable\";\n\ninterface $VariableArgumentType {\n\tname: string;\n\texpr: Expr;\n}\n\nexport default class $Variable extends Expr implements Nameable {\n\n\tpublic readonly name: string;\n\tpublic readonly expr: Expr;\n\n\tconstructor ({name, expr}: $VariableArgumentType, trace: StackTrace) {\n\t\tsuper(null, null, expr.type, trace);\n\n\t\tif (!name || !expr) {\n\t\t\tthrow Expr.error('Assertion failed', trace);\n\t\t}\n\n\t\tthis.name = name;\n\t\tthis.expr = expr;\n\t}\n\n\tprotected isProvedInternal(hypotheses: Expr[]): boolean {\n\t\treturn this.expr.isProved(hypotheses);\n\t}\n\n\tpublic substitute(map: Map<Variable, Expr0>): Expr {\n\t\treturn this.expr.substitute(map);\n\t}\n\n\tprotected expandMetaInternal(andFuncalls: boolean): Expr {\n\t\treturn this.expr.expandMeta(andFuncalls);\n\t}\n\n\tprotected getEqualsPriority(): EqualsPriority {\n\t\treturn EqualsPriority.FIVE;\n\t}\n\n\tprotected equalsInternal(obj: Expr, context: ExecutionContext): (Fun | Variable)[] | false {\n\t\treturn this.expr.equals(obj, context);\n\t}\n\n\tprotected getProofInternal(\n\t\t\thypnumMap: Map<Expr, number>,\n\t\t\t$Map: Map<Expr, number | [number, number]>,\n\t\t\tctr: Counter): ProofType[] {\n\t\t\n\t\tif (!$Map.has(this)) {\n\t\t\tthrow Error(`${this.name} is not defined`);\n\t\t}\n\n\t\treturn [{\n\t\t\t_type: 'R',\n\t\t\tctr: ctr.next(),\n\t\t\tnum: $Map.get(this),\n\t\t\texpr: this.expr\n\t\t}];\n\t}\n\n\tpublic toIndentedString(indent: number, root?: boolean): string {\n\t\treturn this.name;\n\t}\n\t\n\tpublic toTeXString(prec?: Precedence, root?: boolean): string {\n\t\treturn `\\\\mathtt{${Expr.escapeTeX(this.name)}}`;\n\t}\n}","import StackTrace from \"../StackTrace\";\nimport { Precedence } from \"./Expr\";\nimport { ObjectType } from \"./types\";\nimport Variable from \"./Variable\";\n\ninterface ParameterArgumentType {\n\tdoc?: string;\n\ttex?: string;\n\ttype: ObjectType;\n\tname: string;\n\tselector: string;\n}\n\nexport default class Parameter extends Variable {\n\n\tpublic readonly selector: string;\n\n\tconstructor ({doc, tex, type, name, selector}: ParameterArgumentType, trace: StackTrace) {\n\t\tsuper({doc, tex, sealed: false, type, name, expr: null}, trace);\n\n\t\tthis.selector = selector;\n\t}\n\n\tpublic toTeXStringWithId(prec?: Precedence, root?: boolean): string {\n\t\tvar id =`id-${this._id}`;\n\n\t\treturn [\n\t\t\t`\\\\htmlId{${id}}{`,\n\t\t\tthis.toTeXString(prec, root),\n\t\t\t`}`\n\t\t].join('');\n\t}\n}","import Expr0 from './Expr0';\n\ninterface FuncallArgumentType {\n\tfun: Expr;\n\targs: Expr0[];\n}\n\nexport default class Funcall extends Expr0 {\n\t\n\tpublic readonly fun: Expr;\n\tpublic readonly args: Expr0[];\n\n\tconstructor ({fun, args}: FuncallArgumentType, trace: StackTrace) {\n\t\tif (!fun.type.isFunctional()) {\n\t\t\tvar name = isNameable(fun) ? fun.name : '<anonymous>';\n\t\t\tthrow Expr.error(`${name} is not callable`, trace);\n\t\t}\n\n\t\tif (!(args instanceof Array) || args.map(e => e instanceof Expr0).some(e => !e))\n\t\t\tthrow Expr.error('Assertion failed', trace);\n\t\t\t \n\t\tvar resolvedType = fun.type.resolve() as FunctionalObjectType | FunctionalMetaType,\n\t\t\tparamTypes = resolvedType.from,\n\t\t\targTypes = args.map(e => e.type);\n\n\t\tif (paramTypes.length != argTypes.length)\n\t\t\tthrow Expr.error(`Invalid number of arguments (expected ${paramTypes.length}): ${argTypes.length}`, trace);\n\n\t\tfor (var i = 0; i < paramTypes.length; i++) {\n\t\t\tif (!paramTypes[i].equals(argTypes[i])) {\n\t\t\t\tthrow Expr.error(`Argument #${i + 1} has illegal argument type (expected ${paramTypes[i]}): ${argTypes[i]}`, trace);\n\t\t\t}\n\t\t}\n\n\t\tsuper(null, null, resolvedType.to, trace);\n\t\t\n\t\tthis.fun = fun;\n\t\tthis.args = args;\n\t}\n\n\tprotected isProvedInternal(hypotheses: Expr[]): boolean {\n\t\treturn this.fun.isProved(hypotheses);\n\t}\n\n\tpublic substitute(map: Map<Variable, Expr0>): Expr {\n\t\treturn new Funcall({\n\t\t\tfun: this.fun.substitute(map),\n\t\t\targs: this.args.map(arg => arg.substitute(map))\n\t\t}, this.trace);\n\t}\n\n\tprotected expandMetaInternal(andFuncalls: boolean): Expr {\n\t\tvar fun = this.fun.expandMeta(andFuncalls),\n\t\t\targs = this.args.map(arg => arg.expandMeta(andFuncalls));\n\t\t\n\t\tif (!(fun instanceof Fun) || !fun.expr || fun.name && !(fun instanceof Schema))\n\t\t\treturn new Funcall({fun, args}, this.trace);\n\n\t\treturn fun.call(args).expandMeta(andFuncalls);\n\t}\n\n\tpublic isExpandable(context: ExecutionContext): boolean {\n\t\tvar callee: Expr = this.fun;\n\n\t\twhile (callee instanceof $Variable) {\n\t\t\tcallee = callee.expr;\n\t\t}\n\n\t\tif (callee instanceof Variable && callee.expr) {\n\t\t\treturn true;\n\t\t}\n\n\t\tif (callee instanceof Funcall) {\n\t\t\treturn callee.isExpandable(context);\n\t\t}\n\n\t\tif (!(callee instanceof Fun)) return false;\n\n\t\treturn callee.isCallable(context);\n\t}\n\t\n\tpublic expandOnce(context: ExecutionContext): {expanded: Expr, used: (Fun | Variable)[]} {\n\t\tif (!this.isExpandable(context)) {\n\t\t\tthrow Error('Cannot expand');\n\t\t}\n\n\t\tvar used: (Fun | Variable)[] = [];\n\n\t\tvar callee: Expr = this.fun;\n\n\t\twhile (callee instanceof $Variable) {\n\t\t\tcallee = callee.expr;\n\t\t}\n\n\t\tif (callee instanceof Variable && callee.expr) {\n\t\t\tused.push(callee);\n\n\t\t\treturn {\n\t\t\t\texpanded: new Funcall({\n\t\t\t\t\tfun: callee.expr,\n\t\t\t\t\targs: this.args\n\t\t\t\t}, this.trace),\n\t\t\t\tused\n\t\t\t};\n\t\t}\n\n\t\tif (callee instanceof Funcall) {\n\t\t\tvar calleeExpanded = callee.expandOnce(context);\n\t\t\tused.push(...calleeExpanded.used);\n\t\t\treturn {\n\t\t\t\texpanded: new Funcall({\n\t\t\t\t\tfun: calleeExpanded.expanded,\n\t\t\t\t\targs: this.args\n\t\t\t\t}, this.trace),\n\t\t\t\tused\n\t\t\t};\n\t\t}\n\n\t\tif (!(callee instanceof Fun)) {\n\t\t\tthrow Error('Something\\'s wrong');\n\t\t}\n\n\t\tif (callee.name) used.push(callee);\n\n\t\treturn {\n\t\t\texpanded: callee.call(this.args),\n\t\t\tused\n\t\t};\n\t}\n\n\tprotected getEqualsPriority(): EqualsPriority {\n\t\treturn EqualsPriority.THREE;\n\t}\n\n\tprotected equalsInternal(obj: Expr, context: ExecutionContext): (Fun | Variable)[] | false {\n\t\tif (!(obj instanceof Funcall)) {\n\t\t\tif (!this.isExpandable(context)) return false;\n\t\t\t\n\t\t\tvar {expanded, used} = this.expandOnce(context);\n\t\t\tvar ret = expanded.equals(obj, context);\n\t\t\treturn ret && ret.concat(used);\n\t\t}\n\n\t\tvar usedMacrosList: (Fun | Variable)[] = [],\n\t\t\tT = (q: (Fun | Variable)[] | false) => { if (q) usedMacrosList.push(...q); return q; };\n\n\t\tif (this.fun == obj.fun || T(this.fun.equals(obj.fun, context))) {\n\t\t\tfor (var i = 0; i < this.args.length; i++) {\n\t\t\t\tif (!T(this.args[i].equals(obj.args[i], context))) return false;\n\t\t\t}\n\n\t\t\treturn usedMacrosList;\n\t\t}\n\n\t\tif (this.fun instanceof Funcall && this.fun.isExpandable(context)) {\n\t\t\tvar {expanded, used} = this.expandOnce(context);\n\t\t\tvar ret = expanded.equals(obj, context);\n\t\t\treturn ret && ret.concat(used);\n\t\t}\n\n\t\tif (obj.fun instanceof Funcall && obj.fun.isExpandable(context)) {\n\t\t\tvar {expanded, used} = obj.expandOnce(context);\n\t\t\tvar ret = this.equals(expanded, context);\n\t\t\treturn ret && ret.concat(used);\n\t\t}\n\n\t\tvar thisIsExpandable = this.isExpandable(context),\n\t\t\tobjIsExpandable = obj.isExpandable(context);\n\t\t\n\t\tif (this.fun == obj.fun || !thisIsExpandable && !objIsExpandable) {\n\t\t\tif (this.fun != obj.fun) return false;\n\n\t\t\tif (!thisIsExpandable && !objIsExpandable) {\n\t\t\t\tfor (var i = 0; i < this.args.length; i++) {\n\t\t\t\t\tif (!T(this.args[i].equals(obj.args[i], context))) return false;\n\t\t\t\t}\n\n\t\t\t\treturn usedMacrosList;\n\t\t\t}\n\n\t\t\tif (this.args.every((_, i) => {\n\t\t\t\treturn T(this.args[i].equals(obj.args[i], context));\n\t\t\t})) {\n\t\t\t\treturn usedMacrosList;\n\t\t\t}\n\t\t}\n\n\t\tif (thisIsExpandable) {\n\t\t\tvar {expanded, used} = this.expandOnce(context);\n\t\t\tvar ret = expanded.equals(obj, context);\n\t\t\treturn ret && ret.concat(used);\n\t\t}\n\n\t\tvar {expanded, used} = obj.expandOnce(context);\n\t\tvar ret = this.equals(expanded, context);\n\t\treturn ret && ret.concat(used);\n\t}\n\n\tprotected getProofInternal(\n\t\t\thypnumMap: Map<Expr, number>,\n\t\t\t$Map: Map<Expr, number | [number, number]>,\n\t\t\tctr: Counter): ProofType[] {\n\n\t\tif (hypnumMap.has(this.fun)) {\n\t\t\treturn [{\n\t\t\t\t_type: 'RC',\n\t\t\t\tctr: ctr.next(),\n\t\t\t\tschema: hypnumMap.get(this.fun),\n\t\t\t\targs: this.args,\n\t\t\t\texpr: this\n\t\t\t}];\n\t\t}\n\n\t\tif ($Map.has(this.fun)) {\n\t\t\treturn [{\n\t\t\t\t_type: 'RC',\n\t\t\t\tctr: ctr.next(),\n\t\t\t\tschema: $Map.get(this.fun),\n\t\t\t\targs: this.args,\n\t\t\t\texpr: this\n\t\t\t}];\n\t\t}\n\n\t\tif (this.fun instanceof Schema && this.fun.name) {\n\t\t\treturn [{\n\t\t\t\t_type: 'RCX',\n\t\t\t\tctr: ctr.next(),\n\t\t\t\texpr: this\n\t\t\t}];\n\t\t}\n\n\t\tif (!(this.fun instanceof Schema)) {\n\t\t\treturn [{\n\t\t\t\t_type: 'NP',\n\t\t\t\tctr: ctr.next(),\n\t\t\t\texpr: this\n\t\t\t}];\n\t\t}\n\n\t\tvar schemalines = this.fun.getProof(hypnumMap, $Map, ctr);\n\n\t\treturn [\n\t\t\t...schemalines,\n\t\t\t{\n\t\t\t\t_type: 'RC',\n\t\t\t\tctr: ctr.next(),\n\t\t\t\tschema: schemalines[schemalines.length - 1].ctr,\n\t\t\t\targs: this.args,\n\t\t\t\texpr: this\n\t\t\t}\n\t\t];\n\t}\n\n\tpublic toIndentedString(indent: number, root?: boolean): string {\n\t\tvar args: any = this.args.map(arg => {\n\t\t\tif (arg instanceof Variable) return `${arg.name}<${arg._id}>`;\n\t\t\treturn arg.toIndentedString(indent + 1);\n\t\t});\n\t\n\t\tif (args.join('').length <= 50) {\n\t\t\targs = this.args.map(arg => {\n\t\t\t\tif (arg instanceof Variable) return `${arg.name}<${arg._id}>`;\n\t\t\t\treturn arg.toIndentedString(indent);\n\t\t\t});\n\t\n\t\t\targs = args.join(', ');\n\t\t\t\n\t\t\tif (this.fun instanceof Schema) {\n\t\t\t\treturn `${this.fun.name || `(${this.fun})`}(${args})`;\n\t\t\t} else {\n\t\t\t\treturn [\n\t\t\t\t\t!(this.fun instanceof Fun) || !this.fun.name\n\t\t\t\t\t\t? '(' + this.fun.toIndentedString(indent) + ')'\n\t\t\t\t\t\t: this.fun.name,\n\t\t\t\t\t`(${args})`\n\t\t\t\t].join('');\n\t\t\t}\n\t\t} else {\n\t\t\targs = args.join(',\\n' + '\\t'.repeat(indent + 1));\n\t\t\t\n\t\t\tif (this.fun instanceof Schema) {\n\t\t\t\treturn [\n\t\t\t\t\tthis.fun.name || `(${this.fun.toIndentedString(indent)})`,\n\t\t\t\t\t'(',\n\t\t\t\t\t'\\t' + args,\n\t\t\t\t\t')'\n\t\t\t\t].join('\\n' + '\\t'.repeat(indent));\n\t\t\t} else {\n\t\t\t\treturn [\n\t\t\t\t\t(\n\t\t\t\t\t\t!(this.fun instanceof Fun) || !('name' in this.fun && this.fun.name)\n\t\t\t\t\t\t\t? '(' + this.fun.toIndentedString(indent) + ')'\n\t\t\t\t\t\t\t: this.fun.name\n\t\t\t\t\t) + '(',\n\t\t\t\t\t'\\t' + args,\n\t\t\t\t\t')'\n\t\t\t\t].join('\\n' + '\\t'.repeat(indent));\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic toTeXString(prec?: Precedence, root?: boolean): string {\n\t\tif (this.fun instanceof Schema) {\n\t\t\treturn (\n\t\t\t\tthis.fun.name\n\t\t\t\t\t? `\\\\href{#def-${this.fun.name}}{\\\\htmlData{proved=${this.fun.isProved() ? 'p' : 'np'}}{\\\\textsf{${Expr.escapeTeX(this.fun.name)}}}}`\n\t\t\t\t\t: this.fun.toTeXString(false)\n\t\t\t) + `\\\\mathord{\\\\left(${this.args.map(arg => {\n\t\t\t\treturn arg.toTeXString(Expr.PREC_COMMA);\n\t\t\t}).join(', ')}\\\\right)}`;\n\t\t}\n\n\t\tif (this.fun instanceof ObjectFun)\n\t\t\treturn this.fun.funcallToTeXString(this.args, prec);\n\t\t\n\t\tvar args = this.args.map(arg => {\n\t\t\treturn arg.toTeXString(Expr.PREC_COMMA);\n\t\t});\n\n\t\treturn (\n\t\t\t!(isNameable(this.fun) && this.fun.name) || this.fun instanceof Variable\n\t\t\t\t? this.fun.toTeXString(false)\n\t\t\t\t: Expr.makeTeXName(this.fun.name)\n\t\t) + `\\\\mathord{\\\\left(${args.join(', ')}\\\\right)}`;\n\t}\n}\n\nimport Counter from '../Counter';\nimport ExecutionContext from '../ExecutionContext';\nimport { ProofType } from '../ProofType';\nimport StackTrace from '../StackTrace';\nimport $Variable from './$Variable';\nimport Fun from './Fun';\nimport Expr, { EqualsPriority, Precedence } from './Expr';\nimport { isNameable } from './Nameable';\nimport ObjectFun from './ObjectFun';\nimport Schema from './Schema';\nimport Variable from './Variable';\nimport { FunctionalMetaType, FunctionalObjectType } from './types';\n","import Expr from \"./Expr\";\n\nexport default abstract class Expr0 extends Expr {\n\t\n}","import Fun from \"./Fun\";\n\nexport default class ObjectFun extends Fun {\n\t\n\tconstructor ({doc, tex, annotations, sealed, rettype, name, params, expr}: ObjectFunArgumentType, trace: StackTrace) {\n\t\tsuper({doc, tex, annotations, sealed, rettype, name, params, expr}, trace);\n\t}\n\n\tpublic substitute(map: Map<Variable, Expr0>): Expr {\n\t\tif (!this.expr) return this;\n\n\t\t// 이름이 있는 것은 스코프 밖에서 보이지 않으므로 치환될 것을\n\t\t// 갖지 않는다는 생각이 들어 있다.\n\t\tif (this.name) return this;\n\n\t\t// 위의 this.name 조건을 지우면 특수한 경우에 이게 발생할지도 모른다.\n\t\tif (this.params.some(e => map.has(e)))\n\t\t\tthrow Error('Parameter collision');\n\n\t\treturn new ObjectFun({\n\t\t\tdoc: null,\n\t\t\ttex: null,\n\t\t\tannotations: this.annotations,\n\t\t\tsealed: this.sealed,\n\t\t\trettype: null,\n\t\t\tname: null,\n\t\t\tparams: this.params,\n\t\t\texpr: this.expr.substitute(map)\n\t\t}, this.trace);\n\t}\n\n\tprotected expandMetaInternal(andFuncalls: boolean): Expr {\n\t\tif (!this.expr) return this;\n\t\tif (this.type instanceof ObjectType && this.name) return this;\n\n\t\treturn new ObjectFun({\n\t\t\tdoc: null,\n\t\t\ttex: null,\n\t\t\tannotations: this.annotations,\n\t\t\tsealed: this.sealed,\n\t\t\trettype: null,\n\t\t\tname: null,\n\t\t\tparams: this.params,\n\t\t\texpr: this.expr.expandMeta(andFuncalls)\n\t\t}, this.trace);\n\t}\n\n\tpublic isCallable(context: ExecutionContext): boolean {\n\t\treturn this.expr && (!this.sealed || context.canUse(this));\n\t}\n\n\tpublic toIndentedString(indent: number, root?: boolean): string {\n\t\tif (this.name) return this.name;\n\t\t\n\t\treturn [\n\t\t\t`ƒ ${this.name || ''}(${this.params.map(p => p.toIndentedString(indent)).join(', ')}) => {`,\n\t\t\t'\\t' + this.expr.toIndentedString(indent + 1),\n\t\t\t'}'\n\t\t].join('\\n' + '\\t'.repeat(indent));\n\t}\n\n\tpublic toTeXString(prec?: Precedence, root?: boolean): string {\n\t\tif (!this.name) {\n\t\t\tthis.precedence = Expr.PREC_FUNEXPR;\n\t\t\treturn [\n\t\t\t\t(this.shouldConsolidate(prec) ? '\\\\left(' : ''),\n\n\t\t\t\t(\n\t\t\t\t\tthis.params.length == 1\n\t\t\t\t\t? this.params[0].toTeXString(false)\n\t\t\t\t\t: `\\\\left(${this.params.map(e => e.toTeXString(Expr.PREC_COMMA)).join(', ')}\\\\right)`\n\t\t\t\t),\n\t\t\t\t'\\\\mapsto ',\n\t\t\t\tthis.expr.expandMeta(true).toTeXString(false),\n\n\t\t\t\t(this.shouldConsolidate(prec) ? '\\\\right)' : '')\n\t\t\t].join('');\n\t\t}\n\n\t\tif (!root)\n\t\t\treturn `\\\\href{#def-${this.name}}{${Expr.makeTeXName(this.name)}}`;\n\t\n\t\tif (!this.expr)\n\t\t\treturn this.funcallToTeXString(this.params, prec);\n\t\n\t\treturn this.funcallToTeXString(this.params, Expr.PREC_COLONEQQ)\n\t\t\t\t+ `\\\\coloneqq ${this.expr.toTeXString(Expr.PREC_COLONEQQ)}`;\n\t}\n\n\tpublic funcallToTeXString(args, prec) {\n\t\targs = args.map(arg => {\n\t\t\treturn arg.toTeXString(this.tex ? this.precedence : Expr.PREC_COMMA);\n\t\t});\n\t\n\t\tif (this.tex) {\n\t\t\treturn this.makeTeX('def-' + this.name, args, prec);\n\t\t}\n\t\n\t\treturn (\n\t\t\t!this.name\n\t\t\t\t? this.toTeXString(false)\n\t\t\t\t: `\\\\href{#def-${this.name}}{${Expr.makeTeXName(this.name)}}`\n\t\t) + `\\\\mathord{\\\\left(${args.join(', ')}\\\\right)}`;\n\t}\n}\n\nimport ExecutionContext from \"../ExecutionContext\";\nimport StackTrace from \"../StackTrace\";\nimport Expr0 from \"./Expr0\";\nimport Expr, { Precedence } from \"./Expr\";\nimport Variable from \"./Variable\";\nimport Parameter from \"./Parameter\";\nimport { Type, ObjectType } from \"./types\";\n\ninterface ObjectFunArgumentType {\n\tdoc: string;\n\ttex: string;\n\tannotations: string[];\n\tsealed: boolean;\n\trettype: Type;\n\tname: string;\n\tparams: Parameter[];\n\texpr: Expr0;\n}","import ObjectFun from \"./exprs/ObjectFun\";\nimport Variable from \"./exprs/Variable\";\n\nexport default class ExecutionContext {\n\n\tpublic readonly usingList: (Variable | ObjectFun)[];\n\n\tconstructor (usingList?: (Variable | ObjectFun)[]) {\n\t\tthis.usingList = usingList || [];\n\t}\n\n\tpublic canUse(fun: Variable | ObjectFun) {\n\t\treturn this.usingList.includes(fun);\n\t}\n}","var n: number = 0;\n\nexport default {\n\tpeek(): number {\n\t\treturn n;\n\t},\n\tnext(): number {\n\t\treturn ++n;\n\t}\n};","export default interface Nameable {\n\tname: string;\n}\n\nexport function isNameable(obj: object): obj is Nameable {\n\treturn 'name' in obj;\n}","import Counter from '../Counter';\nimport ExecutionContext from '../ExecutionContext';\nimport { ProofType } from '../ProofType';\nimport StackTrace from '../StackTrace';\nimport $Variable from './$Variable';\nimport Expr0 from './Expr0';\nimport Fun from './Fun';\nimport Expr, { EqualsPriority, Precedence } from './Expr';\nimport { ObjectType, Type, TeeType } from './types';\nimport Variable from './Variable';\n\ninterface TeeArgumentType {\n\tleft: Expr[];\n\tdef$s: $Variable[];\n\tright: Expr;\n}\n\nexport default class Tee extends Expr {\n\n\tpublic readonly left: Expr[];\n\tpublic readonly def$s: $Variable[];\n\tpublic readonly right: Expr;\n\n\tconstructor ({left, def$s, right}: TeeArgumentType, trace: StackTrace) {\n\t\tif (!(left instanceof Array\n\t\t\t\t&& left.every(l => {\n\t\t\t\t\treturn l.type instanceof ObjectType\n\t\t\t\t\t\t|| l.type instanceof Type;\n\t\t\t\t}))) {\n\t\t\tconsole.log(left);\n\t\t\tthrow Expr.error('Assertion failed', trace);\n\t\t}\n\n\t\tif (def$s && !(def$s instanceof Array && def$s.every($ => $ instanceof $Variable)))\n\t\t\tthrow Expr.error('Assertion failed', trace);\n\n\t\tif (!(right.type instanceof ObjectType || right.type instanceof Type)) {\n\t\t\tconsole.log(right);\n\t\t\tthrow Expr.error('Assertion failed', trace);\n\t\t}\n\n\t\tsuper(null, null, new TeeType({\n\t\t\tleft: left.map(e => e.type),\n\t\t\tright: right.type\n\t\t}, trace), trace);\n\n\t\tthis.left = left;\n\t\tthis.def$s = def$s || [];\n\t\tthis.right = right;\n\t\tthis.precedence = Expr.PREC_COMMA;\n\t}\n\n\tprotected isProvedInternal(hypotheses: Expr[]): boolean {\n\t\treturn this.right.isProved(hypotheses.concat(this.left));\n\t}\n\n\tpublic substitute(map: Map<Variable, Expr0>): Expr {\n\t\tvar left = this.left.map(e => e.substitute(map));\n\t\tvar right = this.right.substitute(map);\n\n\t\treturn new Tee({\n\t\t\tleft,\n\t\t\tdef$s: null,\n\t\t\tright\n\t\t}, this.trace);\n\t}\n\n\tprotected expandMetaInternal(andFuncalls: boolean): Expr {\n\t\tvar left = this.left.map(lef => lef.expandMeta(andFuncalls));\n\t\tvar right = this.right.expandMeta(andFuncalls);\n\n\t\treturn new Tee({left, def$s: null, right}, this.trace);\n\t}\n\n\tprotected getEqualsPriority(): EqualsPriority {\n\t\treturn EqualsPriority.TWO;\n\t}\n\n\tprotected equalsInternal(obj: Expr, context: ExecutionContext): (Fun | Variable)[] | false {\n\t\tif (!(obj instanceof Tee)) {\n\t\t\tthrow Error('Assertion failed');\n\t\t}\n\n\t\tif (this.left.length != obj.left.length) {\n\t\t\tthrow Error('Assertion failed');\n\t\t}\n\n\t\tfor (var i = 0; i < this.left.length; i++) {\n\t\t\tif (!this.left[i].equals(obj.left[i], context)) return false;\n\t\t}\n\n\t\treturn this.right.equals(obj.right, context);\n\t}\n\n\tprotected getProofInternal(\n\t\t\thypnumMap: Map<Expr, number>,\n\t\t\t$Map: Map<Expr, number | [number, number]>,\n\t\t\tctr: Counter): ProofType[] {\n\t\t\n\t\thypnumMap = new Map(hypnumMap);\n\n\t\tvar start = ctr.peek() + 1;\n\n\t\tvar leftlines: ProofType[] = this.left.map(l => {\n\t\t\thypnumMap.set(l, ctr.next());\n\t\t\t\n\t\t\treturn {\n\t\t\t\t_type: 'H',\n\t\t\t\tctr: ctr.peek(),\n\t\t\t\texpr: l\n\t\t\t};\n\t\t});\n\n\t\t$Map = new Map($Map);\n\n\t\tvar $lines = this.def$s.map($ => {\n\t\t\tvar lines = $.expr.getProof(hypnumMap, $Map, ctr);\n\t\t\tvar $num = lines[lines.length - 1].ctr;\n\t\t\t$Map.set($, $num);\n\t\t\treturn lines;\n\t\t}).flat(1);\n\n\t\treturn [{\n\t\t\t_type: 'T',\n\t\t\tleftlines: leftlines as any,\n\t\t\trightlines: $lines.concat(this.right.getProof(hypnumMap, $Map, ctr)),\n\t\t\tctr: [start, ctr.peek()]\n\t\t}];\n\t}\n\n\tpublic toIndentedString(indent: number, root?: boolean): string {\n\t\tif (!this.left.length) {\n\t\t\treturn '|- ' + this.right.toIndentedString(indent);\n\t\t}\n\t\n\t\treturn [\n\t\t\t'\\t' + this.left.map(e => e.toIndentedString(indent + 1)).join(',\\n' + '\\t'.repeat(indent + 1)),\n\t\t\t'|-',\n\t\t\t'\\t' + this.right.toIndentedString(indent + 1)\n\t\t].join('\\n' + '\\t'.repeat(indent));\n\t}\n\t\n\tpublic toTeXString(prec?: Precedence, root?: boolean): string {\n\t\tvar expanded = this.expandMeta(true) as Tee;\n\n\t\treturn [\n\t\t\t(this.shouldConsolidate(prec) ? '\\\\left(' : ''),\n\t\t\t`{${expanded.left.map(e => e.toTeXString(Expr.PREC_COMMA)).join(', ')} \\\\vdash ${expanded.right.toTeXString(Expr.PREC_COMMA)}}`,\n\t\t\t(this.shouldConsolidate(prec) ? '\\\\right)' : '')\n\t\t].join('');\n\t}\n}","var grammar;\n\nif (process.env.__webpack__) {\n\tgrammar = require('raw-loader!./grammar.pegjs').default;\n} else {\n\tvar fs = require('fs');\n\tvar path = require('path');\n\n\tgrammar = fs.readFileSync(path.join(__dirname, 'grammar.pegjs'), 'utf-8');\n}\n\nvar Program = require('./Program').default;\n\nmodule.exports = {grammar, Program};","export default \"start =\\n\\t_\\n\\timports:(i:import _ {return i})*\\n\\tlines:(a:line _ {return a})*\\n\\t{return imports.concat(lines)}\\n\\nline =\\n\\ttypedef\\n\\t/ defv\\n\\t/ defun\\n\\t/ defschema\\n\\nevaluable =\\n\\t_ e:evaluable_internal _ {return e}\\n\\nevaluable_internal =\\n\\ttypedef\\n\\t/ defv\\n\\t/ defun\\n\\t/ defschema\\n\\t/ expr\\n\\nimport =\\n\\t'import' __\\n\\tfilename:ident _\\n\\tsem\\n\\t{\\n\\t\\treturn {\\n\\t\\t\\t_type: 'import',\\n\\t\\t\\tfilename,\\n\\t\\t\\tlocation: location()\\n\\t\\t}\\n\\t}\\n\\ntypedef =\\n\\tdoc:(documentation __)?\\n\\t\\\"type\\\" __\\n\\tname:ident _\\n\\texpr:('=' _ o:ftype _ {return o})?\\n\\tsem\\n\\t{\\n\\t\\treturn {\\n\\t\\t\\t_type: 'typedef',\\n\\t\\t\\tdoc: doc ? doc[0] : null,\\n\\t\\t\\texpr,\\n\\t\\t\\tname,\\n\\t\\t\\tlocation: location()\\n\\t\\t}\\n\\t}\\n\\ndefv =\\n\\tdoc:(documentation __)?\\n\\ttex:(tex __)?\\n\\tsealed:('sealed' __)?\\n\\ttype:type __\\n\\tname:ident _\\n\\texpr:(\\n\\t\\t\\\"=\\\" _\\n\\t\\texpr:expr0 _\\n\\t\\tsem\\n\\t\\t{return expr}\\n\\t\\t/ sem {return null}\\n\\t)\\n\\t{\\n\\t\\treturn {\\n\\t\\t\\t_type: 'defv',\\n\\t\\t\\tisParam: false,\\n\\t\\t\\tdoc: doc ? doc[0] : null,\\n\\t\\t\\ttex: tex ? tex[0] : null,\\n\\t\\t\\tsealed: !!sealed,\\n\\t\\t\\ttype,\\n\\t\\t\\tname,\\n\\t\\t\\texpr,\\n\\t\\t\\tlocation: location()\\n\\t\\t}\\n\\t}\\n\\ndefparam =\\n\\ttex:(tex __)? type:type __ name:ident\\n\\t{\\n\\t\\treturn {\\n\\t\\t\\t_type: 'defv',\\n\\t\\t\\tisParam: true,\\n\\t\\t\\tdoc: null,\\n\\t\\t\\ttex: tex ? tex[0] : null,\\n\\t\\t\\ttype,\\n\\t\\t\\tname,\\n\\t\\t\\tlocation: location()\\n\\t\\t}\\n\\t}\\n\\ndefschemaparam =\\n\\ttex:(tex __)? type:type __ name:ident\\n\\tselector:(_ ':' _ '@' g:$[a-z0-9_]+ {return g})?\\n\\t{\\n\\t\\treturn {\\n\\t\\t\\t_type: 'defv',\\n\\t\\t\\tisParam: true,\\n\\t\\t\\tdoc: null,\\n\\t\\t\\ttex: tex ? tex[0] : null,\\n\\t\\t\\ttype,\\n\\t\\t\\tname,\\n\\t\\t\\tselector,\\n\\t\\t\\tlocation: location()\\n\\t\\t}\\n\\t}\\n \\ndefun =\\n\\tdoc:(documentation __)?\\n\\ttex:(tex __)?\\n\\tsealed:('sealed' __)?\\n\\trettype:type __\\n\\tname:ident _\\n\\tparams:(\\n\\t\\t\\\"(\\\" _\\n\\t\\tp:(\\n\\t\\t\\thead:defparam _\\n\\t\\t\\ttail:(\\\",\\\" _ tv:defparam _ {return tv})*\\n\\t\\t\\t{return [head].concat(tail)}\\n\\t\\t)?\\n\\t\\t\\\")\\\" _\\n\\t\\t{return p || []}\\n\\t)\\n\\texpr:(\\n\\t\\t\\\"{\\\" _\\n\\t\\texpr:expr0 _\\n\\t\\t\\\"}\\\"\\n\\t\\t{return expr}\\n\\t\\t/ sem {return null}\\n\\t)\\n\\t{\\n\\t\\treturn {\\n\\t\\t\\t_type: 'defun',\\n\\t\\t\\tdoc: doc ? doc[0] : null,\\n\\t\\t\\ttex: tex ? tex[0] : null,\\n\\t\\t\\tsealed: !!sealed,\\n\\t\\t\\trettype,\\n\\t\\t\\tname,\\n\\t\\t\\tparams,\\n\\t\\t\\texpr,\\n\\t\\t\\tlocation: location()\\n\\t\\t}\\n\\t}\\n\\ndefschema =\\n\\tdoc:(documentation __)?\\n\\tannotations: (a:annotation __ {return a})*\\n\\tschemaType:('axiom' / 'theorem' / 'schema') __\\n\\tname:ident _\\n\\tparams:(\\n\\t\\t\\\"(\\\" _\\n\\t\\tp:(\\n\\t\\t\\thead:defschemaparam _\\n\\t\\t\\ttail:(\\\",\\\" _ tv:defschemaparam _ {return tv})*\\n\\t\\t\\t{return [head].concat(tail)}\\n\\t\\t)?\\n\\t\\t\\\")\\\" _\\n\\t\\t{return p || []}\\n\\t)\\n\\tusing:(\\n\\t\\t'using' __\\n\\t\\tx:(\\n\\t\\t\\thead:ident _\\n\\t\\t\\ttail:(',' _ n:ident _ {return n})*\\n\\t\\t\\t{return [head].concat(tail)}\\n\\t\\t)\\n\\t\\t{return x}\\n\\t)?\\n\\t\\\"{\\\" _\\n\\tdefdollars: (d:defdollar _ {return d})* _\\n\\texpr:expr _\\n\\t\\\"}\\\"\\n\\t{\\n\\t\\treturn {\\n\\t\\t\\t_type: 'defschema',\\n\\t\\t\\tdoc: doc ? doc[0] : null,\\n\\t\\t\\tannotations,\\n\\t\\t\\tschemaType,\\n\\t\\t\\tname,\\n\\t\\t\\tparams,\\n\\t\\t\\tusing: using || [],\\n\\t\\t\\tdef$s: defdollars,\\n\\t\\t\\texpr,\\n\\t\\t\\tlocation: location()\\n\\t\\t}\\n\\t}\\n\\n// var[...]\\n// foo(...)[...]\\n// foo[...][...]\\n// (expr)[...]\\n// schema(?, ...)[...]\\nreduction =\\n\\tantecedents:(\\n\\t\\ta:expr_internal_2 {return [a]}\\n\\t\\t/ \\\"[\\\" _\\n\\t\\tb:(\\n\\t\\t\\thead:expr _\\n\\t\\t\\ttail:(\\\";\\\" _ e:expr _ {return e})*\\n\\t\\t\\t{return [head].concat(tail)}\\n\\t\\t)?\\n\\t\\t\\\"]\\\"\\n\\t\\t{return b || []}\\n\\t)\\n\\tright:(\\n\\t\\t_ '>' _\\n\\t\\tsubject:(\\n\\t\\t\\tschemacall\\n\\t\\t\\t/ var\\n\\t\\t\\t/ \\\"(\\\" _\\n\\t\\t\\te:expr _\\n\\t\\t\\t\\\")\\\"\\n\\t\\t\\t{return e}\\n\\t\\t)\\n\\t\\targs:(\\n\\t\\t\\t_ \\\"(\\\" _\\n\\t\\t\\ta:(\\n\\t\\t\\t\\thead:('?' {return null} / expr0) _\\n\\t\\t\\t\\ttail:(\\\",\\\" _ e:('?' {return null} / expr0) _ {return e})*\\n\\t\\t\\t\\t{return [head].concat(tail)}\\n\\t\\t\\t)?\\n\\t\\t\\t\\\")\\\"\\n\\t\\t\\t{return a || []}\\n\\t\\t)?\\n\\t\\tas_:(\\n\\t\\t\\t__ 'as' __\\n\\t\\t\\tm:expr_internal_2\\n\\t\\t\\t{return m}\\n\\t\\t)?\\n\\t\\t{return {subject, args, as_: as_ || null};}\\n\\t)+\\n\\t{\\n\\t\\tvar ret = {\\n\\t\\t\\t_type: 'reduction',\\n\\t\\t\\tsubject: right[0].subject,\\n\\t\\t\\targs: right[0].args,\\n\\t\\t\\tantecedents,\\n\\t\\t\\tas: right[0].as_,\\n\\t\\t\\tlocation: location()\\n\\t\\t};\\n\\n\\t\\tfor (var i = 1; i < right.length; i++) {\\n\\t\\t\\tret = {\\n\\t\\t\\t\\t_type: 'reduction',\\n\\t\\t\\t\\tsubject: right[i].subject,\\n\\t\\t\\t\\targs: right[i].args,\\n\\t\\t\\t\\tantecedents: [ret],\\n\\t\\t\\t\\tas: right[i].as_,\\n\\t\\t\\t\\tlocation: location()\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t\\n\\t\\treturn ret;\\n\\t}\\n\\n// var(...)\\n// (expr)(...)\\nschemacall =\\n\\tschema:(\\n\\t\\tvar\\n\\t\\t/ \\\"(\\\" _ e:expr _ \\\")\\\"\\n\\t\\t{return e}\\n\\t) _\\n\\targs:(\\n\\t\\t\\\"(\\\" _\\n\\t\\ta:(\\n\\t\\t\\thead:expr0 _\\n\\t\\t\\ttail:(\\\",\\\" _ e:expr0 _ {return e})*\\n\\t\\t\\t{return [head].concat(tail)}\\n\\t\\t)?\\n\\t\\t\\\")\\\"\\n\\t\\t{return a || []}\\n\\t)\\n\\t{\\n\\t\\treturn {\\n\\t\\t\\t_type: 'schemacall',\\n\\t\\t\\tschema,\\n\\t\\t\\targs,\\n\\t\\t\\tlocation: location()\\n\\t\\t}\\n\\t}\\n\\n// forall(f, g)\\n// (expr0)(f, g)\\nfuncall =\\n\\tschema:(\\n\\t\\tvar\\n\\t\\t/ \\\"(\\\" _\\n\\t\\te:expr0 _\\n\\t\\t\\\")\\\"\\n\\t\\t{return e}\\n\\t) _\\n\\targs:(\\n\\t\\t\\\"(\\\" _\\n\\t\\ta:(\\n\\t\\t\\thead:expr0 _\\n\\t\\t\\ttail:(\\\",\\\" _ e:expr0 _ {return e})*\\n\\t\\t\\t{return [head].concat(tail)}\\n\\t\\t)?\\n\\t\\t\\\")\\\"\\n\\t\\t{return a || []}\\n\\t)\\n\\t{\\n\\t\\treturn {\\n\\t\\t\\t_type: 'funcall',\\n\\t\\t\\tschema,\\n\\t\\t\\targs,\\n\\t\\t\\tlocation: location()\\n\\t\\t}\\n\\t}\\n\\n// (T t) => expr0\\n// (T t) => { expr0 }\\nfunexpr =\\n\\tparams:(\\n\\t\\t\\\"(\\\" _\\n\\t\\tp:(\\n\\t\\t\\thead:defparam _\\n\\t\\t\\ttail:(\\\",\\\" _ tv:defparam _ {return tv})*\\n\\t\\t\\t{return [head].concat(tail)}\\n\\t\\t)?\\n\\t\\t\\\")\\\" _\\n\\t\\t{return p || []}\\n\\t)\\n\\t\\\"=>\\\" _\\n\\texpr:(\\n\\t\\texpr0\\n\\t\\t/ \\\"{\\\" _ e:expr0 _ \\\"}\\\" {return e}\\n\\t)\\n\\t{\\n\\t\\treturn {\\n\\t\\t\\t_type: 'funexpr',\\n\\t\\t\\tparams,\\n\\t\\t\\texpr,\\n\\t\\t\\tlocation: location()\\n\\t\\t}\\n\\t}\\n\\n// (T t) => expr_internal_1\\n// (T t) => { $foo = ...; expr }\\nschemaexpr =\\n\\tparams:(\\n\\t\\t\\\"(\\\" _\\n\\t\\tp:(\\n\\t\\t\\thead:defparam _\\n\\t\\t\\ttail:(\\\",\\\" _ tv:defparam _ {return tv})*\\n\\t\\t\\t{return [head].concat(tail)}\\n\\t\\t)?\\n\\t\\t\\\")\\\" _\\n\\t\\t{return p || []}\\n\\t)\\n\\t\\\"=>\\\" _\\n\\tfoo:(\\n\\t\\texpr:expr_internal_1\\n\\t\\t{return {defdollars: [], expr}}\\n\\t\\t/ \\\"{\\\" _\\n\\t\\tdefdollars: (d:defdollar _ {return d})* _\\n\\t\\texpr:expr _\\n\\t\\t\\\"}\\\"\\n\\t\\t{return {defdollars, expr}}\\n\\t)\\n\\t{\\n\\t\\treturn {\\n\\t\\t\\t_type: 'schemaexpr',\\n\\t\\t\\tparams,\\n\\t\\t\\tdef$s: foo.defdollars,\\n\\t\\t\\texpr: foo.expr,\\n\\t\\t\\tlocation: location()\\n\\t\\t}\\n\\t}\\n\\ntee =\\n\\tleft:(\\n\\t\\tl:(\\n\\t\\t\\thead:expr_internal_1 _\\n\\t\\t\\ttail:(\\\",\\\" _ e:expr_internal_1 _ {return e})*\\n\\t\\t\\t{return [head].concat(tail)}\\n\\t\\t)? {return l || []}\\n\\t)\\n\\t\\\"|-\\\" _\\n\\tfoo:(\\n\\t\\texpr:expr_internal_2\\n\\t\\t{return {defdollars: [], expr}}\\n\\t\\t/ \\\"{\\\" _\\n\\t\\tdefdollars: (d:defdollar _ {return d})* _\\n\\t\\texpr:expr _\\n\\t\\t\\\"}\\\"\\n\\t\\t{return {defdollars, expr}}\\n\\t)\\n\\t{\\n\\t\\treturn {\\n\\t\\t\\t_type: 'tee',\\n\\t\\t\\tdef$s: foo.defdollars,\\n\\t\\t\\tleft,\\n\\t\\t\\tright: foo.expr,\\n\\t\\t\\tlocation: location()\\n\\t\\t}\\n\\t}\\n\\nwith =\\n\\t'with' _ '(' _\\n\\ttex:(tex __)?\\n\\ttype:type __\\n\\tvarname:ident _\\n\\t\\\"=\\\" _\\n\\tvarexpr:expr0 _\\n\\t')' _ '{' _\\n\\tdefdollars: (d:defdollar _ {return d})* _\\n\\texpr:expr _\\n\\t'}'\\n\\t{\\n\\t\\treturn {\\n\\t\\t\\t_type: 'with',\\n\\t\\t\\twith: {\\n\\t\\t\\t\\t_type: 'defv',\\n\\t\\t\\t\\tisParam: false,\\n\\t\\t\\t\\tdoc: null,\\n\\t\\t\\t\\ttex: tex ? tex[0] : null,\\n\\t\\t\\t\\tsealed: false,\\n\\t\\t\\t\\ttype,\\n\\t\\t\\t\\tname: varname,\\n\\t\\t\\t\\texpr: varexpr,\\n\\t\\t\\t\\tlocation: location()\\n\\t\\t\\t},\\n\\t\\t\\tdef$s: defdollars,\\n\\t\\t\\texpr,\\n\\t\\t\\tlocation: location()\\n\\t\\t}\\n\\t}\\n\\nexpr =\\n\\texpr_internal_3\\n\\nexpr_internal_3 =\\n\\treduction\\n\\t/ expr_internal_2\\n\\nexpr_internal_2 =\\n\\ttee\\n\\t/ expr_internal_1\\n\\n/*\\n * The following should hold:\\n *\\n * - `schemacall` should precede `var`.\\n *\\n */\\nexpr_internal_1 =\\n\\tschemacall\\n\\t/ var\\n\\t/ schemaexpr\\n\\t/ with\\n\\t/ \\\"(\\\" _ e:expr _ \\\")\\\" {return e}\\n\\nexpr0 =\\n\\tfuncall\\n\\t/ funexpr\\n\\t/ var\\n\\t/ \\\"(\\\" _ e:expr0 _ \\\")\\\" {return e}\\n\\ndefdollar =\\n\\tname:dollar_ident _\\n\\t'=' _\\n\\texpr:expr _\\n\\tsem\\n\\t{\\n\\t\\treturn {\\n\\t\\t\\t_type: 'def$',\\n\\t\\t\\tname,\\n\\t\\t\\texpr,\\n\\t\\t\\tlocation: location()\\n\\t\\t};\\n\\t}\\n\\ntype =\\n\\tstype\\n\\t/ ftype\\n\\nstype =\\n\\tname:ident\\n\\t{\\n\\t\\treturn {\\n\\t\\t\\t_type: 'type',\\n\\t\\t\\tftype: false,\\n\\t\\t\\tname,\\n\\t\\t\\tlocation: location()\\n\\t\\t}\\n\\t}\\n\\nftype =\\n\\t\\\"[\\\" _\\n\\tfrom:(\\n\\t\\thead:type\\n\\t\\ttail:(_ \\\",\\\" _ t:type {return t})*\\n\\t\\t{return [head].concat(tail)}\\n\\t) _\\n\\t\\\"->\\\" _\\n\\tto:type _\\n\\t\\\"]\\\"\\n\\t{\\n\\t\\treturn {\\n\\t\\t\\t_type: 'type',\\n\\t\\t\\tftype: true,\\n\\t\\t\\tfrom,\\n\\t\\t\\tto,\\n\\t\\t\\tlocation: location()\\n\\t\\t}\\n\\t}\\n\\nvar =\\n\\tat_var\\n\\t/ dollar_var\\n\\t/ plain_var\\n\\nat_var =\\n\\tname:at_ident\\n\\t{\\n\\t\\treturn {\\n\\t\\t\\t_type: 'var',\\n\\t\\t\\ttype: '@',\\n\\t\\t\\tname: name.slice(1),\\n\\t\\t\\tlocation: location()\\n\\t\\t}\\n\\t}\\n\\ndollar_var =\\n\\tname:dollar_ident\\n\\t{\\n\\t\\treturn {\\n\\t\\t\\t_type: 'var',\\n\\t\\t\\ttype: '$',\\n\\t\\t\\tname: name,\\n\\t\\t\\tlocation: location()\\n\\t\\t}\\n\\t}\\n\\nplain_var =\\n\\tname:ident\\n\\t{\\n\\t\\treturn {\\n\\t\\t\\t_type: 'var',\\n\\t\\t\\ttype: 'normal',\\n\\t\\t\\tname,\\n\\t\\t\\tlocation: location()\\n\\t\\t}\\n\\t}\\n\\nkeyword =\\n\\t'as'\\n\\t/ 'axiom'\\n\\t/ 'import'\\n\\t/ 'schema'\\n\\t/ 'sealed'\\n\\t/ 'theorem'\\n\\t/ 'type'\\n\\t/ 'using'\\n\\t/ 'with'\\n\\nannotation =\\n\\t'@discouraged'\\n\\t/ '@deprecated'\\n\\nident =\\n\\t$(!(keyword ![a-zA-Z0-9_]) [a-zA-Z0-9_]+)\\n\\nat_ident =\\n\\t$('@' [a-zA-Z0-9_]+)\\n\\ndollar_ident =\\n\\t$('$' [a-zA-Z0-9_]+)\\n\\ndocumentation =\\n\\t'\\\"' b:$(!'\\\"' a:. {return a})* '\\\"' {\\n\\t\\treturn b.replace(/\\\\r\\\\n|\\\\r/g, '\\\\n');\\n\\t}\\n\\ntex =\\n\\t'$' b:$(!'$' a:. {return a})* '$' {\\n\\t\\treturn b.replace(/\\\\r\\\\n|\\\\r/g, '\\\\n');\\n\\t}\\n\\ncomment =\\n\\t\\\"//\\\" (!newline .)*\\n\\t/ \\\"/*\\\" (!\\\"*/\\\" .)* \\\"*/\\\"\\n\\nnewline =\\n\\t\\\"\\\\r\\\\n\\\" / \\\"\\\\r\\\" / \\\"\\\\n\\\"\\n\\n// optional whitespace\\n_ =\\n\\t([ \\\\t\\\\n\\\\r] / comment)*\\n\\n// mandatory whitespace\\n__ =\\n\\t([ \\\\t\\\\n\\\\r] / comment)+\\n\\nsem =\\n\\t\\\";\\\"\";","import { SimpleObjectType } from './exprs/types';\nimport PegInterface from './PegInterface';\nimport { EvaluableObject, ImportOrLineObject } from './PegInterfaceDefinitions';\nimport ProofExplorer from './ProofExplorer';\nimport Scope from './Scope';\n\ninterface LoaderReturnType {\n\tfileUri?: string;\n\tcode: string;\n}\n\ntype LoaderType = (packageName: string) => (LoaderReturnType | Promise<LoaderReturnType>);\n\nexport default class Program {\n\t\n\tpublic scope: Scope;\n\tpublic readonly parser;\n\tpublic readonly scopeMap: Map<string, Scope> = new Map();\n\n\t/**\n\t * A temporary list used by {@link loadModuleInternal} method.\n\t * \n\t * This is the list of filenames of the files with a temporary mark during a\n\t * depth-first topological sort. Note that the file is considered to be\n\t * marked with a permanent mark if {@code this.scopeMap} has the filename.\n\t * \n\t * See https://en.wikipedia.org/wiki/Topological_sorting#Depth-first_search.\n\t */\n\tprivate loadingModules: string[];\n\t\n\tconstructor (parser) {\n\t\tif (!parser) throw Error('no');\n\t\tthis.parser = parser;\n\t}\n\n\tpublic async loadModule(filename: string, loader: LoaderType): Promise<Scope> {\n\t\tthis.loadingModules = [];\n\t\treturn this.scope = await this.loadModuleInternal(filename, loader);\n\t}\n\n\tprivate async loadModuleInternal(filename: string, loader: LoaderType): Promise<Scope> {\n\t\t// the file has a permanent mark\n\t\tif (this.scopeMap.has(filename)) {\n\t\t\treturn this.scopeMap.get(filename);\n\t\t}\n\n\t\tvar loadingModuleIndex = this.loadingModules.indexOf(filename);\n\n\t\t// the file has a temporary mark\n\t\tif (loadingModuleIndex >= 0) {\n\t\t\tif (loadingModuleIndex == this.loadingModules.length - 1) {\n\t\t\t\tthrow Error(`Cannot self import (${filename})`);\n\t\t\t}\n\n\t\t\tvar cycle = this.loadingModules.slice(loadingModuleIndex).concat(filename);\n\n\t\t\tthrow Error(`Circular import detected (${cycle.join(' -> ')}). Sadly, circular import is currently not supported.`);\n\t\t}\n\n\t\t// mark the file with a temporary mark\n\t\tthis.loadingModules.push(filename);\n\n\t\tvar {fileUri, code} = await loader(filename);\n\n\t\tvar scope = new Scope(fileUri, null);\n\t\tvar parsed = this.parser.parse(code);\n\n\t\tawait this.feed(parsed, scope, loader);\n\n\t\t// remove temporary mark\n\t\tif (this.loadingModules.pop() != filename) {\n\t\t\tthrow Error('Something\\'s wrong');\n\t\t}\n\n\t\t// mark the file with a permanent mark\n\t\tthis.scopeMap.set(filename, scope);\n\t\treturn scope;\n\t}\n\n\tpublic async feed(lines: ImportOrLineObject[], scope: Scope=this.scope, loader: LoaderType) {\n\t\tfor (var i = 0; i < lines.length; i++) {\n\t\t\tvar line = lines[i];\n\t\t\t\n\t\t\tswitch (line._type) {\n\t\t\t\tcase 'import':\n\t\t\t\t\tvar scope2 = await this.loadModuleInternal(line.filename, loader);\n\t\t\t\t\tscope.importMap.set(line.filename, scope2);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'typedef':\n\t\t\t\t\tvar type = PegInterface.type(line, scope) as SimpleObjectType;\n\n\t\t\t\t\tif (scope.hasType(type.name)) {\n\t\t\t\t\t\tthrow scope.error(`Type ${type.name} has already been declared`);\n\t\t\t\t\t}\n\n\t\t\t\t\tscope.addType(type);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'defv':\n\t\t\t\t\tvar variable = PegInterface.variable(line, scope);\n\n\t\t\t\t\tif (scope.hasVariable(variable.name)) {\n\t\t\t\t\t\tthrow scope.error(`Definition ${variable.name} has already been declared`);\n\t\t\t\t\t}\n\n\t\t\t\t\tscope.addVariable(variable);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'defun':\n\t\t\t\t\tvar fun = PegInterface.fun(line, scope);\n\n\t\t\t\t\tif (scope.hasVariable(fun.name)) {\n\t\t\t\t\t\tthrow scope.error(`Definition ${fun.name} has already been declared`);\n\t\t\t\t\t}\n\n\t\t\t\t\tscope.addFun(fun);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'defschema':\n\t\t\t\t\tvar schema = PegInterface.schema(line, scope, null);\n\n\t\t\t\t\tif (scope.hasSchema(schema.name)) {\n\t\t\t\t\t\tthrow scope.error(`Schema ${schema.name} has already been declared`);\n\t\t\t\t\t}\n\n\t\t\t\t\tscope.addSchema(schema);\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tthrow Error(`Unknown line type ${(line as any)._type}`);\n\t\t\t}\n\t\t};\n\t}\n\n\tpublic evaluate(line: EvaluableObject) {\n\t\tvar scope = new Scope('<repl>', this.scope);\n\n\t\tswitch (line._type) {\n\t\t\tcase 'typedef':\n\t\t\t\treturn PegInterface.type(line, scope);\n\t\t\tcase 'defv':\n\t\t\t\treturn PegInterface.variable(line, scope);\n\t\t\tcase 'defun':\n\t\t\t\treturn PegInterface.fun(line, scope);\n\t\t\tcase 'defschema':\n\t\t\tcase 'schemaexpr':\n\t\t\t\treturn PegInterface.schema(line, scope, null);\n\t\t\tcase 'tee':\n\t\t\t\treturn PegInterface.tee(line, scope, null);\n\t\t\tcase 'reduction':\n\t\t\t\treturn PegInterface.reduction(line, scope, null);\n\t\t\tcase 'schemacall':\n\t\t\t\treturn PegInterface.schemacall(line, scope, null);\n\t\t\tcase 'var':\n\t\t\t\treturn PegInterface.metavar(line, scope);\n\t\t\tdefault:\n\t\t\t\tthrow Error(`Unknown line type ${(line as any)._type}`);\n\t\t}\n\t}\n\n\tpublic getProofExplorer(name: string, ktx) {\n\t\treturn ProofExplorer.get(this.scope, name, ktx);\n\t}\n}","/*\n * PEG.js의 출력과 적절한 클래스 사이를 잇는 인터페이스.\n * PEG.js의 출력은 여기에서만 처리해야 한다.\n */\n\nimport ExecutionContext from './ExecutionContext';\nimport $Variable from './exprs/$Variable';\nimport Expr0 from './exprs/Expr0';\nimport Fun from './exprs/Fun';\nimport Funcall from './exprs/Funcall';\nimport Expr from './exprs/Expr';\nimport ObjectFun from './exprs/ObjectFun';\nimport Parameter from './exprs/Parameter';\nimport Reduction from './exprs/Reduction';\nimport Schema, { SchemaType } from './exprs/Schema';\nimport Tee from './exprs/Tee';\nimport { ObjectType, SimpleObjectType } from './exprs/types';\nimport Variable from './exprs/Variable';\nimport With from './exprs/With';\nimport { Def$Object, DefschemaObject, DefunObject, DefvObject, Expr0Object, FuncallObject, FunexprObject, ExprObject, ReductionObject, SchemacallObject, SchemaexprObject, StypeObject, TeeObject, TypedefObject, TypeObject, VarObject, WithObject } from './PegInterfaceDefinitions';\nimport Scope, { NestedTypeInput } from './Scope';\n\nfunction typeObjToString(obj: TypeObject): string {\n\tif (obj._type != 'type')\n\t\tthrow Error('Assertion failed');\n\n\tif (!obj.ftype) return (obj as StypeObject).name;\n\treturn '[' + obj.from.map(typeObjToString).join(', ') + ' -> '\n\t\t\t+ typeObjToString(obj.to) + ']';\n}\n\n/*\n * Scope#getType이나 Scope#hasType 등의 입력 형태로 바꾼다.\n * st\t\t\t\t\t\t-> 'st'\n * [cls -> st]\t\t\t\t-> ['cls', 'st']\n * [(cls, cls) -> st]\t\t-> ['cls', 'cls', 'st']\n * [[cls -> st] -> st]\t\t-> [['cls', 'st'], 'st']\n */\nfunction typeObjToNestedArr(obj: TypeObject): NestedTypeInput {\n\tif (obj._type != 'type')\n\t\tthrow Error('Assertion failed');\n\n\tif (!obj.ftype) {\n\t\tobj = obj as StypeObject;\n\n\t\tif (!obj.name)\n\t\t\tthrow Error('Assertion failed');\n\n\t\treturn obj.name;\n\t} else {\n\t\tif (!obj.from || !obj.to)\n\t\t\tthrow Error('Assertion failed');\n\n\t\treturn obj.from.map(typeObjToNestedArr).concat(\n\t\t\t[typeObjToNestedArr(obj.to)]\n\t\t);\n\t}\n}\n\nfunction varObjToString(obj: VarObject): string {\n\tswitch (obj.type) {\n\t\tcase '@':\n\t\t\treturn `@${obj.name}`;\n\t\tcase '$':\n\t\t\treturn `${obj.name}`;\n\t\tcase 'normal':\n\t\t\treturn `${obj.name}`;\n\t\tdefault:\n\t\t\tthrow Error(`Unknown type ${obj.type}`);\n\t}\n}\n\nexport default class PI {\n\tpublic static type(obj: TypedefObject, parentScope: Scope): ObjectType {\n\t\tif (obj._type != 'typedef')\n\t\t\tthrow Error('Assertion failed');\n\n\t\tvar scope: Scope = parentScope.extend('type', obj.name, obj.location);\n\n\t\tvar expr: ObjectType = obj.expr ? scope.getType(typeObjToNestedArr(obj.expr)) : null;\n\n\t\tvar name: string = obj.name;\n\t\tvar doc: string = obj.doc;\n\n\t\tif (expr) {\n\t\t\treturn new SimpleObjectType({\n\t\t\t\tdoc,\n\t\t\t\tname,\n\t\t\t\texpr\n\t\t\t}, scope.trace);\n\t\t}\n\n\t\treturn new SimpleObjectType({\n\t\t\tdoc,\n\t\t\tname,\n\t\t\texpr: null\n\t\t}, scope.trace);\n\t}\n\n\tpublic static variable(obj: DefvObject | VarObject, parentScope: Scope): Variable | Fun {\n\t\tif (!['defv', 'var'].includes(obj._type)) {\n\t\t\tthrow Error('Assertion failed');\n\t\t}\n\n\t\tvar scope = parentScope.extend('variable', obj.name, obj.location);\n\n\t\tif (obj._type == 'var') {\n\t\t\tif (obj.type != 'normal') {\n\t\t\t\tthrow scope.error(`Variable type ${obj.type} not allowed`);\n\t\t\t}\n\n\t\t\tif (!scope.hasVariable(obj.name))\n\t\t\t\tthrow scope.error(`Undefined identifier ${varObjToString(obj)}`);\n\t\t\treturn scope.getVariable(obj.name);\n\t\t}\n\n\t\tif (!scope.hasType(typeObjToNestedArr(obj.type)))\n\t\t\tthrow scope.error(`Type ${typeObjToString(obj.type)} is not defined`);\n\n\t\tvar type = scope.getType(typeObjToNestedArr(obj.type));\n\n\t\tvar expr = obj.expr ? PI.expr0(obj.expr, scope) : null;\n\n\t\tif (obj.isParam) {\n\t\t\treturn new Parameter({\n\t\t\t\tdoc: obj.doc,\n\t\t\t\ttex: obj.tex,\n\t\t\t\ttype,\n\t\t\t\tname: obj.name,\n\t\t\t\tselector: obj.selector || null\n\t\t\t}, scope.trace);\n\t\t}\n\n\t\treturn new Variable({\n\t\t\tdoc: obj.doc,\n\t\t\ttex: obj.tex,\n\t\t\tsealed: !!obj.sealed,\n\t\t\ttype,\n\t\t\tname: obj.name,\n\t\t\texpr: expr || null\n\t\t}, scope.trace);\n\t}\n\n\tpublic static fun(obj: DefunObject | FunexprObject, parentScope: Scope): ObjectFun {\n\t\tif (obj._type != 'defun' && obj._type != 'funexpr')\n\t\t\tthrow Error('Assertion failed');\n\t\t\n\t\tvar scope = parentScope.extend('fun', obj._type == 'defun' ? obj.name : '<anonymous>', obj.location);\n\n\t\tvar doc = null,\n\t\t\ttex = null,\n\t\t\tsealed = false,\n\t\t\trettype: ObjectType = null,\n\t\t\tname = null,\n\t\t\texpr = null;\n\n\t\tif (obj._type == 'defun') {\n\t\t\tdoc = obj.doc;\n\t\t\ttex = obj.tex;\n\t\t\tsealed = obj.sealed;\n\t\t\t\n\t\t\tif (!scope.hasType(typeObjToNestedArr(obj.rettype))) {\n\t\t\t\tthrow scope.error(`Type ${typeObjToString(obj.rettype)} is not defined`);\n\t\t\t}\n\n\t\t\trettype = scope.getType(typeObjToNestedArr(obj.rettype));\n\t\t\tname = obj.name;\n\t\t}\n\n\t\tvar params = obj.params.map(tvo => {\n\t\t\tvar tv = PI.variable(tvo, scope);\n\n\t\t\tif (scope.hasOwnVariable(tv.name))\n\t\t\t\tthrow scope.error(`Parameter ${tv.name} has already been declared`);\n\t\t\t\n\t\t\tif (!(tv instanceof Parameter)) {\n\t\t\t\tthrow Error('Something\\'s wrong');\n\t\t\t}\n\n\t\t\tscope.addVariable(tv);\n\t\t\treturn tv;\n\t\t});\n\n\t\tif (obj.expr) {\n\t\t\texpr = PI.expr0(obj.expr, scope);\n\t\t}\n\n\t\treturn new ObjectFun({annotations: [], sealed, rettype, name, params, expr, doc, tex}, scope.trace);\n\t}\n\n\tpublic static funcall(obj: FuncallObject, parentScope: Scope): Funcall {\n\t\tif (obj._type != 'funcall')\n\t\t\tthrow Error('Assertion failed');\n\n\t\tvar scope = parentScope.extend('funcall', 'name' in obj.schema ? obj.schema.name : null, obj.location);\n\n\t\tvar fun = PI.expr0(obj.schema, scope);\n\n\t\tvar args = obj.args.map(arg => {\n\t\t\treturn PI.expr0(arg, scope);\n\t\t});\n\n\t\treturn new Funcall({fun, args}, scope.trace);\n\t}\n\n\tpublic static expr(obj: ExprObject, parentScope: Scope, context: ExecutionContext): Expr {\n\t\tif (!['tee', 'reduction', 'schemacall', 'schemaexpr', 'var', 'with'].includes(obj._type)) {\n\t\t\tthrow Error('Assertion failed');\n\t\t}\n\n\t\t// don't extend scope\n\t\tvar scope = parentScope;\n\n\t\tswitch (obj._type) {\n\t\t\tcase 'tee':\n\t\t\t\treturn PI.tee(obj, scope, context);\n\t\t\tcase 'reduction':\n\t\t\t\treturn PI.reduction(obj, scope, context);\n\t\t\tcase 'schemacall':\n\t\t\t\treturn PI.schemacall(obj, scope, context);\n\t\t\tcase 'schemaexpr':\n\t\t\t\treturn PI.schema(obj, scope, context);\n\t\t\tcase 'var':\n\t\t\t\treturn PI.metavar(obj, scope);\n\t\t\tcase 'with':\n\t\t\t\treturn PI.with(obj, scope, context);\n\t\t\tdefault:\n\t\t\t\tthrow Error('wut');\n\t\t}\n\t}\n\n\tpublic static expr0(obj: Expr0Object, parentScope: Scope): Expr0 {\n\t\tif (!['funcall', 'funexpr', 'var'].includes(obj._type)) {\n\t\t\tconsole.log(obj);\n\t\t\tthrow Error('Assertion failed');\n\t\t}\n\n\t\t// don't extend scope\n\t\tvar scope = parentScope;\n\n\t\tswitch (obj._type) {\n\t\t\tcase 'funcall':\n\t\t\t\treturn PI.funcall(obj, scope);\n\t\t\tcase 'funexpr':\n\t\t\t\treturn PI.fun(obj, scope);\n\t\t\tcase 'var':\n\t\t\t\treturn PI.variable(obj, scope);\n\t\t\tdefault:\n\t\t\t\tthrow Error('wut');\n\t\t}\n\t}\n\n\tpublic static metavar(obj: VarObject, parentScope: Scope): Expr {\n\t\tif (obj._type != 'var')\n\t\t\tthrow Error('Assertion failed');\n\n\t\t// don't extend scope\n\t\tvar scope = parentScope;\n\n\t\tswitch (obj.type) {\n\t\t\tcase '@':\n\t\t\t\tif (obj.name.match(/^h[0-9]+$/)) {\n\t\t\t\t\tvar hypnum = Number(obj.name.slice(1)) - 1;\n\t\t\t\t\tif (hypnum >= scope.hypotheses.length) {\n\t\t\t\t\t\tthrow scope.error(`Hypothesis #${hypnum + 1} not found`);\n\t\t\t\t\t}\n\n\t\t\t\t\treturn scope.hypotheses[hypnum];\n\t\t\t\t}\n\n\t\t\t\tthrow scope.error(`Unknown selector query ${varObjToString(obj)}`);\n\t\t\tcase '$':\n\t\t\t\tif (!scope.has$(obj.name)) {\n\t\t\t\t\tthrow scope.error(`${varObjToString(obj)} is not defined`);\n\t\t\t\t}\n\n\t\t\t\treturn scope.get$(obj.name);\n\t\t\tcase 'normal':\n\t\t\t\tif (!scope.hasSchema(obj.name))\n\t\t\t\t\tthrow scope.error(`Schema ${varObjToString(obj)} is not defined`);\n\n\t\t\t\treturn scope.getSchema(obj.name);\n\t\t\tdefault:\n\t\t\t\tthrow scope.error(`Unknown type ${obj.type}`);\n\t\t}\n\t}\n\n\tpublic static with(obj: WithObject, parentScope: Scope, context: ExecutionContext): With {\n\t\tif (obj._type != 'with') {\n\t\t\tthrow Error('Assertion failed');\n\t\t}\n\n\t\tvar scope = parentScope.extend('with', null, obj.location);\n\n\t\tvar tv = PI.variable(obj.with, scope);\n\n\t\tif (scope.hasOwnVariable(tv.name))\n\t\t\tthrow scope.error(`Parameter ${tv.name} has already been declared`);\n\t\t\n\t\tif (!(tv instanceof Variable)) {\n\t\t\tthrow Error('Something\\'s wrong');\n\t\t}\n\n\t\tscope.addVariable(tv);\n\n\t\tvar def$s = obj.def$s.map($ => {\n\t\t\tvar $v = PI.def$($, scope, context);\n\n\t\t\tif (scope.hasOwn$($v.name)) {\n\t\t\t\tthrow scope.error(`${$.name} has already been declared`);\n\t\t\t}\n\n\t\t\treturn scope.add$($v);\n\t\t});\n\n\t\tvar expr = PI.expr(obj.expr, scope, context);\n\n\t\treturn new With({\n\t\t\tvariable: tv,\n\t\t\tdef$s,\n\t\t\texpr\n\t\t}, scope.trace);\n\t}\n\n\tpublic static tee(obj: TeeObject, parentScope: Scope, context: ExecutionContext): Tee {\n\t\tif (obj._type != 'tee')\n\t\t\tthrow Error('Assertion failed');\n\n\t\tvar scope = parentScope.extend('tee', null, obj.location);\n\n\t\tvar left = obj.left.map(o => PI.expr(o, scope, context));\n\n\t\tvar scopeRight = scope.extend('tee.right', null, obj.right.location);\n\t\tleft.forEach(l => scopeRight.hypotheses.push(l));\n\n\t\tvar def$s = obj.def$s.map($ => {\n\t\t\tvar $v = PI.def$($, scopeRight, context);\n\n\t\t\tif (scopeRight.hasOwn$($v.name)) {\n\t\t\t\tthrow scopeRight.error(`${$.name} has already been declared`);\n\t\t\t}\n\n\t\t\treturn scopeRight.add$($v);\n\t\t});\n\n\t\tvar right = PI.expr(obj.right, scopeRight, context);\n\n\t\treturn new Tee({left, def$s, right}, scope.trace);\n\t}\n\n\tpublic static def$(obj: Def$Object, parentScope: Scope, context: ExecutionContext): $Variable {\n\t\tif (obj._type != 'def$')\n\t\t\tthrow Error('Assertion failed');\n\t\t\n\t\tvar scope = parentScope.extend('def$', obj.name, obj.location);\n\t\t\n\t\tvar expr = PI.expr(obj.expr, scope, context);\n\n\t\treturn new $Variable({name: obj.name, expr}, scope.trace);\n\t}\n\n\tpublic static schema(obj: DefschemaObject | SchemaexprObject, parentScope: Scope, oldContext: ExecutionContext): Schema {\n\t\tif (obj._type != 'defschema' && obj._type != 'schemaexpr')\n\t\t\tthrow Error('Assertion failed');\n\t\t\n\t\tvar name = obj._type == 'defschema' ? obj.name : null;\n\n\t\tvar scope = parentScope.extend('schema', name, obj.location);\n\n\t\tvar schemaType: SchemaType = 'schema',\n\t\t\tdoc: string = null,\n\t\t\tannotations: string[] = [],\n\t\t\tcontext = oldContext;\n\n\t\tif (obj._type == 'defschema') {\n\t\t\tschemaType = obj.schemaType;\n\t\t\tdoc = obj.doc;\n\t\t\tannotations = obj.annotations;\n\n\t\t\tif (oldContext) {\n\t\t\t\tconsole.log(oldContext);\n\t\t\t\tthrow Error('duh');\n\t\t\t}\n\n\t\t\tvar using: (Variable | ObjectFun)[] = obj.using.map(name => {\n\t\t\t\tif (!scope.hasVariable(name)) {\n\t\t\t\t\tthrow scope.error(`Variable ${name} is not defined`);\n\t\t\t\t}\n\n\t\t\t\tvar fun = scope.getVariable(name);\n\n\t\t\t\tif (!fun.expr) {\n\t\t\t\t\tthrow scope.error(`${name} is not a macro`);\n\t\t\t\t}\n\n\t\t\t\treturn fun;\n\t\t\t});\n\n\t\t\tcontext = new ExecutionContext(using);\n\t\t}\n\n\t\tvar params = obj.params.map(tvo => {\n\t\t\tvar tv = PI.variable(tvo, scope);\n\n\t\t\tif (scope.hasOwnVariable(tv.name))\n\t\t\t\tthrow scope.error(`Parameter ${tv.name} has already been declared`);\n\t\t\t\n\t\t\tif (!(tv instanceof Parameter)) {\n\t\t\t\tthrow Error('Something\\'s wrong');\n\t\t\t}\n\n\t\t\tscope.addVariable(tv);\n\t\t\treturn tv;\n\t\t});\n\n\t\tvar def$s = obj.def$s.map($ => {\n\t\t\tvar $v = PI.def$($, scope, context);\n\n\t\t\tif (scope.hasOwn$($v.name)) {\n\t\t\t\tthrow scope.error(`${$.name} has already been declared`);\n\t\t\t}\n\n\t\t\treturn scope.add$($v);\n\t\t});\n\n\t\tvar expr = PI.expr(obj.expr, scope, context);\n\n\t\treturn new Schema({doc, tex: null, annotations, schemaType, name, params, context, def$s, expr}, scope.trace);\n\t}\n\n\tpublic static schemacall(obj: SchemacallObject, parentScope: Scope, context: ExecutionContext): Funcall {\n\t\tif (obj._type != 'schemacall')\n\t\t\tthrow Error('Assertion failed');\n\n\t\tvar scope = parentScope.extend('schemacall', 'name' in obj.schema ? obj.schema.name : null, obj.location);\n\n\t\tvar fun = PI.expr(obj.schema, scope, context);\n\n\t\tvar args = obj.args.map(obj => {\n\t\t\treturn PI.expr0(obj, scope);\n\t\t});\n\n\t\treturn new Funcall({\n\t\t\tfun,\n\t\t\targs\n\t\t}, scope.trace);\n\t}\n\n\tpublic static reduction(obj: ReductionObject, parentScope: Scope, context: ExecutionContext): Reduction {\n\t\tif (obj._type != 'reduction')\n\t\t\tthrow Error('Assertion failed');\n\t\t\n\t\tif (!context) {\n\t\t\tthrow Error('duh');\n\t\t}\n\n\t\tvar scope = parentScope.extend('reduction', 'name' in obj.subject ? obj.subject.name : null, obj.location);\n\n\t\tvar subject = PI.expr(obj.subject, scope, context);\n\n\t\tvar args = !obj.args\n\t\t\t? null\n\t\t\t: obj.args.map(g => {\n\t\t\t\treturn g && PI.expr0(g, scope);\n\t\t\t});\n\n\t\tvar antecedents = obj.antecedents.map(obj => {\n\t\t\treturn PI.expr(obj, scope, context);\n\t\t});\n\n\t\tvar as = obj.as && PI.expr(obj.as, scope, context);\n\n\t\treturn new Reduction({\n\t\t\tsubject,\n\t\t\targs,\n\t\t\tantecedents,\n\t\t\tas\n\t\t}, context, scope.trace);\n\t}\n}","import Counter from \"../Counter\";\nimport ExecutionContext from \"../ExecutionContext\";\nimport { ProofType } from \"../ProofType\";\nimport StackTrace from \"../StackTrace\";\nimport Expr0 from \"./Expr0\";\nimport Fun from \"./Fun\";\nimport Funcall from \"./Funcall\";\nimport Expr, { EqualsPriority, Precedence } from \"./Expr\";\nimport { isNameable } from \"./Nameable\";\nimport Parameter from \"./Parameter\";\nimport Schema from \"./Schema\";\nimport Tee from \"./Tee\";\nimport { FunctionalObjectType, FunctionalMetaType, TeeType } from \"./types\";\nimport Variable from \"./Variable\";\n\ninterface ReductionArgumentType {\n\tantecedents: Expr[];\n\tsubject: Expr;\n\targs: (Expr0 | null)[];\n\tas: Expr;\n}\n\nexport default class Reduction extends Expr {\n\t\n\tpublic readonly antecedents: Expr[];\n\tpublic readonly requiredAntecedents: Expr[];\n\tpublic readonly subject: Expr;\n\tpublic readonly args: (Expr0 | null)[];\n\tpublic readonly preFormatConsequent: Expr;\n\tpublic readonly consequent: Expr;\n\tprivate readonly antecedentEqualsResults: (Fun | Variable)[][];\n\tprivate readonly rightEqualsResult: (Fun | Variable)[];\n\n\tconstructor ({antecedents, subject, args, as}: ReductionArgumentType, context: ExecutionContext, trace: StackTrace) {\n\t\tif (args) {\n\t\t\tlet resolvedType = subject.type.resolve() as FunctionalObjectType | FunctionalMetaType,\n\t\t\t\tparamTypes = resolvedType.from,\n\t\t\t\targTypes = args.map(e => e && e.type);\n\n\t\t\tif (paramTypes.length != argTypes.length)\n\t\t\t\tthrow Expr.error(`Invalid number of arguments (expected ${paramTypes.length}): ${argTypes.length}`, trace);\n\n\t\t\tfor (var i = 0; i < paramTypes.length; i++) {\n\t\t\t\tif (argTypes[i] && !paramTypes[i].equals(argTypes[i])) {\n\t\t\t\t\tthrow Expr.error(`Argument #${i + 1} has illegal argument type (expected ${paramTypes[i]}): ${argTypes[i]}`, trace);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (subject instanceof Fun) {\n\t\t\tsubject.params.forEach((p, i) => {\n\t\t\t\tif (!(args && args[i]) && !p.selector) {\n\t\t\t\t\tthrow Expr.error(`Argument #${i + 1} could not be guessed`, trace);\n\t\t\t\t}\n\t\t\t});\n\t\n\t\t\tvar derefs = subject.params.map((p, i) => {\n\t\t\t\tif (args && args[i]) return args[i];\n\n\t\t\t\tvar tee = (subject as Fun).expr.expandMeta(false);\n\n\t\t\t\tif (!(tee instanceof Tee)) throw Error('wut');\n\t\n\t\t\t\treturn Reduction.guess(\n\t\t\t\t\tp.selector,\n\t\t\t\t\ttee.left, antecedents,\n\t\t\t\t\ttee.right, as,\n\t\t\t\t\tcontext, trace\n\t\t\t\t);\n\t\t\t});\n\t\n\t\t\tsubject = new Funcall({\n\t\t\t\tfun: subject,\n\t\t\t\targs: derefs,\n\t\t\t}, trace);\n\t\t} else if (args) {\n\t\t\tthrow Expr.error('Something\\'s wrong', trace);\n\t\t}\n\t\n\t\tif (!(subject.type instanceof TeeType))\n\t\t\tthrow Expr.error('Subject is not reducible', trace);\n\t\n\t\tif (!(antecedents instanceof Array)\n\t\t\t\t|| antecedents.map(e => e instanceof Expr).some(e => !e))\n\t\t\tthrow Expr.error('Assertion failed', trace);\n\n\t\tvar paramTypes = subject.type.left,\n\t\t\tantecedentTypes = antecedents.map(e => e.type);\n\n\t\tif (paramTypes.length != antecedentTypes.length)\n\t\t\tthrow Expr.error(`Invalid number of arguments (expected ${paramTypes.length}): ${antecedentTypes.length}`, trace);\n\n\t\tfor (let i = 0; i < paramTypes.length; i++) {\n\t\t\tif (!paramTypes[i].equals(antecedentTypes[i]))\n\t\t\t\tthrow Expr.error(`Illegal argument type (expected ${paramTypes[i]}): ${antecedentTypes[i]}`, trace);\n\t\t}\n\n\t\tsuper(null, null, subject.type.right, trace);\n\n\t\tthis.subject = subject;\n\t\tthis.antecedents = antecedents;\n\n\t\tvar tee = subject.expandMeta(true);\n\n\t\tif (!(tee instanceof Tee)) {\n\t\t\tthrow Expr.error('Assertion failed', trace);\n\t\t}\n\n\t\tthis.requiredAntecedents = tee.left;\n\t\tthis.antecedentEqualsResults = Array(tee.left.length).fill(0).map(() => []);\n\n\t\tvar antecedentsExpanded = antecedents.map(arg => {\n\t\t\treturn arg.expandMeta(true);\n\t\t});\n\n\t\tfor (let i = 0; i < tee.left.length; i++) {\n\t\t\tvar tmp = tee.left[i].equals(antecedentsExpanded[i], context);\n\t\t\tif (!tmp) {\n\t\t\t\tthrow Expr.error(`LHS #${i + 1} failed to match:\n\n--- EXPECTED ---\n${tee.left[i].expandMeta(true)}\n----------------\n\n--- RECEIVED ---\n${antecedents[i].expandMeta(true)}\n----------------`, trace);\n\t\t\t}\n\n\t\t\tthis.antecedentEqualsResults[i] = tmp;\n\t\t}\n\n\t\tthis.preFormatConsequent = tee.right;\n\n\t\tif (as) {\n\t\t\tvar tmp = tee.right.equals(as, context);\n\t\t\tif (!tmp) {\n\t\t\t\tthrow Expr.error(`RHS failed to match:\n\n--- EXPECTED ---\n${tee.right.expandMeta(true)}\n----------------\n\n--- RECEIVED (from [as ...]) ---\n${as.expandMeta(true)}\n----------------`, trace);\n\t\t\t}\n\n\t\t\tthis.rightEqualsResult = tmp;\n\t\t\tthis.consequent = as;\n\t\t} else {\n\t\t\tthis.consequent = tee.right;\n\t\t}\n\t}\n\n\tprotected isProvedInternal(hypotheses: Expr[]): boolean {\n\t\treturn this.subject.isProved(hypotheses)\n\t\t\t&& this.antecedents.every(l => l.isProved(hypotheses));\n\t}\n\n\tpublic substitute(map: Map<Variable, Expr0>): Expr {\n\t\treturn this.consequent.substitute(map);\n\t}\n\n\tprotected expandMetaInternal(andFuncalls: boolean): Expr {\n\t\treturn this.consequent.expandMeta(andFuncalls);\n\t}\n\n\tprotected getEqualsPriority(): EqualsPriority {\n\t\treturn EqualsPriority.FIVE;\n\t}\n\n\tprotected equalsInternal(obj: Expr, context: ExecutionContext): (Fun | Variable)[] | false {\n\t\treturn this.consequent.equals(obj, context);\n\t}\n\n\tprotected getProofInternal(\n\t\t\thypnumMap: Map<Expr, number>,\n\t\t\t$Map: Map<Expr, number | [number, number]>,\n\t\t\tctr: Counter): ProofType[] {\n\t\t\n\t\tvar antecedentLinesList: ProofType[][] = [];\n\t\tvar antecedentNums: (number | [number, number])[] = this.antecedents.map((l, i) => {\n\t\t\tif (!this.antecedentEqualsResults[i].length) {\n\t\t\t\tif (hypnumMap.has(l)) return hypnumMap.get(l);\n\t\t\t\tif ($Map.has(l)) return $Map.get(l);\n\t\t\t}\n\n\t\t\tvar ref = hypnumMap.has(l)\n\t\t\t\t? hypnumMap.get(l)\n\t\t\t\t: $Map.has(l)\n\t\t\t\t\t? $Map.get(l)\n\t\t\t\t\t: null;\n\t\t\tvar lines = ref ? [] : l.getProof(hypnumMap, $Map, ctr);\n\n\t\t\tif (this.antecedentEqualsResults[i].length) {\n\t\t\t\tlines.push({\n\t\t\t\t\t_type: 'bydef',\n\t\t\t\t\tctr: ctr.next(),\n\t\t\t\t\tref: ref || lines[lines.length - 1].ctr,\n\t\t\t\t\texpr: this.requiredAntecedents[i],\n\t\t\t\t\tof: this.antecedentEqualsResults[i]\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tantecedentLinesList.push(lines);\n\t\t\treturn this.antecedentEqualsResults[i].length\n\t\t\t\t? ctr.peek()\n\t\t\t\t: lines[lines.length - 1].ctr;\n\t\t});\n\t\t\n\t\tvar args: Expr0[] = null;\n\t\tvar subjectlines: ProofType[] = [];\n\t\tvar subjectnum = hypnumMap.get(this.subject)\n\t\t\t|| $Map.get(this.subject)\n\t\t\t|| (\n\t\t\t\tthis.subject instanceof Funcall && $Map.has(this.subject.fun)\n\t\t\t\t\t? (args = this.subject.args, $Map.get(this.subject.fun))\n\t\t\t\t\t: false\n\t\t\t)\n\t\t\t|| (\n\t\t\t\t(s => {\n\t\t\t\t\treturn s instanceof Fun && s.name\n\t\t\t\t\t\t|| s instanceof Funcall && isNameable(s.fun) && s.fun.name;\n\t\t\t\t})(this.subject)\n\t\t\t\t\t? this.subject\n\t\t\t\t\t: (subjectlines = this.subject.getProof(hypnumMap, $Map, ctr))[subjectlines.length-1].ctr\n\t\t\t);\n\n\t\tvar ret: ProofType[] = [\n\t\t\t...antecedentLinesList.flat(),\n\t\t\t...subjectlines\n\t\t];\n\n\t\tif (this.rightEqualsResult && this.rightEqualsResult.length) {\n\t\t\tret.push(\n\t\t\t\t{\n\t\t\t\t\t_type: 'E',\n\t\t\t\t\tctr: ctr.next(),\n\t\t\t\t\tsubject: subjectnum,\n\t\t\t\t\targs,\n\t\t\t\t\tantecedents: antecedentNums,\n\t\t\t\t\treduced: this.preFormatConsequent\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t_type: 'bydef',\n\t\t\t\t\tref: ctr.peek(),\n\t\t\t\t\tctr: ctr.next(),\n\t\t\t\t\texpr: this.consequent,\n\t\t\t\t\tof: this.rightEqualsResult\n\t\t\t\t}\n\t\t\t);\n\t\t} else {\n\t\t\tret.push({\n\t\t\t\t_type: 'E',\n\t\t\t\tctr: ctr.next(),\n\t\t\t\tsubject: subjectnum,\n\t\t\t\targs,\n\t\t\t\tantecedents: antecedentNums,\n\t\t\t\treduced: this.consequent\n\t\t\t});\n\t\t}\n\t\t\n\t\treturn ret;\n\t}\n\n\tpublic static guess(\n\t\t\tselector: string,\n\t\t\trequiredAntecedents: Expr[], antecedents: Expr[],\n\t\t\tright: Expr, as: Expr,\n\t\t\tcontext: ExecutionContext, trace: StackTrace): Expr {\n\t\t\n\t\tif (selector.length == 0) throw Expr.error('wut', trace);\n\n\t\tvar pattern: Expr, instance: Expr;\n\n\t\tif (selector[0] == 'r') {\n\t\t\tif (!as) {\n\t\t\t\tthrow Expr.error(`Cannot dereference @${selector} (at 0): expected output is not given`, trace);\n\t\t\t}\n\n\t\t\tpattern = right;\n\t\t\tinstance = as;\n\t\t} else {\n\t\t\tvar n = Number(selector[0]);\n\n\t\t\tif (!(1 <= n && n <= antecedents.length))\n\t\t\t\tthrow Expr.error(`Cannot dereference @${selector} (at 0): antecedent index out of range`, trace);\n\n\t\t\tpattern = requiredAntecedents[n - 1];\n\t\t\tinstance = antecedents[n - 1];\n\t\t}\n\n\t\treturn (function recurse(\n\t\t\t\tptr: number,\n\t\t\t\tpattern: Expr, instance: Expr,\n\t\t\t\tparams: Parameter[]): Expr {\n\t\t\t\n\t\t\tinstance = instance.expandMeta(true);\n\t\t\t\n\t\t\tif (selector.length <= ptr) return instance;\n\n\t\t\tif (/^[0-9]$/.test(selector[ptr])) {\n\t\t\t\tvar n = Number(selector[ptr]);\n\n\t\t\t\tif (pattern instanceof Tee && instance instanceof Tee) {\n\t\t\t\t\tif (pattern.left.length != instance.left.length) {\n\t\t\t\t\t\tthrow Expr.error(`Cannot dereference @${selector} (at ${ptr}): antecedent length mismatch`, trace);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (!(1 <= n && n <= instance.left.length)) {\n\t\t\t\t\t\tthrow Expr.error(`Cannot dereference @${selector} (at ${ptr}): antecedent index out of range`, trace);\n\t\t\t\t\t}\n\n\t\t\t\t\treturn recurse(ptr + 1, pattern.left[n - 1], instance.left[n - 1], params);\n\t\t\t\t}\n\n\t\t\t\twhile (true) {\n\t\t\t\t\twhile (instance instanceof Variable && instance.expr) {\n\t\t\t\t\t\tinstance = instance.expr;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (!(pattern instanceof Funcall && instance instanceof Funcall)) {\n\t\t\t\t\t\tthrow Expr.error(`Cannot dereference @${selector} (at ${ptr})`, trace);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (pattern.fun.equals(instance.fun, context)) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (!instance.isExpandable(context)) {\n\t\t\t\t\t\tthrow Expr.error(`Cannot dereference @${selector} (at ${ptr}): ${instance}`, trace);\n\t\t\t\t\t}\n\n\t\t\t\t\tinstance = instance.expandOnce(context).expanded;\n\t\t\t\t}\n\n\t\t\t\tif (!(1 <= n && n <= instance.args.length))\n\t\t\t\t\tthrow Expr.error(`Cannot dereference @${selector} (at ${ptr})`, trace);\n\n\t\t\t\treturn recurse(ptr + 1, pattern.args[n - 1], instance.args[n - 1], params);\n\t\t\t} else if (selector[ptr] == 'r') {\n\t\t\t\tif (!(pattern instanceof Tee && instance instanceof Tee)) {\n\t\t\t\t\tthrow Expr.error(`Cannot dereference @${selector} (at ${ptr})`, trace);\n\t\t\t\t}\n\n\t\t\t\treturn recurse(ptr + 1, pattern.right, instance.right, params);\n\t\t\t} else if (selector[ptr] == 'c') {\n\t\t\t\tif (!(\n\t\t\t\t\tpattern instanceof Fun && !pattern.name\n\t\t\t\t\t&& instance instanceof Fun && !instance.name\n\t\t\t\t)) {\n\t\t\t\t\tthrow Expr.error(`Cannot dereference @${selector} (at ${ptr})`, trace);\n\t\t\t\t}\n\n\t\t\t\tif (pattern.length != instance.length) {\n\t\t\t\t\tthrow Expr.error(`Cannot dereference @${selector} (at ${ptr}): parameter length mismatch`, trace);\n\t\t\t\t}\n\n\t\t\t\tvar placeholders = [];\n\n\t\t\t\tfor (var i = 0; i < pattern.length; i++) {\n\t\t\t\t\tif (!pattern.params[i].type.equals(instance.params[i].type)) {\n\t\t\t\t\t\tthrow Expr.error(`Cannot dereference @${selector} (at ${ptr}): parameter type mismatch`, trace);\n\t\t\t\t\t}\n\n\t\t\t\t\tplaceholders.push(new Parameter({\n\t\t\t\t\t\ttex: instance.params[i].tex,\n\t\t\t\t\t\ttype: pattern.params[i].type,\n\t\t\t\t\t\tname: instance.params[i].name,\n\t\t\t\t\t\tselector: null\n\t\t\t\t\t}, trace));\n\t\t\t\t}\n\n\t\t\t\treturn recurse(ptr + 1, pattern.call(placeholders), instance.call(placeholders), placeholders.concat(params));\n\t\t\t} else if (selector[ptr] == 'f') {\n\t\t\t\tif (ptr != selector.length - 1) {\n\t\t\t\t\tthrow Expr.error(`Cannot dereference @${selector} (at ${ptr}): invalid selector`, trace);\n\t\t\t\t}\n\n\t\t\t\t// (($0, $1) => f($0, $1)) -> f\n\t\t\t\tif (instance instanceof Funcall\n\t\t\t\t\t\t&& instance.args.length == params.length\n\t\t\t\t\t\t&& instance.args.every((arg, i) => arg == params[i])) {\n\t\t\t\t\treturn instance.fun;\n\t\t\t\t}\n\n\t\t\t\treturn new Schema({\n\t\t\t\t\tdoc: null,\n\t\t\t\t\ttex: null,\n\t\t\t\t\tannotations: [],\n\t\t\t\t\tschemaType: 'schema',\n\t\t\t\t\tname: null,\n\t\t\t\t\tparams,\n\t\t\t\t\tcontext: new ExecutionContext(),\n\t\t\t\t\tdef$s: [],\n\t\t\t\t\texpr: instance\n\t\t\t\t}, trace);\n\t\t\t}\n\n\t\t\tthrow Expr.error(`Cannot dereference @${selector} (at ${ptr}): invalid selector`, trace);\n\t\t})(1, pattern, instance, []);\n\t}\n\n\tpublic toIndentedString(indent: number, root?: boolean): string {\n\t\tvar antecedents = this.antecedents.map(arg => {\n\t\t\treturn arg.toIndentedString(indent + 1);\n\t\t});\n\t\n\t\tif (antecedents.join('').length <= 50) {\n\t\t\tantecedents = this.antecedents.map(arg => {\n\t\t\t\treturn arg.toIndentedString(indent);\n\t\t\t});\n\t\n\t\t\treturn [\n\t\t\t\t`${this.subject.toIndentedString(indent)}[`,\n\t\t\t\tantecedents.join(', '),\n\t\t\t\t']'\n\t\t\t].join('');\n\t\t}\n\n\t\treturn [\n\t\t\t`${this.subject.toIndentedString(indent)}[`,\n\t\t\t'\\t' + antecedents.join(',\\n' + '\\t'.repeat(indent + 1)),\n\t\t\t']'\n\t\t].join('\\n' + '\\t'.repeat(indent));\n\t\t\n\t}\n\n\tpublic toTeXString(prec?: Precedence, root?: boolean): string {\n\t\treturn `${this.subject.toTeXString(false)}[${this.antecedents.map(e => e.toTeXString(Expr.PREC_COMMA)).join(', ')}]`;\n\t}\n}","import Counter from \"../Counter\";\nimport ExecutionContext from \"../ExecutionContext\";\nimport { ProofType } from \"../ProofType\";\nimport StackTrace from \"../StackTrace\";\nimport $Variable from \"./$Variable\";\nimport Expr0 from \"./Expr0\";\nimport Fun from \"./Fun\";\nimport Expr, { EqualsPriority, Precedence } from \"./Expr\";\nimport Variable from \"./Variable\";\n\ninterface WithArgumentType {\n\tvariable: Variable;\n\tdef$s: $Variable[];\n\texpr: Expr;\n}\n\nexport default class With extends Expr {\n\n\tpublic readonly variable: Variable;\n\tpublic readonly def$s: $Variable[];\n\tpublic readonly expr: Expr;\n\n\tconstructor({variable, def$s, expr}: WithArgumentType, trace: StackTrace) {\n\t\tsuper(null, null, expr.type, trace);\n\n\t\tthis.variable = variable;\n\t\tthis.def$s = def$s;\n\t\tthis.expr = expr;\n\t}\n\n\tpublic substitute(map: Map<Variable, Expr0>): Expr {\n\t\tif (map.has(this.variable))\n\t\t\tthrow Error('Parameter collision');\n\t\t\n\t\tmap = new Map(map);\n\n\t\treturn this.expandMeta(false).substitute(map);\n\t}\n\n\tprotected expandMetaInternal(andFuncalls: boolean): Expr {\n\t\tvar map = new Map<Variable, Expr0>();\n\t\tmap.set(this.variable, this.variable.expr);\n\n\t\treturn this.expr.substitute(map).expandMeta(andFuncalls);\n\t}\n\n\tprotected getEqualsPriority(context: ExecutionContext): EqualsPriority {\n\t\tthrow new Error(\"Method not implemented.\");\n\t}\n\n\tprotected equalsInternal(obj: Expr, context: ExecutionContext): (Fun | Variable)[] | false {\n\t\tthrow new Error(\"Method not implemented.\");\n\t}\n\n\tprotected isProvedInternal(hypotheses: Expr[]): boolean {\n\t\treturn this.expr.isProved(hypotheses);\n\t}\n\n\tprotected getProofInternal(hypnumMap: Map<Expr, number>, $Map: Map<Expr, number | [number, number]>, ctr: Counter, root?: boolean): ProofType[] {\n\n\t\t$Map = new Map($Map);\n\n\t\tvar def: ProofType = {\n\t\t\t_type: 'def',\n\t\t\tctr: ctr.next(),\n\t\t\tvar: this.variable\n\t\t};\n\n\t\tvar $lines = this.def$s.map($ => {\n\t\t\tvar lines = $.expr.getProof(hypnumMap, $Map, ctr);\n\t\t\tvar $num = lines[lines.length - 1].ctr;\n\t\t\t$Map.set($, $num);\n\t\t\treturn lines;\n\t\t}).flat(1);\n\n\t\treturn [\n\t\t\tdef,\n\t\t\t...$lines,\n\t\t\t...this.expr.getProof(hypnumMap, $Map, ctr)\n\t\t];\n\t}\n\n\tpublic toIndentedString(indent: number, root?: boolean): string {\n\t\tthrow new Error(\"Method not implemented.\");\n\t}\n\n\tpublic toTeXString(prec?: Precedence, root?: boolean): string {\n\t\tthrow new Error(\"Method not implemented.\");\n\t}\n}","import Counter from \"./Counter\";\nimport Expr from \"./exprs/Expr\";\nimport Schema from \"./exprs/Schema\";\nimport Variable from \"./exprs/Variable\";\nimport { ProofType } from \"./ProofType\";\nimport Scope from \"./Scope\";\n\nexport default class ProofExplorer {\n\tpublic static get(scope: Scope, name: string, ktx): string {\n\t\tvar DIAMOND = '&#x25C7;',\n\t\t\tDOWN = '&#x25BC;';\n\t\t// var UP = '&#x25B2;';\n\t\t\n\t\tif (!scope.hasSchema(name)) {\n\t\t\tthrow Error('wut');\n\t\t}\n\t\n\t\tvar expr = scope.getSchema(name);\n\n\t\tif (!(expr instanceof Schema)) {\n\t\t\tthrow Error('wut');\n\t\t}\n\n\t\tfunction getHtmlLine(ctr: string | number, left: any[], h1: string, h2: string | string[], options?) {\n\t\t\tvar padding = left.length;\n\n\t\t\tvar {bbb=false, rrb=false} = options || {};\n\t\n\t\t\tvar htmlLeft = left.map((e, i, a) => `<td class=\"${rrb && i == a.length - 1 ? 'rrb' : 'brb'}\">${e.map(f => ktx(f.toTeXStringWithId(true))).join(', ')}</td>`).join('');\n\n\t\t\tfor (var i = 0; i < left.length; i++)\n\t\t\t\twhile(left[i].length) left[i].pop();\n\t\n\t\t\treturn `<tr><th>${ctr}</th>${htmlLeft}<td ${bbb ? 'class=\"bbb\" ' : ''}colspan=\"${ncols-padding}\">${h1}</td>${h2 instanceof Array ? h2.map(e => `<td>${e}</td>`).join('') : `<td colspan=\"2\">${h2}</td>`}</tr>`;\n\t\t}\n\n\t\tfunction exprToHtml(expr: number | [number, number] | Expr, expand?: boolean): string {\n\t\t\tif (typeof expr == 'number') return `<b>${expr}</b>`;\n\t\t\tif (expr instanceof Array) return `<b>${expr[0]}&ndash;${expr[1]}</b>`;\n\t\t\tif (expand) return ktx(expr.expandMeta(true).toTeXString(true, true));\n\t\t\t\n\t\t\treturn ktx(expr.toTeXString(true, true));\n\t\t}\n\n\t\tvar tree = expr.getProof(new Map(), new Map(), new Counter(), true);\n\n\t\tvar innertree: ProofType[] = (tree[0] as any).$lines.concat((tree[0] as any).lines);\n\n\t\tvar ncols = (function recurse(tree: ProofType[]): number {\n\t\t\treturn Math.max(...tree.map(t => {\n\t\t\t\tswitch (t._type) {\n\t\t\t\t\tcase 'V':\n\t\t\t\t\t\treturn Math.max(\n\t\t\t\t\t\t\trecurse(t.$lines),\n\t\t\t\t\t\t\trecurse(t.lines)\n\t\t\t\t\t\t) + 1;\n\t\t\t\t\tcase 'T':\n\t\t\t\t\t\treturn Math.max(\n\t\t\t\t\t\t\trecurse(t.leftlines),\n\t\t\t\t\t\t\trecurse(t.rightlines)\n\t\t\t\t\t\t) + 1;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\treturn 1;\n\t\t\t\t}\n\t\t\t}));\n\t\t})(innertree);\n\n\t\tvar html = '<table class=\"explorer\">';\n\t\thtml += `<tr><th>#</th><th colspan=\"${ncols}\">expr</th><th colspan=\"2\">rule</th></tr>`;\n\t\t\n\t\thtml += (function tree2html(lines: ProofType[], left: Variable[][]) {\n\t\t\treturn lines.map(line => {\n\t\t\t\tswitch (line._type) {\n\t\t\t\t\tcase 'V':\n\t\t\t\t\t\t// getHtmlLine 함수가 이 배열을 조작하기 때문에\n\t\t\t\t\t\t// shallow copy 해야 한다.\n\t\t\t\t\t\tvar params = line.params.slice();\n\t\t\t\t\t\treturn tree2html(line.$lines, left.concat([params]))\n\t\t\t\t\t\t\t+ tree2html(line.lines, left.concat([params]));\n\t\t\t\t\tcase 'T':\n\t\t\t\t\t\tvar newleft = left.concat([[]]);\n\n\t\t\t\t\t\tvar ret = '';\n\n\t\t\t\t\t\tif (line.leftlines.length == 0) {\n\t\t\t\t\t\t\tvar emptyleft = Array(left.length + 1).fill([]);\n\n\t\t\t\t\t\t\tret += getHtmlLine(\n\t\t\t\t\t\t\t\t'', emptyleft, '', '', {bbb: true, rrb: true}\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tret += line.leftlines.map((line, i, a) => {\n\t\t\t\t\t\t\t\treturn getHtmlLine(\n\t\t\t\t\t\t\t\t\tline.ctr,\n\t\t\t\t\t\t\t\t\tnewleft,\n\t\t\t\t\t\t\t\t\texprToHtml(line.expr, true),\n\t\t\t\t\t\t\t\t\t'assumption',\n\t\t\t\t\t\t\t\t\t{bbb: i == a.length - 1, rrb: true}\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t}).join('');\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tret += tree2html(\n\t\t\t\t\t\t\tline.rightlines,\n\t\t\t\t\t\t\tnewleft\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\treturn ret;\n\t\t\t\t\tcase '?':\n\t\t\t\t\t\treturn getHtmlLine(\n\t\t\t\t\t\t\tline.ctr,\n\t\t\t\t\t\t\tleft,\n\t\t\t\t\t\t\texprToHtml(line.expr, true),\n\t\t\t\t\t\t\t'???'\n\t\t\t\t\t\t);\n\t\t\t\t\tcase 'H':\n\t\t\t\t\t\tthrow Error('no');\n\t\t\t\t\tcase 'R':\n\t\t\t\t\t\treturn getHtmlLine(\n\t\t\t\t\t\t\tline.ctr,\n\t\t\t\t\t\t\tleft,\n\t\t\t\t\t\t\texprToHtml(line.expr, true),\n\t\t\t\t\t\t\t[DIAMOND, exprToHtml(line.num)]\n\t\t\t\t\t\t);\n\t\t\t\t\tcase 'RS':\n\t\t\t\t\tcase 'RCX':\n\t\t\t\t\t\treturn getHtmlLine(\n\t\t\t\t\t\t\tline.ctr,\n\t\t\t\t\t\t\tleft,\n\t\t\t\t\t\t\texprToHtml(line.expr, true),\n\t\t\t\t\t\t\t[DIAMOND, exprToHtml(line.expr)]\n\t\t\t\t\t\t);\n\t\t\t\t\tcase 'RC':\n\t\t\t\t\t\treturn getHtmlLine(\n\t\t\t\t\t\t\tline.ctr,\n\t\t\t\t\t\t\tleft,\n\t\t\t\t\t\t\texprToHtml(line.expr, true),\n\t\t\t\t\t\t\t[DIAMOND, `${exprToHtml(line.schema)} (${line.args.map(a => exprToHtml(a)).join(', ')})`]\n\t\t\t\t\t\t);\n\t\t\t\t\tcase 'E':\n\t\t\t\t\t\treturn getHtmlLine(\n\t\t\t\t\t\t\tline.ctr,\n\t\t\t\t\t\t\tleft,\n\t\t\t\t\t\t\texprToHtml(line.reduced, true),\n\t\t\t\t\t\t\t[DOWN, `${exprToHtml(line.subject)}${line.args ? ' (' + line.args.map(a => exprToHtml(a)).join(', ') + ')' : ''} [${line.antecedents.map(a => exprToHtml(a)).join(', ')}]`]\n\t\t\t\t\t\t);\n\t\t\t\t\tcase 'NP':\n\t\t\t\t\t\treturn getHtmlLine(\n\t\t\t\t\t\t\tline.ctr,\n\t\t\t\t\t\t\tleft,\n\t\t\t\t\t\t\texprToHtml(line.expr, true),\n\t\t\t\t\t\t\t'<b class=\"red\">not proved</b>'\n\t\t\t\t\t\t);\n\t\t\t\t\tcase 'def':\n\t\t\t\t\t\treturn getHtmlLine(\n\t\t\t\t\t\t\tline.ctr,\n\t\t\t\t\t\t\tleft,\n\t\t\t\t\t\t\texprToHtml(line.var),\n\t\t\t\t\t\t\t'definition'\n\t\t\t\t\t\t);\n\t\t\t\t\tcase 'bydef':\n\t\t\t\t\t\treturn getHtmlLine(\n\t\t\t\t\t\t\tline.ctr,\n\t\t\t\t\t\t\tleft,\n\t\t\t\t\t\t\texprToHtml(line.expr),\n\t\t\t\t\t\t\t`by definition of ${line.of.map(v => {\n\t\t\t\t\t\t\t\treturn exprToHtml(v);\n\t\t\t\t\t\t\t}).join(', ')} [${exprToHtml(line.ref)}]`\n\t\t\t\t\t\t);\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tthrow Error(`Unknown type ${(line as any)._type}`);\n\t\t\t\t}\n\t\t\t}).join('');\n\t\t})(innertree, []);\n\t\t\n\t\thtml += '</table>';\n\t\n\t\treturn html;\n\t}\n}","export default class Counter {\n\n\tprivate n: number;\n\n\tconstructor (start: number=0) {\n\t\tthis.n = start;\n\t}\n\n\tpublic peek(): number {\n\t\treturn this.n;\n\t}\n\n\tpublic next(): number {\n\t\treturn ++this.n;\n\t}\n}","import $Variable from './exprs/$Variable';\nimport Fun from './exprs/Fun';\nimport Expr from './exprs/Expr';\nimport ObjectFun from './exprs/ObjectFun';\nimport Schema from './exprs/Schema';\nimport { FunctionalObjectType, ObjectType, SimpleObjectType } from './exprs/types';\nimport Variable from './exprs/Variable';\nimport { LocationObject } from './PegInterfaceDefinitions';\nimport StackTrace from './StackTrace';\n\nexport type NestedTypeInput = string | NestedTypeInput[];\n\n/**\n * 변수 영역(scope).\n * 구문 분석 과정에서 name resolution을 할 때에만 사용해야 한다.\n */\nexport default class Scope {\n\tpublic readonly importMap: Map<string, Scope> = new Map();\n\n\tpublic readonly typedefMap: Map<string, ObjectType> = new Map();\n\tpublic readonly defMap: Map<string, Variable | ObjectFun> = new Map();\n\tpublic readonly schemaMap: Map<string, Schema> = new Map();\n\tpublic readonly $Map: Map<string, $Variable> = new Map();\n\tpublic readonly hypotheses: Expr[] = [];\n\n\tpublic readonly parent: Scope;\n\tpublic readonly root: Scope;\n\n\tpublic readonly trace: StackTrace;\n\n\t/** 파일 경로. 예를 들어 `/propositional.math`이다. 파일과 일대일대응이어야 한다. */\n\tpublic readonly fileUri: string;\n\n\tconstructor (fileUri: string, parent: Scope, trace?: StackTrace) {\n\t\tthis.fileUri = fileUri;\n\n\t\tthis.parent = parent;\n\t\tthis.root = parent ? parent.root : this;\n\n\t\tif (trace && !(trace instanceof StackTrace)) {\n\t\t\tthrow Error('Assertion failed');\n\t\t}\n\n\t\tthis.trace = trace || new StackTrace(fileUri);\n\t}\n\n\tpublic extend(type: string, name: string, location: LocationObject): Scope {\n\t\tvar child = new Scope(this.fileUri, this, this.trace.extend({type, name, location}));\n\t\tthis.hypotheses.forEach(h => child.hypotheses.push(h));\n\t\treturn child;\n\t}\n\n\tpublic error(message: string): Error {\n\t\treturn this.trace.error(message);\n\t}\n\n\t/*\n\t * Possible input values:\n\t * 'st'\t\t\t\t\t\t-> st\n\t * ['cls', 'st']\t\t\t-> [cls -> st]\n\t * ['cls', 'cls', 'st']\t\t-> [(cls, cls) -> st]\n\t * [['cls', 'st'], 'st']\t-> [[cls -> st] -> st]\n\t */\n\tpublic hasOwnType(name: NestedTypeInput): boolean {\n\t\tif (typeof name == 'string') {\n\t\t\treturn this.typedefMap.has(name)\n\t\t\t\t|| [...this.importMap.values()].some(s => s.hasOwnType(name));\n\t\t}\n\n\t\tif (!(name instanceof Array))\n\t\t\tthrow this.error('Argument is malformed');\n\n\t\tif (name.length < 2)\n\t\t\tthrow this.error('Illegal array length');\n\n\t\treturn name.map(e => {\n\t\t\treturn this.hasOwnType(e);\n\t\t}).every(e => e);\n\t}\n\n\t/*\n\t * Possible input values:\n\t * 'st'\t\t\t\t\t\t-> st\n\t * ['cls', 'st']\t\t\t-> [cls -> st]\n\t * ['cls', 'cls', 'st']\t\t-> [(cls, cls) -> st]\n\t * [['cls', 'st'], 'st']\t-> [[cls -> st] -> st]\n\t */\n\tpublic hasType(name: NestedTypeInput): boolean {\n\t\tif (typeof name == 'string') {\n\t\t\treturn this.hasOwnType(name)\n\t\t\t\t|| (!!this.parent && this.parent.hasType(name));\n\t\t}\n\n\t\tif (!(name instanceof Array))\n\t\t\tthrow this.error('Argument is malformed');\n\n\t\tif (name.length < 2)\n\t\t\tthrow this.error('Illegal array length');\n\n\t\treturn name.map(e => {\n\t\t\treturn this.hasType(e);\n\t\t}).every(e => e);\n\t}\n\n\tpublic addType(type: SimpleObjectType): SimpleObjectType {\n\t\tif (!(type instanceof SimpleObjectType))\n\t\t\tthrow this.error('Illegal argument type');\n\n\t\tif (!type.name)\n\t\t\tthrow this.error('Something\\'s wrong');\n\n\t\tif (this.hasOwnType(type.name))\n\t\t\tthrow this.error(`Type ${type.name} has already been declared`);\n\n\t\tthis.typedefMap.set(type.name, type);\n\t\treturn type;\n\t}\n\n\t/*\n\t * Possible input values:\n\t * 'st'\t\t\t\t\t\t-> st\n\t * ['cls', 'st']\t\t\t-> [cls -> st]\n\t * ['cls', 'cls', 'st']\t\t-> [(cls, cls) -> st]\n\t * [['cls', 'st'], 'st']\t-> [[cls -> st] -> st]\n\t */\n\tpublic getType(name: NestedTypeInput): ObjectType {\n\t\tif (typeof name == 'string') {\n\t\t\tif (!this.hasType(name))\n\t\t\t\tthrow this.error(`Type ${name} is not defined`);\n\n\t\t\treturn this.typedefMap.has(name)\n\t\t\t\t? this.typedefMap.get(name)\n\t\t\t\t: (!!this.parent && this.parent.getType(name))\n\t\t\t\t\t|| [...this.importMap.values()].filter(s => {\n\t\t\t\t\t\treturn s.hasType(name)\n\t\t\t\t\t})[0].getType(name);\n\t\t}\n\n\t\tif (!(name instanceof Array))\n\t\t\tthrow this.error('Argument is malformed');\n\n\t\tif (name.length < 2)\n\t\t\tthrow this.error('Illegal array length');\n\n\t\tvar from = name.slice(0, name.length - 1).map(e => {\n\t\t\treturn this.getType(e);\n\t\t});\n\n\t\tvar to = this.getType(name[name.length - 1]);\n\n\t\treturn new FunctionalObjectType({\n\t\t\tfrom,\n\t\t\tto\n\t\t}, this.trace);\n\t}\n\n\tpublic hasOwnVariable(name: string): boolean {\n\t\treturn this.defMap.has(name)\n\t\t\t|| [...this.importMap.values()].some(s => s.hasOwnVariable(name));\n\t}\n\n\tpublic hasVariable(name: string): boolean {\n\t\treturn this.hasOwnVariable(name)\n\t\t\t|| (!!this.parent && this.parent.hasVariable(name));\n\t}\n\n\tpublic addVariable(variable: Variable | Fun): Variable | Fun {\n\t\tif (!(variable instanceof Variable))\n\t\t\tthrow this.error('Illegal argument type');\n\n\t\tif (this.hasOwnVariable(variable.name))\n\t\t\tthrow this.error(`Definition ${variable.name} has already been declared`);\n\n\t\tthis.defMap.set(variable.name, variable);\n\t\treturn variable;\n\t}\n\n\tpublic addFun(fun: ObjectFun): ObjectFun {\n\t\tif (!(fun instanceof ObjectFun))\n\t\t\tthrow this.error('Illegal argument type');\n\n\t\tif (!fun.name)\n\t\t\tthrow this.error('Cannot add anonymous fun to scope');\n\n\t\tif (this.hasOwnVariable(fun.name))\n\t\t\tthrow this.error(`Definition ${fun.name} has already been declared`);\n\n\t\tthis.defMap.set(fun.name, fun);\n\t\treturn fun;\n\t}\n\n\tpublic getVariable(name: string): Variable | ObjectFun {\n\t\tif (!this.hasVariable(name))\n\t\t\tthrow this.error(`Definition ${name} is not defined`);\n\n\t\treturn this.defMap.has(name)\n\t\t\t? this.defMap.get(name)\n\t\t\t: (!!this.parent && this.parent.getVariable(name))\n\t\t\t\t|| [...this.importMap.values()].filter(s => {\n\t\t\t\t\treturn s.hasVariable(name)\n\t\t\t\t})[0].getVariable(name);\n\t}\n\n\tpublic hasOwnSchema(name: string): boolean {\n\t\treturn this.schemaMap.has(name) || this.defMap.has(name)\n\t\t\t|| [...this.importMap.values()].some(s => s.hasOwnSchema(name));\n\t}\n\n\tpublic hasSchema(name: string): boolean {\n\t\treturn this.hasOwnSchema(name)\n\t\t\t|| (!!this.parent && this.parent.hasSchema(name));\n\t}\n\n\tpublic addSchema(schema: Schema): Schema {\n\t\tif (!(schema instanceof Fun))\n\t\t\tthrow this.error('Illegal argument type');\n\n\t\tif (this.hasOwnSchema(schema.name))\n\t\t\tthrow this.error(`Schema ${schema.name} has already been declared`);\n\n\t\tthis.schemaMap.set(schema.name, schema);\n\t\treturn schema;\n\t}\n\n\tpublic getSchema(name: string): Variable | Fun {\n\t\tif (!this.hasSchema(name))\n\t\t\tthrow this.error(`Schema ${name} is not defined`);\n\n\t\treturn this.schemaMap.has(name)\n\t\t\t? this.schemaMap.get(name)\n\t\t\t: this.defMap.has(name)\n\t\t\t\t? this.defMap.get(name)\n\t\t\t\t: (!!this.parent && this.parent.getSchema(name))\n\t\t\t\t\t|| [...this.importMap.values()].filter(s => {\n\t\t\t\t\t\treturn s.hasSchema(name)\n\t\t\t\t\t})[0].getSchema(name);\n\t}\n\n\tpublic hasOwn$(name: string): boolean {\n\t\treturn this.$Map.has(name)\n\t\t\t|| [...this.importMap.values()].some(s => s.hasOwn$(name));\n\t}\n\n\tpublic has$(name: string): boolean {\n\t\treturn this.hasOwn$(name)\n\t\t\t|| (!!this.parent && this.parent.has$(name));\n\t}\n\n\tpublic add$($: $Variable): $Variable {\n\t\tif (!($ instanceof $Variable))\n\t\t\tthrow this.error('Illegal argument type');\n\n\t\tif (this.hasOwn$($.name))\n\t\t\tthrow this.error(`$ variable ${$.name} has already been declared`);\n\n\t\tthis.$Map.set($.name, $);\n\t\treturn $;\n\t}\n\n\tpublic get$(name: string): $Variable {\n\t\tif (!this.has$(name))\n\t\t\tthrow this.error(`$ variable ${name} is not defined`);\n\n\t\treturn this.$Map.has(name)\n\t\t\t? this.$Map.get(name)\n\t\t\t: (!!this.parent && this.parent.get$(name))\n\t\t\t\t|| [...this.importMap.values()].filter(s => {\n\t\t\t\t\treturn s.has$(name)\n\t\t\t\t})[0].get$(name);\n\t}\n}","import { LocationObject } from \"./PegInterfaceDefinitions\";\n\ninterface StackTraceElement {\n\ttype: string;\n\tname: string;\n\tlocation: LocationObject;\n}\n\nexport default class StackTrace {\n\n\tpublic readonly fileUri: string;\n\tpublic readonly stack: StackTraceElement[];\n\n\tconstructor (fileUri: string, stack?: StackTraceElement[]) {\n\t\tthis.fileUri = fileUri;\n\t\tthis.stack = stack || [];\n\t}\n\n\tpublic extend(element: StackTraceElement): StackTrace {\n\t\treturn new StackTrace(this.fileUri, [element].concat(this.stack));\n\t}\n\n\tpublic error(message: string) {\n\t\tvar fileUri = this.fileUri || '<unknown>';\n\n\t\treturn new Error(\n\t\t\tmessage\n\t\t\t+ '\\n\\tat '\n\t\t\t+ (\n\t\t\t\tthis.stack.length\n\t\t\t\t\t? this.stack.map(({type, name, location}) => {\n\t\t\t\t\t\treturn `${type} ${name || '<anonymous>'} (${fileUri}:${location.start.line}:${location.start.column})`;\n\t\t\t\t\t}).join('\\n\\tat ')\n\t\t\t\t\t: `<root> (${fileUri}:1:1)`\n\t\t\t)\n\t\t);\n\t}\n}"],"sourceRoot":""}