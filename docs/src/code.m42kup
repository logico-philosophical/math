[=코드를 작성하는 법]

저장소에서 [;/web/code.math]를 보면 많은 예시가 있다.

[==논리식의 문법을 정의하는 방법]

math-o-matic 상에서 대상언어의 문장이나 단어에는 타입이 있어야 한다. 그러므로 타입을 먼저 정의해야 한다.

[;;
"문장 타입."
[**base] [**type] st;]

타입 선언은 [;type <타입 이름>;]이라 하면 되고 문장 타입일 경우 [;base]를 붙인다. 문장 타입은 언어마다 하나만 있을 수 있다. 타입에 관한 설명을 큰따옴표 안에 작성할 수 있다.

이때 말단 기호는 다음과 같이 선언할 수 있다.

[;;
"verum (T). 즉 임의의 항진명제를 표시한다."
$\top$
st T;]

[$\LaTeX] 코드를 [;$]로 감싸서 기호가 어떻게 보이는지를 바꿀 수 있다. 위의 예시는 [;T] 변수가 [$\top]처럼 표시되게 하였다.

말단 기호가 아닌 것은 다음과 같이 선언할 수 있다.

[;;
"and (TFFF)."
$!<prec=596>#1<<\land>>#2$
st A(st p, st q);
]

[;!<prec=596>]은 [$\land]의 연산자 우선순위를 596으로 하겠다는 뜻이다. 연산자 우선순위 문맥에 따라 표시할 때 괄호가 필요한지가 결정된다. [;#1]과 [;#2]는 각각 첫 번째와 두 번째 인자가 표시될 위치를 표시한다. [;<<]와 [;>>]는 클릭 되는 부분을 표시한다.

또는

[;;`[(st, st) -> st] A;`]

라 써도 될 것이다. 이때 [;`[(st, st) -> st]`]는 [;st] 두 개를 받아 [;st]를 뱉는 함수형 타입이다. 그러나 저 위에 방법으로 쓰는 것이 좋을 것이다.

무정의용어가 아닌 매크로를 정의할 수도 있는데 매크로의 정의는 본체를 가진다. 다음과 같다.

[;;
"pr 타입을 위한 A."
$\left(#1<<\land>>#2\right)$
pr Af(pr f, pr g) {
	(cls z) => { A(f(z), g(z)) }
}]

[;.(...) => {...}]는 인라인에서 매크로를 정의한 것이다.

[==공리와 증명을 작성하는 방법]

공리는 다음과 같이 작성한다.

[;;
"연언 도입(conjunction introduction)."
[**axiom] `Ai(st p: @1, st q: @2) {
	p, q |- A(p, q)
}`]

공리라서 [;axiom]이 붙었다. [;|-]가 [$\vdash]를 나타낸다. [;@1]과 [;@2]는 ⊦E 구문을 쓸 때 인자가 자동으로 인식되도록 하기 위한 것이다. 공리를 그냥 정의할 수는 없고 공리 스키마로 감싸야 한다. 정리 역시 그러하다. 예를 들어 다음과 같이 인자 없는 스키마로 감싸면 된다.

[;;
"axiom of empty set."
[**axiom] ax_emptyset() {
	|- set(emptyset)
}]

증명은 다음과 같이 작성한다.

[;;
"연언 도입 2번."
[**theorem]` A3i(st p: @1, st q: @2, st r: @3) {
	p, q, r |- Ai[Ai[@h1, @h2], @h3]
}`
]

[;@h1], [;@h2], [;@h3]이 각각 1[&ndash]3번째 가정 [;p], [;q], [;r]을 나타낸다. [;`Ai[@h1, @h2]`]가 [;`Ai[p, q]`]인데, 이는 [;`Ai(p, q)[p, q]`]가 인자 생략된 것이다. 즉 [;`(p, q |- A(p, q))[p, q]`]인데, 대괄호를 쓴 것이 ⊦E 구문을 적용하라는 뜻으로 [;p, q]를 [;|-]의 좌변과 비교하여 같으면 [;A(p, q)]가 증명되는 방식이다. 그러므로 [;`Ai[@h1, @h2]`]가 [;A(p, q)]가 되고, [;`Ai[A(p, q), r]`]이 [;A(A(p, q), r)]이 된다. 즉 Fitch 표기법으로 다음과 같은 증명을 한 것이다.

[<;;
1 ┃ p                      가정
2 ┃ q                      가정
3 ┃ r                      가정
  ┣━━━
4 ┃ p ∧ q                  ⊦E, Ai, [1, 2]
5 ┃ (p ∧ q) ∧ r           ⊦E, Ai, [4, 3]
6 p, q, r ⊦ (p ∧ q) ∧ r    ⊦I [1[<&ndash>]5]
>]

이는 증명탐색기에 표시되는 바와 같다. 증명이 잘 되었는지는 math-o-matic 프로그램이 판단하며 잘 되었으면 초록불이 들어온다.

더 있는데 [***귀찮다]. [;/web/code.math]의 코드 예시를 보면 될 듯하다.