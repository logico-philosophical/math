import propositional;
import predicate;
import set;
import relation;
import function;
import natural;

"정수 집합의 정의를 위해 사용되는 이항관계."
${\sim}_{\omega\times\omega}$
cls rel_omega_pair = setbuilder_pair((cls x, cls y) => {
	Xin4(omega, omega, omega, omega, (cls a, cls b, $a'$ cls ap, $b'$ cls bp) => A(A(eq(x, pair(a, b)), eq(y, pair(ap, bp))), eq(omega_add(a, bp), omega_add(ap, b))))
});

theorem rel_omega_pair_is_rel() {
	(cls z) => {
		in(z, rel_omega_pair) |- {
			$X = @h1 > setbuilder_e as X2((cls x, cls y) => A(
				eq(z, pair(x, y)),
				Xin4(omega, omega, omega, omega, (cls a, cls b, $a'$ cls ap, $b'$ cls bp) => {
					A(
						A(
							eq(x, pair(a, b)),
							eq(y, pair(ap, bp))
						),
						eq(omega_add(a, bp), omega_add(ap, b))
					)
				})
			));

			$U = (cls x, cls y) => {
				eq(z, pair(x, y)),
				Xin4(omega, omega, omega, omega, (cls a, cls b, $a'$ cls ap, $b'$ cls bp) => {
					A(
						A(
							eq(x, pair(a, b)),
							eq(y, pair(ap, bp))
						),
						eq(omega_add(a, bp), omega_add(ap, b))
					)
				}) |- {
					$U = (cls a) => { in(a, omega) /* @h4 */ |- {
					(cls b) => { in(b, omega) |- {
					($a'$ cls ap) => { in(ap, omega) |- {
					($b'$ cls bp) => { in(bp, omega) |- {
						eq(x, pair(a, b)) /* @h8 */, eq(y, pair(ap, bp)), eq(omega_add(a, bp), omega_add(ap, b)) |- {
							$x_in_om_om = [@h8; [@h4; @h5] > cartesian_in_i] > eq_in;
							$y_in_om_om = [@h9; [@h6; @h7] > cartesian_in_i] > eq_in;

							[@h2; [$x_in_om_om; $y_in_om_om] > cartesian_in_i] > eq_in
						} > cp3
					} > cp } > Ui
					} > cp } > Ui
					} > cp } > Ui
					} > cp } > Ui as Uin4(omega, omega, omega, omega, (cls a, cls b, $a'$ cls ap, $b'$ cls bp) => {
						I(
							A(
								A(
									eq(x, pair(a, b)),
									eq(y, pair(ap, bp))
								),
								eq(omega_add(a, bp), omega_add(ap, b))
							),
							in(z, cartesian(cartesian(omega, omega), cartesian(omega, omega)))
						)
					});

					[@h3; $U] > mpXin4_alt as in(z, cartesian(cartesian(omega, omega), cartesian(omega, omega)))
				} > cp2
			} > Ui2;

			[$X; $U] > mpX2_alt as in(z, cartesian(cartesian(omega, omega), cartesian(omega, omega)))
		} > cp
	} > Ui as is_rel_over_set(rel_omega_pair, cartesian(omega, omega))
}

theorem rel_omega_pair_is_reflexive() {
	(cls x) => {
		in(x, cartesian(omega, omega)) |- {
			$X = @h1 > setbuilder_e;

			$U = (cls a, cls b) => {
				eq(x, pair(a, b)), A(in(a, omega), in(b, omega)) |- {
					$a_in_omega = @h3 > Ae1;
					$b_in_omega = @h3 > Ae2;

					$set_x = @h1 > is_set_i;
					$set_xx = [$set_x; $set_x] > pair_set_i;

					$X4 = [
						$a_in_omega; $b_in_omega; $a_in_omega; $b_in_omega;
						[[@h2; @h2] > Ai; eq_reflexive(omega_add(a, b))] > Ai
					] > Xin4i as Xin4(omega, omega, omega, omega, (cls a, cls b, $a'$ cls ap, $b'$ cls bp) => {
						A(
							A(eq(x, pair(a, b)), eq(x, pair(ap, bp))),
							eq(omega_add(a, bp), omega_add(ap, b))
						)
					});

					[$set_xx; $X4] > setbuilder_pair_i as rel_call(rel_omega_pair, x, x)
				} > cp2
			} > Ui2;

			[$X; $U] > mpX2_alt as rel_call(rel_omega_pair, x, x)
		} > cp
	} > Ui as rel_reflexive(rel_omega_pair, cartesian(omega, omega))
}

theorem rel_omega_pair_e(cls a: @11, cls b: @21, $a'$ cls ap: @31, $b'$ cls bp: @41) {
	in(a, omega), in(b, omega), in(ap, omega), in(bp, omega),
	rel_call(rel_omega_pair, pair(a, b), pair(ap, bp)) |- {
		$X = @h5 > setbuilder_pair_e as Xin4(omega, omega, omega, omega, (cls c, cls d, $c'$ cls cp, $d'$ cls dp) => {
			A(
				A(
					eq(pair(a, b), pair(c, d)),
					eq(pair(ap, bp), pair(cp, dp))
				),
				eq(omega_add(c, dp), omega_add(cp, d))
			)
		});
		
		$U = (cls c, cls d, $c'$ cls cp, $d'$ cls dp) => {
			A(
				eq(pair(a, b), pair(c, d)),
				eq(pair(ap, bp), pair(cp, dp))
			),
			eq(omega_add(c, dp), omega_add(cp, d)) |- {
				$set_a = @h1 > is_set_i; $set_b = @h2 > is_set_i;
				$set_ap = @h3 > is_set_i; $set_bp = @h4 > is_set_i;
				$set_ab = [$set_a; $set_b] > pair_set_i;
				$set_apbp = [$set_ap; $set_bp] > pair_set_i;

				$ab_is_cd = @h6 > Ae1;
				$apbp_is_cpdp = @h6 > Ae2;

				$a_is_c = [$set_ab; $ab_is_cd] > pair_eq_e1_v1;
				$b_is_d = [$set_ab; $ab_is_cd] > pair_eq_e2_v1;
				$ap_is_cp = [$set_apbp; $apbp_is_cpdp] > pair_eq_e1_v1;
				$bp_is_dp = [$set_apbp; $apbp_is_cpdp] > pair_eq_e2_v1;

				[
					[$a_is_c; $bp_is_dp] > omega_add_eq_i;
					@h7;
					[$ap_is_cp; $b_is_d] > omega_add_eq_i > eq_symmetric
				] > eq_transitive_3
			} > cp2
		} > Ui4 > U4_to_Uin4(omega, omega, omega, omega, ?);
		
		[$X; $U] > mpXin4_alt as eq(omega_add(a, bp), omega_add(ap, b))
	}
}

theorem int_eq_e(cls a: @11, cls b: @21, $a'$ cls ap: @31, $b'$ cls bp: @41) {
	in(a, omega), in(b, omega), in(ap, omega), in(bp, omega),
	eq(
		equiv_cls(pair(a, b), cartesian(omega, omega), rel_omega_pair),
		equiv_cls(pair(ap, bp), cartesian(omega, omega), rel_omega_pair)
	) |- {
		[
			rel_omega_pair_is_reflexive();
			[@h1; @h2] > cartesian_in_i;
			[@h3; @h4] > cartesian_in_i;
			@h5
		] > equiv_cls_eq_e
	}
}

"정수 집합. 독일어 [*Zahlen]의 Z이다. 자연수 순서쌍의 동치류의 집합으로 정의된다. 이때 자연수 순서쌍의 동치류 [$`[(a, b)]`]가 정수 [$a - b]를 의미한다. 예를 들어 [$`[(3, 5)] = [(5, 7)] = -2`]이다.

@see [~https://en.wikipedia.org/wiki/Integer#Construction]"
$\Z$
cls int = quotient_set(cartesian(omega, omega), rel_omega_pair);

theorem int_in_e(cls n: @11) {
	in(n, int) |- {
		$X = @h1 > setbuilder_e;
		
		$U = (cls z) => {
			eq(n, equiv_cls(z, cartesian(omega, omega), rel_omega_pair)), in(z, cartesian(omega, omega)) |- {
				$X = @h3 > setbuilder_e;

				$U = (cls a, cls b) => {
					eq(z, pair(a, b)), A(in(a, omega), in(b, omega)) |- {
						$a_in_omega = @h5 > Ae1;
						$b_in_omega = @h5 > Ae2;

						[
							$a_in_omega; $b_in_omega;
							[
								@h2;
								@h4 > call_eq_i((cls z) => equiv_cls(z, cartesian(omega, omega), rel_omega_pair), ?, ?)
							] > eq_transitive
						] > Xin2i as Xin2(omega, omega, (cls a, cls b) => eq(n, equiv_cls(pair(a, b), cartesian(omega, omega), rel_omega_pair)))
					} > cp2
				} > Ui2;

				[$X; $U] > mpX2_alt as Xin2(omega, omega, (cls a, cls b) => eq(n, equiv_cls(pair(a, b), cartesian(omega, omega), rel_omega_pair)))
			} > cp2
		} > Ui;
		
		[$X; $U] > mpX_alt as Xin2(omega, omega, (cls a, cls b) => eq(n, equiv_cls(pair(a, b), cartesian(omega, omega), rel_omega_pair)))
	}
}

"정수 덧셈."
$\left(#1<<+_\Z>>#2\right)$
cls int_add(cls m, cls n) {
	instantiate((cls k) => {
		Xin4(omega, omega, omega, omega, (cls a1, cls b1, cls a2, cls b2) => {
			A(A(eq(m, equiv_cls(pair(a1, b1), cartesian(omega, omega), rel_omega_pair)), eq(n, equiv_cls(pair(a2, b2), cartesian(omega, omega), rel_omega_pair))), eq(k, equiv_cls(pair(omega_add(a1, a2), omega_add(b1, b2)), cartesian(omega, omega), rel_omega_pair)))
		})
	})
}