import propositional;
import predicate;
import set;
import relation;
import function;
import natural;

"정수 집합의 정의를 위해 사용되는 이항관계."
${\sim}_{\omega\times\omega}$
cls rel_omega_pair = setbuilder_pair((cls x, cls y) => {
	Xin4(omega, omega, omega, omega, (cls a, cls b, $a'$ cls ap, $b'$ cls bp) => A(A(eq(x, pair(a, b)), eq(y, pair(ap, bp))), eq(omega_add(a, bp), omega_add(ap, b))))
});

theorem rel_omega_pair_is_rel() {
	(cls z) => {
		in(z, rel_omega_pair) |- {
			$X = @h1 > setbuilder_e as X2((cls x, cls y) => A(
				eq(z, pair(x, y)),
				Xin4(omega, omega, omega, omega, (cls a, cls b, $a'$ cls ap, $b'$ cls bp) => {
					A(
						A(
							eq(x, pair(a, b)),
							eq(y, pair(ap, bp))
						),
						eq(omega_add(a, bp), omega_add(ap, b))
					)
				})
			));

			$U = (cls x, cls y) => {
				eq(z, pair(x, y)),
				Xin4(omega, omega, omega, omega, (cls a, cls b, $a'$ cls ap, $b'$ cls bp) => {
					A(
						A(
							eq(x, pair(a, b)),
							eq(y, pair(ap, bp))
						),
						eq(omega_add(a, bp), omega_add(ap, b))
					)
				}) |- {
					$U = (cls a) => { in(a, omega) /* @h4 */ |- {
					(cls b) => { in(b, omega) |- {
					($a'$ cls ap) => { in(ap, omega) |- {
					($b'$ cls bp) => { in(bp, omega) |- {
						eq(x, pair(a, b)) /* @h8 */, eq(y, pair(ap, bp)), eq(omega_add(a, bp), omega_add(ap, b)) |- {
							$x_in_om_om = [@h8; [@h4; @h5] > cartesian_in_i] > eq_in;
							$y_in_om_om = [@h9; [@h6; @h7] > cartesian_in_i] > eq_in;

							[@h2; [$x_in_om_om; $y_in_om_om] > cartesian_in_i] > eq_in
						} > cp3
					} > cp } > Ui
					} > cp } > Ui
					} > cp } > Ui
					} > cp } > Ui as Uin4(omega, omega, omega, omega, (cls a, cls b, $a'$ cls ap, $b'$ cls bp) => {
						I(
							A(
								A(
									eq(x, pair(a, b)),
									eq(y, pair(ap, bp))
								),
								eq(omega_add(a, bp), omega_add(ap, b))
							),
							in(z, cartesian(cartesian(omega, omega), cartesian(omega, omega)))
						)
					});

					[@h3; $U] > mpXin4_alt as in(z, cartesian(cartesian(omega, omega), cartesian(omega, omega)))
				} > cp2
			} > Ui2;

			[$X; $U] > mpX2_alt as in(z, cartesian(cartesian(omega, omega), cartesian(omega, omega)))
		} > cp
	} > Ui as is_rel_over_set(rel_omega_pair, cartesian(omega, omega))
}

theorem rel_omega_pair_is_reflexive() {
	(cls x) => {
		in(x, cartesian(omega, omega)) |- {
			$X = @h1 > setbuilder_e;

			$U = (cls a, cls b) => {
				eq(x, pair(a, b)), A(in(a, omega), in(b, omega)) |- {
					$a_in_omega = @h3 > Ae1;
					$b_in_omega = @h3 > Ae2;

					$set_x = @h1 > is_set_i;
					$set_xx = [$set_x; $set_x] > pair_set_i;

					$X4 = [
						$a_in_omega; $b_in_omega; $a_in_omega; $b_in_omega;
						[[@h2; @h2] > Ai; eq_reflexive(omega_add(a, b))] > Ai
					] > Xin4i as Xin4(omega, omega, omega, omega, (cls a, cls b, $a'$ cls ap, $b'$ cls bp) => {
						A(
							A(eq(x, pair(a, b)), eq(x, pair(ap, bp))),
							eq(omega_add(a, bp), omega_add(ap, b))
						)
					});

					[$set_xx; $X4] > setbuilder_pair_i as rel_call(rel_omega_pair, x, x)
				} > cp2
			} > Ui2;

			[$X; $U] > mpX2_alt as rel_call(rel_omega_pair, x, x)
		} > cp
	} > Ui as rel_reflexive(rel_omega_pair, cartesian(omega, omega))
}

theorem rel_omega_pair_is_symmetric() {
	(cls x, cls y) => {
		in(x, cartesian(omega, omega)), in(y, cartesian(omega, omega)) |- {
			with ([(cls, cls) -> pr4] predicate = (cls x, cls y) => {
				(cls a, cls b, $a'$ cls ap, $b'$ cls bp) => A(
					A(eq(x, pair(a, b)), eq(y, pair(ap, bp))),
					eq(omega_add(a, bp), omega_add(ap, b))
				)
			}) {
				rel_call(rel_omega_pair, x, y) |- {
					$X = @h3 > setbuilder_pair_e as Xin4(omega, omega, omega, omega, predicate(x, y));

					$U = (cls a, cls b, $a'$ cls ap, $b'$ cls bp) => {
						/* @h4 */ in(a, omega), in(b, omega), in(ap, omega), in(bp, omega) |- {
							/* @h8 */ (predicate(x, y))(a, b, ap, bp) |- {
								[
									@h6; @h7; @h4; @h5;
									[@h8 > Ae1 > A_flip; @h8 > Ae2 > eq_symmetric] > Ai
								] > Xin4i as Xin4(omega, omega, omega, omega, predicate(y, x))
							} > cp
						}
					} > Uin4i;

					$f = [$X; $U] > mpXin4_alt as Xin4(omega, omega, omega, omega, predicate(y, x));

					[[@h2 > is_set_i; @h1 > is_set_i] > pair_set_i; $f] > setbuilder_pair_i as rel_call(rel_omega_pair, y, x)
				} > cp
			}
		}
	} > Uin2i as rel_symmetric(rel_omega_pair, cartesian(omega, omega))
}

theorem rel_omega_pair_i(cls a1: @11, cls b1: @21, cls a2: @31, cls b2: @41) {
	in(a1, omega), in(b1, omega), in(a2, omega), in(b2, omega), eq(omega_add(a1, b2), omega_add(a2, b1)) |- {
		with ([(cls, cls) -> pr4] predicate = (cls x, cls y) => {
			(cls a, cls b, $a'$ cls ap, $b'$ cls bp) => A(
				A(eq(x, pair(a, b)), eq(y, pair(ap, bp))),
				eq(omega_add(a, bp), omega_add(ap, b))
			)
		}) {
			$X = [
				@h1; @h2; @h3; @h4;
				[eq_reflexive(pair(a1, b1)); eq_reflexive(pair(a2, b2)); @h5] > A3i
			] > Xin4i as Xin4(omega, omega, omega, omega, predicate(pair(a1, b1), pair(a2, b2)));
			
			[
				[
					[@h1 > is_set_i; @h2 > is_set_i] > pair_set_i;
					[@h3 > is_set_i; @h4 > is_set_i] > pair_set_i
				] > pair_set_i;
				$X
			] > setbuilder_pair_i as rel_call(rel_omega_pair, pair(a1, b1), pair(a2, b2))
		}
	}
}

theorem rel_omega_pair_e(cls a: @11, cls b: @21, $a'$ cls ap: @31, $b'$ cls bp: @41) {
	in(a, omega), in(b, omega), in(ap, omega), in(bp, omega),
	rel_call(rel_omega_pair, pair(a, b), pair(ap, bp)) |- {
		$X = @h5 > setbuilder_pair_e as Xin4(omega, omega, omega, omega, (cls c, cls d, $c'$ cls cp, $d'$ cls dp) => {
			A(
				A(
					eq(pair(a, b), pair(c, d)),
					eq(pair(ap, bp), pair(cp, dp))
				),
				eq(omega_add(c, dp), omega_add(cp, d))
			)
		});
		
		$U = (cls c, cls d, $c'$ cls cp, $d'$ cls dp) => {
			A(
				eq(pair(a, b), pair(c, d)),
				eq(pair(ap, bp), pair(cp, dp))
			),
			eq(omega_add(c, dp), omega_add(cp, d)) |- {
				$set_a = @h1 > is_set_i; $set_b = @h2 > is_set_i;
				$set_ap = @h3 > is_set_i; $set_bp = @h4 > is_set_i;
				$set_ab = [$set_a; $set_b] > pair_set_i;
				$set_apbp = [$set_ap; $set_bp] > pair_set_i;

				$ab_is_cd = @h6 > Ae1;
				$apbp_is_cpdp = @h6 > Ae2;

				$a_is_c = [$set_ab; $ab_is_cd] > pair_eq_e1_v1;
				$b_is_d = [$set_ab; $ab_is_cd] > pair_eq_e2_v1;
				$ap_is_cp = [$set_apbp; $apbp_is_cpdp] > pair_eq_e1_v1;
				$bp_is_dp = [$set_apbp; $apbp_is_cpdp] > pair_eq_e2_v1;

				[
					[$a_is_c; $bp_is_dp] > omega_add_eq_i;
					@h7;
					[$ap_is_cp; $b_is_d] > omega_add_eq_i > eq_symmetric
				] > eq_transitive_3
			} > cp2
		} > Ui4 > U4_to_Uin4(omega, omega, omega, omega, ?);
		
		[$X; $U] > mpXin4_alt as eq(omega_add(a, bp), omega_add(ap, b))
	}
}

theorem int_eq_e(cls a: @11, cls b: @21, $a'$ cls ap: @31, $b'$ cls bp: @41) {
	in(a, omega), in(b, omega), in(ap, omega), in(bp, omega),
	eq(
		equiv_cls(pair(a, b), cartesian(omega, omega), rel_omega_pair),
		equiv_cls(pair(ap, bp), cartesian(omega, omega), rel_omega_pair)
	) |- {
		[
			rel_omega_pair_is_reflexive();
			[@h1; @h2] > cartesian_in_i;
			[@h3; @h4] > cartesian_in_i;
			@h5
		] > equiv_cls_eq_e
	}
}

theorem rel_omega_pair_is_transitive() {
	(cls x, cls y, cls z) => {
		in(x, cartesian(omega, omega)), in(y, cartesian(omega, omega)), in(z, cartesian(omega, omega)) |- {
			with ([(cls, cls) -> pr4] predicate = (cls x, cls y) => {
				(cls a, cls b, $a'$ cls ap, $b'$ cls bp) => A(
					A(eq(x, pair(a, b)), eq(y, pair(ap, bp))),
					eq(omega_add(a, bp), omega_add(ap, b))
				)
			}) {
				/* @h4 */ rel_call(rel_omega_pair, x, y), rel_call(rel_omega_pair, y, z) |- {
					$X = @h4 > setbuilder_pair_e as Xin4(omega, omega, omega, omega, (cls a1, cls b1, cls a2, cls b2) => (predicate(x, y))(a1, b1, a2, b2));

					$U = (cls a1, cls b1, cls a2, cls b2) => {
						/* @h6 */ in(a1, omega), in(b1, omega), in(a2, omega), in(b2, omega) |- {
							/* @h10 */ (predicate(x, y))(a1, b1, a2, b2) |- {
								$X = @h5 > setbuilder_pair_e as Xin4(omega, omega, omega, omega, ($a_2'$ cls a2p, $b_2'$ cls b2p, cls a3, cls b3) => (predicate(y, z))(a2p, b2p,a3, b3));

								$U = ($a_2'$ cls a2p, $b_2'$ cls b2p, cls a3, cls b3) => {
									/* @h11 */ in(a2p, omega), in(b2p, omega), in(a3, omega), in(b3, omega) |- {
										/* @h15 */ (predicate(y, z))(a2p, b2p, a3, b3) |- {
											$a1b2_is_a2b1 = @h10 > Ae2;
											$foo1 = @h10 > Ae1;
											$x_is_a1b1 = $foo1 > Ae1;
											$y_is_a2b2 = $foo1 > Ae2;

											$a2pb3_is_a3b2p = @h15 > Ae2;
											$foo2 = @h15 > Ae1;
											$y_is_a2pb2p = $foo2 > Ae1;
											$z_is_a3b3 = $foo2 > Ae2;

											$a2b2_is_a2pb2p = [$y_is_a2b2 > eq_symmetric; $y_is_a2pb2p] > eq_transitive;
											$foo3 = [@h8 > is_set_i; @h9 > is_set_i; @h11 > is_set_i; @h12 > is_set_i; $a2b2_is_a2pb2p] > pair_eq_e;
											$a2_is_a2p = $foo3 > Ae1;
											$b2_is_b2p = $foo3 > Ae2;

											$a2b3_is_a3b2 = [
												$a2_is_a2p > omega_add_eq_i_right(?, ?, b3);
												$a2pb3_is_a3b2p;
												$b2_is_b2p > omega_add_eq_i_left(a3, ?, ?) > eq_symmetric
											] > eq_transitive_3;

											$foo4 = [
												[@h8; @h9] > omega_add_commutative > omega_add_eq_i_left(omega_add(a1, b3), ?, ?);
												[@h6; @h9; @h8; @h14] > omega_add_inner_to_right > eq_symmetric;
												[$a1b2_is_a2b1; $a2b3_is_a3b2] > omega_add_eq_i;
												[@h8; @h7; @h13; @h9] > omega_add_inner_to_left
											] > eq_transitive_4;

											$foo5 = [
												[
													[@h6; @h14] > omega_add_in_omega;
													[@h7; @h13] > omega_add_in_omega;
													[@h8; @h9] > omega_add_in_omega;
													$foo4
												] > omega_add_eq_e_right;
												[@h7; @h13] > omega_add_commutative
											] > eq_transitive;

											$foo6 = [
												@h6; @h7; @h13; @h14;
												$foo5
											] > rel_omega_pair_i;

											[
												$z_is_a3b3;
												[
													$x_is_a1b1;
													$foo6
												] > ax_indiscernible_m2((cls x) => rel_call(rel_omega_pair, x, pair(a3, b3)), ?, ?)
											] > ax_indiscernible_m2((cls z) => rel_call(rel_omega_pair, x, z), ?, ?)
										} > cp
									}
								} > Uin4i;

								[$X; $U] > mpXin4_alt as rel_call(rel_omega_pair, x, z)
							} > cp
						}
					} > Uin4i;

					[$X; $U] > mpXin4_alt as rel_call(rel_omega_pair, x, z)
				} > cp2
			}
		}
	} > Uin3i as rel_transitive(rel_omega_pair, cartesian(omega, omega))
}

theorem rel_omega_pair_is_equiv_rel() {
	[
		rel_omega_pair_is_rel();
		rel_omega_pair_is_reflexive();
		rel_omega_pair_is_symmetric();
		rel_omega_pair_is_transitive()
	] > equiv_rel_i
}

"정수 집합. 독일어 [*Zahlen]의 Z이다. 자연수 순서쌍의 동치류의 집합으로 정의된다. 이때 자연수 순서쌍의 동치류 [$`[(a, b)]`]가 정수 [$a - b]를 의미한다. 예를 들어 [$`[(3, 5)] = [(5, 7)] = -2`]이다.

@see [~https://en.wikipedia.org/wiki/Integer#Construction]"
$\Z$
cls int = quotient_set(cartesian(omega, omega), rel_omega_pair);

theorem int_in_e(cls n: @11) {
	in(n, int) |- {
		$X = @h1 > setbuilder_e;
		
		$U = (cls z) => {
			eq(n, equiv_cls(z, cartesian(omega, omega), rel_omega_pair)), in(z, cartesian(omega, omega)) |- {
				$X = @h3 > setbuilder_e;

				$U = (cls a, cls b) => {
					eq(z, pair(a, b)), A(in(a, omega), in(b, omega)) |- {
						$a_in_omega = @h5 > Ae1;
						$b_in_omega = @h5 > Ae2;

						[
							$a_in_omega; $b_in_omega;
							[
								@h2;
								@h4 > call_eq_i((cls z) => equiv_cls(z, cartesian(omega, omega), rel_omega_pair), ?, ?)
							] > eq_transitive
						] > Xin2i as Xin2(omega, omega, (cls a, cls b) => eq(n, equiv_cls(pair(a, b), cartesian(omega, omega), rel_omega_pair)))
					} > cp2
				} > Ui2;

				[$X; $U] > mpX2_alt as Xin2(omega, omega, (cls a, cls b) => eq(n, equiv_cls(pair(a, b), cartesian(omega, omega), rel_omega_pair)))
			} > cp2
		} > Ui;
		
		[$X; $U] > mpX_alt as Xin2(omega, omega, (cls a, cls b) => eq(n, equiv_cls(pair(a, b), cartesian(omega, omega), rel_omega_pair)))
	}
}

"정수 덧셈."
$\left(#1<<+_\Z>>#2\right)$
cls int_add(cls m, cls n) {
	instantiate((cls k) => {
		Xin4(omega, omega, omega, omega, (cls a1, cls b1, cls a2, cls b2) => {
			A(A(eq(m, equiv_cls(pair(a1, b1), cartesian(omega, omega), rel_omega_pair)), eq(n, equiv_cls(pair(a2, b2), cartesian(omega, omega), rel_omega_pair))), eq(k, equiv_cls(pair(omega_add(a1, a2), omega_add(b1, b2)), cartesian(omega, omega), rel_omega_pair)))
		})
	})
}

theorem int_add_X(cls m: @11, cls n: @21) {
	in(m, int), in(n, int) |- {
		with (pr predicate = (cls k) => {
			Xin4(omega, omega, omega, omega, (cls a1, cls b1, cls a2, cls b2) => {
				A(A(eq(m, equiv_cls(pair(a1, b1), cartesian(omega, omega), rel_omega_pair)), eq(n, equiv_cls(pair(a2, b2), cartesian(omega, omega), rel_omega_pair))), eq(k, equiv_cls(pair(omega_add(a1, a2), omega_add(b1, b2)), cartesian(omega, omega), rel_omega_pair)))
			})
		}) {
			$X = @h1 > int_in_e as Xin2(omega, omega, ($a_1'$ cls a1p, $b_1'$ cls b1p) => {
				eq(m, equiv_cls(pair(a1p, b1p), cartesian(omega, omega), rel_omega_pair))
			});
			
			$U = ($a_1'$ cls a1p) => { /* @h3 */ in(a1p, omega) |- {
			($b_1'$ cls b1p) => { in(b1p, omega) |- {
				eq(m, equiv_cls(pair(a1p, b1p), cartesian(omega, omega), rel_omega_pair)) |- {
					$X = @h2 > int_in_e as Xin2(omega, omega, ($a_2'$ cls a2p, $b_2'$ cls b2p) => {
						eq(n, equiv_cls(pair(a2p, b2p), cartesian(omega, omega), rel_omega_pair))
					});
					
					$U = ($a_2'$ cls a2p) => { /* @h6 */ in(a2p, omega) |- {
					($b_2'$ cls b2p) => { in(b2p, omega) |- {
						/* @h8 */ eq(n, equiv_cls(pair(a2p, b2p), cartesian(omega, omega), rel_omega_pair)) |- {
							[
								@h3; @h4; @h6; @h7;
								[
									[@h5; @h8] > Ai;
									eq_reflexive(equiv_cls(pair(omega_add(a1p, a2p), omega_add(b1p, b2p)), cartesian(omega, omega), rel_omega_pair))
								] > Ai
							] > Xin4i as predicate(equiv_cls(pair(omega_add(a1p, a2p), omega_add(b1p, b2p)), cartesian(omega, omega), rel_omega_pair))
							> Xi(?, equiv_cls(pair(omega_add(a1p, a2p), omega_add(b1p, b2p)), cartesian(omega, omega), rel_omega_pair)) as X((cls k) => predicate(k))
						} > cp
					} > cp } > Ui
					} > cp } > Ui;
					
					[$X; $U] > mpXin2_alt as X((cls k) => predicate(k))
				} > cp
			} > cp } > Ui
			} > cp } > Ui;
			
			[$X; $U] > mpXin2_alt as X((cls k) => predicate(k))
		}
	}
}

theorem int_add_Q(cls m: @11, cls n: @21) {
	in(m, int), in(n, int) |- {
		with ([cls -> pr4] predicate4 = (cls k) => {
			($a_1'$ cls a1p, $b_1'$ cls b1p, $a_2'$ cls a2p, $b_2'$ cls b2p) => {
				A(A(eq(m, equiv_cls(pair(a1p, b1p), cartesian(omega, omega), rel_omega_pair)), eq(n, equiv_cls(pair(a2p, b2p), cartesian(omega, omega), rel_omega_pair))), eq(k, equiv_cls(pair(omega_add(a1p, a2p), omega_add(b1p, b2p)), cartesian(omega, omega), rel_omega_pair)))
			}
		}) {
			with (pr predicate = (cls k) => {
				Xin4(omega, omega, omega, omega, predicate4(k))
			}) {
				$X = @h1 > int_in_e as Xin2(omega, omega, (cls a1, cls b1) => eq(m, equiv_cls(pair(a1, b1), cartesian(omega, omega), rel_omega_pair)));

				$U = (cls a1, cls b1) => {
					/* @h3 */ in(a1, omega), in(b1, omega) |- {
						/* @h5 */ eq(m, equiv_cls(pair(a1, b1), cartesian(omega, omega), rel_omega_pair)) |- {
							$X = @h2 > int_in_e as Xin2(omega, omega, (cls a2, cls b2) => eq(n, equiv_cls(pair(a2, b2), cartesian(omega, omega), rel_omega_pair)));

							$U = (cls a2, cls b2) => {
								/* @h6 */ in(a2, omega), in(b2, omega) |- {
									/* @h8 */ eq(n, equiv_cls(pair(a2, b2), cartesian(omega, omega), rel_omega_pair)) |- {
										(cls k) => {
											/* @h9 */ predicate(k) |- {
												$U = ($a_1'$ cls a1p, $b_1'$ cls b1p, $a_2'$ cls a2p, $b_2'$ cls b2p) => {
													/* @h10 */ in(a1p, omega), in(b1p, omega), in(a2p, omega), in(b2p, omega) |- {
														/* @h14 */ (predicate4(k))(a1p, b1p, a2p, b2p) |- {
															$foo = @h14 > Ae1;
															$m_is_a1pb1p = $foo > Ae1;
															$n_is_a2pb2p = $foo > Ae2;
															$k_is_a1pa2p_b1pb2p = @h14 > Ae2;

															$a1b1_is_a1pb1p = [@h5 > eq_symmetric; $m_is_a1pb1p] > eq_transitive;
															$a2b2_is_a2pb2p = [@h8 > eq_symmetric; $n_is_a2pb2p] > eq_transitive;

															$a1b1p_is_a1pb1 = [
																@h3; @h4; @h10; @h11;
																[@h3; @h4; @h10; @h11; $a1b1_is_a1pb1p] > int_eq_e
															] > rel_omega_pair_e;

															$a2b2p_is_a2pb2 = [
																@h6; @h7; @h12; @h13;
																[@h6; @h7; @h12; @h13; $a2b2_is_a2pb2p] > int_eq_e
															] > rel_omega_pair_e;

															$nat_a1a2 = [@h3; @h6] > omega_add_in_omega;
															$nat_b1pb2p = [@h11; @h13] > omega_add_in_omega;
															$nat_a1pa2p = [@h10; @h12] > omega_add_in_omega;
															$nat_b1b2 = [@h4; @h7] > omega_add_in_omega;

															$rel = [
																$nat_a1a2; $nat_b1b2; $nat_a1pa2p; $nat_b1pb2p;
																[
																	[@h3; @h11; @h6; @h13] > omega_add_flip_inner > eq_symmetric;
																	[$a1b1p_is_a1pb1; $a2b2p_is_a2pb2] > omega_add_eq_i;
																	[@h10; @h4; @h12; @h7] > omega_add_flip_inner
																] > eq_transitive_3
															] > rel_omega_pair_i;

															[
																$k_is_a1pa2p_b1pb2p;
																[
																	rel_omega_pair_is_equiv_rel();
																	[$nat_a1a2; $nat_b1b2] > cartesian_in_i;
																	[$nat_a1pa2p; $nat_b1pb2p] > cartesian_in_i;
																	$rel
																] > equiv_cls_eq_i > eq_symmetric
															] > eq_transitive
														} > cp
													}
												} > Uin4i;

												[@h9; $U] > mpXin4_alt as eq(k, equiv_cls(pair(omega_add(a1, a2), omega_add(b1, b2)), cartesian(omega, omega), rel_omega_pair))
											} > cp
										} > Ui > Qim
									} > cp
								}
							} > Uin2i;

							[$X; $U] > mpXin2_alt as Q(predicate)
						} > cp
					}
				} > Uin2i;
				
				[$X; $U] > mpXin2_alt as Q(predicate)
			}
		}
	}
}

theorem int_add_def(cls m: @11, cls n: @21) {
	in(m, int), in(n, int) |- {
		with (pr predicate = (cls k) => {
			Xin4(omega, omega, omega, omega, (cls a1, cls b1, cls a2, cls b2) => {
				A(A(eq(m, equiv_cls(pair(a1, b1), cartesian(omega, omega), rel_omega_pair)), eq(n, equiv_cls(pair(a2, b2), cartesian(omega, omega), rel_omega_pair))), eq(k, equiv_cls(pair(omega_add(a1, a2), omega_add(b1, b2)), cartesian(omega, omega), rel_omega_pair)))
			})
		}) {
			$X = [@h1; @h2] > int_add_X as X(predicate);
			$Q = [@h1; @h2] > int_add_Q as Q(predicate);

			[$X; $Q] > XQ_to_Xq > instantiate_def as predicate(int_add(m, n))
		}
	}
}