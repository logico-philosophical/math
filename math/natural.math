import propositional;
import predicate;
import set;
import relation;
import function;

"따름 순서수(successor ordinal)."
${#1}^{<<+>>}$
cls successor(cls x) {
	cup(x, singleton(x))
}

theorem successor_eq_i(cls x: @11, cls y: @12) {
	eq(x, y) |- {
		[
			@h1;
			@h1 > singleton_eq_i
		] > cup_eq_i as eq(successor(x), successor(y))
	}
}

theorem self_in_successor(cls x: @11) {
	set(x) |- {
		@h1 > self_in_singleton(x) > cup_i2(x, ?, ?) as in(x, successor(x))
	}
}

"순서수(ordinal number)로서의 0."
$0_\omega$
cls ord_zero = emptyset;

"순서수(ordinal number)로서의 1. 0의 따름 순서수이다."
$1_\omega$
cls ord_one = successor(ord_zero);

"순서수(ordinal number)로서의 2. 1의 따름 순서수이다."
$2_\omega$
cls ord_two = successor(ord_one);

"따름 순서수는 집합이다."
theorem successor_is_set(cls x: @11) {
	set(x) |- {
		[
			@h1;
			@h1 > singleton_set_i
		] > cup_is_set as set(successor(x))
	}
}

"[$x]가 successor set이다."
$\left(<<\operatorname{successor\ set}>> #1\right)$
st is_successor_set(cls x) {
	A(in(emptyset, x), U((cls z) => I(in(z, x), in(successor(z), x))))
}

"무한 공리(axiom of infinity). 즉 successor set 중에는 집합인 것이 있다."
axiom ax_infinity() {
	X((cls x) => A(set(x), is_successor_set(x)))
}

"자연수 집합. 즉 모든 successor set을 교집합한 것이다."
$\omega$
cls omega = bigcap(setbuilder((cls z) => is_successor_set(z)));

"자연수 집합은 0을 포함한다. `[Pinter]`에 따르면 페아노 공리계 제1공리이다."
theorem zero_in_omega() {
	[
		ax_emptyset();
		(cls z) => {
			in(z, setbuilder((cls z) => is_successor_set(z))) |- {
				@h1 > setbuilder_e > Ae1
			} > cp
		} > Ui
	] > bigcap_i(setbuilder((cls z) => is_successor_set(z)), ord_zero) as in(ord_zero, omega)
}

"`[Pinter]`에 따르면 페아노 공리계 제2공리인 것."
theorem successor_in_omega(cls z: @11) {
	in(z, omega) |- {
		[
			@h1 > Xi(contains(z), omega) > successor_is_set(z);
			(cls x) => {
				in(x, setbuilder((cls z) => is_successor_set(z))) |- {
					[
						[
							@h2;
							@h1 > bigcap_e(setbuilder((cls z) => is_successor_set(z)), z) > Ue(?, x)
						] > mp;
						@h2 > setbuilder_e((cls z) => is_successor_set(z), x) > Ae2 > Ue(?, z)
					] > mp
				} > cp
			} > Ui
		] > bigcap_i(setbuilder((cls z) => is_successor_set(z)), successor(z)) as in(successor(z), omega)
	}
}

"[$\omega]는 successor set이다."
theorem omega_is_successor_set() {
	[
		zero_in_omega();
		(cls z) => { successor_in_omega(z) > cp } > Ui
	] > Ai as is_successor_set(omega)
}

"자연수 집합은 집합이다. ax_infinity로부터 유도된다."
theorem omega_is_set() {
	[
		ax_infinity();
		(cls x) => {
			A(set(x), is_successor_set(x)) |- {
				[
					@h1 > Ae1;
					@h1 > setbuilder_ia((cls z) => is_successor_set(z), ?) > bigcap_is_smaller
				] > subset_is_set as set(omega)
			} > cp
		} > Ui
	] > mpX_Xe_p(?, set(omega))
}

"`[Pinter]` 정리 6.3."
theorem induce_set($X$ cls x: @11) {
	subseteq(x, omega), in(ord_zero, x),
	Uin(omega, (cls n) => I(in(n, x), in(successor(n), x))) |- {
		$x_is_successor_set = [
			@h2;
			(cls n) => {
				in(n, x) |- {
					[
						@h4;
						[
							[@h4; @h1] > in_subseteq;
							@h3 > Ue(?, n)
						] > mp
					] > mp
				} > cp
			} > Ui
		] > Ai as is_successor_set(x);

		$omega_subseteq_x = [
			[omega_is_set(); @h1] > subset_is_set;
			$x_is_successor_set
		] > setbuilder_i((cls z) => is_successor_set(z), ?) > bigcap_is_smaller as subseteq(omega, x);

		[@h1; $omega_subseteq_x] > subseteq_to_eq
	}
}

"수학적 귀납법. [~(href=https://www.cs.ru.nl/~freek/100/)[*Formalizing 100 Theorems]]의 정리 #74이다."
theorem induce(pr f) {
	$foo = (cls z) => {
		in(z, omega) |- {
			[
				f(z) |- {
					[@h1; @h2] > subsetbuilder_i(omega, f, z)
				};
				in(z, subsetbuilder(omega, f)) |- {
					@h2 > subsetbuilder_e
				}
			] > Ei_alt
		}
	};

	f(ord_zero), Uin(omega, (cls n) => I(f(n), f(successor(n)))) |- {
		$c1 = subsetbuilder_is_subset(omega, f);

		$c2 = [
			@h1;
			zero_in_omega() > $foo(ord_zero)
		] > mpE1;

		$c3 = (cls n) => {
			in(n, omega) |- {
				in(n, subsetbuilder(omega, f)) |- {
					[
						[
							@h4 > subsetbuilder_e;
							[
								@h3;
								@h2 > Ue(?, n)
							] > mp
						] > mp;
						@h3 > successor_in_omega > $foo(successor(n))
					] > mpE1
				} > cp
			} > cp
		} > Ui as Uin(omega, (cls n) => I(in(n, subsetbuilder(omega, f)), in(successor(n), subsetbuilder(omega, f))));

		(cls n) => {
			in(n, omega) |- {
				[
					@h3;
					[$c1; $c2; $c3] > induce_set
				] > in_eq_right_2 > subsetbuilder_e
			} > cp
		} > Ui as Uin(omega, f)
	}
}

"induce_set의 더 강력한 버전."
theorem induce_set_strong($X$ cls x: @12) {
	in(ord_zero, x), Uin(omega, (cls n) => I(in(n, x), in(successor(n), x))) |- {
		[@h1; @h2] > induce(is_in(x)) as subseteq(omega, x)
	}
}

"`[Pinter]`에 따르면 페아노 공리계 제3공리인 것."
theorem successor_is_not_zero(cls n: @11) {
	in(n, omega) |- {
		eq(successor(n), ord_zero) |- {
			[
				[
					@h1 > set_i > self_in_successor;
					@h2
				] > in_eq_right_1;
				emptyset_def(n) > id(Nin(n, ord_zero))
			] > Fi
		} > Ni_alt as Neq(successor(n), ord_zero)
	}
}

"`[Pinter]` 보조정리 6.6."
theorem omega_in_to_subseteq(cls n: @11, cls m: @21) {
	$base = (cls m) => {
		in(m, ord_zero) |- {
			N(subseteq(m, ord_zero)) |- {
				[@h1; emptyset_def(m)] > Fi
			} > Ni_alt > NNe
		} > cp
	} > Ui;

	$step = (cls n) => {
		in(n, omega) |- {
			U((cls m) => I(in(m, n), subseteq(m, n))) |- {
				(cls m) => {
					in(m, successor(n)) |- {
						$n_subseteq_successor_n = cup_is_bigger_1(n, singleton(n)) > id(subseteq(n, successor(n)));

						[
							@h3 > cup_e;
							in(m, n) |- {
								[
									[
										@h4;
										@h2 > Ue(?, m)
									] > mp;
									$n_subseteq_successor_n
								] > subseteq_subseteq
							};
							in(m, singleton(n)) |- {
								[
									[
										@h1 > set_i;
										@h4
									] > singleton_e;
									$n_subseteq_successor_n
								] > eq_subseteq
							}
						] > Oe_alt
					} > cp
				} > Ui
			} > cp
		} > cp
	} > Ui;

	in(n, omega), in(m, n) |- {
		[
			@h2;
			[
				@h1;
				[$base; $step] > induce((cls n) => U((cls m) => I(in(m, n), subseteq(m, n)))) > Ue(?, n)
			] > mp > Ue(?, m)
		] > mp
	}
}

"`[Pinter]`에 따르면 페아노 공리계 제5공리인 것."
theorem successor_eq_e(cls n: @11, cls m: @21) {
	in(n, omega), in(m, omega), eq(successor(n), successor(m)) |- {
		$base = [
			@h1 > set_i > self_in_successor;
			@h3
		] > in_eq_right_1 > setbuilder_e;

		$base_dual = [
			@h2 > set_i > self_in_successor;
			@h3
		] > in_eq_right_2 > setbuilder_e;

		$c1 = in(n, singleton(m)) |- {
			[
				@h2 > set_i;
				@h4
			] > singleton_e
		};

		$c1_dual = in(m, singleton(n)) |- {
			[
				@h1 > set_i;
				@h4
			] > singleton_e
		};

		Neq(n, m) |- {
			$c2 = [
				@h2;
				[
					$base;
					in(n, singleton(m)) |- {
						[
							@h5 > $c1;
							@h4
						] > Fi
					} > Ni_alt
				] > Oe2
			] > omega_in_to_subseteq;

			$c2_dual = [
				@h1;
				[
					$base_dual;
					in(m, singleton(n)) |- {
						[
							@h5 > $c1_dual;
							@h4 > Neq_symmetric
						] > Fi
					} > Ni_alt
				] > Oe2
			] > omega_in_to_subseteq;

			[
				[$c2; $c2_dual] > subseteq_to_eq;
				@h4
			] > Fi
		} > Ni_alt > NNe
	}
}

st is_recursively_defined($\gamma$ cls g, $A$ cls a, cls c, cls f) {
	A(is_fun(g, omega, a), A(eq(funcall(g, ord_zero), c), Uin(omega, (cls n) => eq(funcall(g, successor(n)), funcall(f, funcall(g, n))))))
}

st is_recursively_defined_m($\gamma$ cls g, $A$ cls a, cls c, fun f) {
	A(is_fun(g, omega, a), A(eq(funcall(g, ord_zero), c), Uin(omega, (cls n) => eq(funcall(g, successor(n)), f(funcall(g, n))))))
}

"재귀정리의 증명에 사용되는 술어."
st is_recursive_supset($G$ cls g, $A$ cls a, cls c, cls f) {
	A(subseteq(g, cartesian(omega, a)), A(in(pair(ord_zero, c), g), Uin(omega, (cls n) => {
		Uin(a, (cls x) => I(in(pair(n, x), g), in(pair(successor(n), funcall(f, x)), g)))
	})))
}

"클래스 [$A] 및 그 원소 [$c\in A] 및 함수 [$f: A\to A]에 대하여,
[ol
	[*] [$\gamma(0) = c,]
	[*] 임의의 [$n\in\omega]에 대하여, [$\gamma(n^+)=f(\gamma(n))]
]
을 만족하는 함수 [$\gamma:\omega\to A]를 만든다. [$c]와 [$f]가 조건을 만족하지 않으면 만들어지지 않는다. `[Pinter]`의 정리 6.8에 등장한다."
$<<\operatorname{recursive\ def.}>>\left(\text{to=}#1, \text{base=}#2, \text{step=}#3\right)$
sealed cls define_recursively($A$ cls a, cls c, cls f) {
	bigcap3(($G$ cls g) => is_recursive_supset(g, a, c, f), ($G$ cls g) => g)
}

"메타함수 [$f]를 위한 define_recursively."
$<<\operatorname{recursive\ def.}>>\left(\text{to=}#1, \text{base=}#2, \text{step=}#3\right)$
cls define_recursively_m($A$ cls a, cls c, fun f) {
	define_recursively(a, c, map(f, a))
}

"is_recursive_supset의 첫 번째 조건. 즉 [$\gamma\subseteq\omega\times A]이다.
[$\gamma]가 함수가 되기 위한 첫 번째 조건이기도 하다."
theorem recursion_theorem_1($A$ cls a: @12, cls c: @11, cls f: @21) using define_recursively {
	in(c, a), is_fun(f, a, a) |- {
		$irs = [
			self_subseteq_self(cartesian(omega, a));
			[
				[zero_in_omega(); @h1] > cartesian_in_i;
				(cls n) => {
					in(n, omega) |- {
						(cls x) => {
							in(x, a) |- {
								in(pair(n, x), cartesian(omega, a)) |- {
									[
										@h3 > successor_in_omega;
										[@h2; @h4] > funcall_in_codomain
									] > cartesian_in_i
								} > cp
							} > cp
						} > Ui((cls x) => {
							I(in(x, a), I(in(pair(n, x), cartesian(omega, a)), in(pair(successor(n), funcall(f, x)), cartesian(omega, a))))
						}) as Uin(a, (cls x) => {
							I(in(pair(n, x), cartesian(omega, a)), in(pair(successor(n), funcall(f, x)), cartesian(omega, a)))
						})
					} > cp
				} > Ui((cls n) => {
					I(in(n, omega), Uin(a, (cls x) => {
						I(in(pair(n, x), cartesian(omega, a)), in(pair(successor(n), funcall(f, x)), cartesian(omega, a)))
					}))
				}) as Uin(omega, (cls n) => {
					Uin(a, (cls x) => {
						I(in(pair(n, x), cartesian(omega, a)), in(pair(successor(n), funcall(f, x)), cartesian(omega, a)))
					})
				})
			] > Ai
		] > Ai as is_recursive_supset(cartesian(omega, a), a, c, f);

		$irs > bigcap3_is_smaller(?, ?, cartesian(omega, a)) as subseteq(define_recursively(a, c, f), cartesian(omega, a))
	}
}

"is_recursive_supset의 두 번째 조건."
theorem recursion_theorem_2($A$ cls a: @12, cls c: @11, cls f) using define_recursively {
	in(c, a) |- {
		$set_0c = [
			zero_in_omega() > set_i;
			@h1 > set_i
		] > pair_set_i;

		[
			$set_0c;
			($G$ cls g) => {
				is_recursive_supset(g, a, c, f) |- {
					@h2 > Ae2 > Ae1
				} > cp
			} > Ui
		] > bigcap3_i as in(pair(ord_zero, c), define_recursively(a, c, f))
	}
}

"is_recursive_supset의 세 번째 조건."
theorem recursion_theorem_3($A$ cls a: @12, cls c, cls f: @11) using define_recursively {
	is_fun(f, a, a) |- {
		with ($\gamma$ cls g = define_recursively(a, c, f)) {
			(cls n) => {
				in(n, omega) |- {
					(cls x) => {
						in(x, a) |- {
							in(pair(n, x), g) |- {
								[
									[
										@h2 > set_i > successor_is_set;
										[@h1; @h3] > funcall_in_codomain > set_i
									] > pair_set_i;
									[
										@h4 > setbuilder_e;
										($G$ cls g) => {
											is_recursive_supset(g, a, c, f) |- {
												[
													@h3;
													[
														@h2;
														@h5 > Ae2 > Ae2 > Ue(?, n)
													] > mp > Ue(?, x)
												] > mp
											} > cp > I_distribute_left
										} > Ui > UIm(($G$ cls g) => I(is_recursive_supset(g, a, c, f), in(pair(n, x), g)), ($G$ cls g) => I(is_recursive_supset(g, a, c, f), in(pair(successor(n), funcall(f, x)), g)))
									] > mp
								] > bigcap3_i as in(pair(successor(n), funcall(f, x)), define_recursively(a, c, f))
							} > cp
						} > cp
					} > Ui
				} > cp
			} > Ui as Uin(omega, (cls n) => {
				Uin(a, (cls x) => I(in(pair(n, x), g), in(pair(successor(n), funcall(f, x)), g)))
			})
		}
	}
}

"[$\gamma]가 함수가 되기 위한 두 번째 조건."
theorem recursion_theorem_4($A$ cls a: @12, cls c: @11, cls f: @21) {
	in(c, a), is_fun(f, a, a) |- {
		with ($\gamma$ cls g = define_recursively(a, c, f)) {
			$base = [
				@h1;
				@h1 > recursion_theorem_2(a, c, f) as in(pair(ord_zero, c), g)
			] > Ai > Xi((cls x) => A(in(x, a), in(pair(ord_zero, x), g)), c) as Xin(a, (cls x) => in(pair(ord_zero, x), g));

			$step = (cls n) => {
				in(n, omega) |- {
					Xin(a, (cls x) => in(pair(n, x), g)) |- {
						[
							@h4;
							(cls x) => {
								in(x, a) |- {
									in(pair(n, x), g) |- {
										[
											[@h2; @h5] > funcall_in_codomain;
											[
												@h6;
												[
													@h5;
													[
														@h3;
														@h2 > recursion_theorem_3(a, c, f) as Uin(omega, (cls n) => {
															Uin(a, (cls x) => I(in(pair(n, x), g), in(pair(successor(n), funcall(f, x)), g)))
														}) > Ue(?, n)
													] > mp > Ue(?, x)
												] > mp
											] > mp
										] > Ai > Xi((cls x) => A(in(x, a), in(pair(successor(n), x), g)), funcall(f, x))
									} > cp
								} > cp
							} > Ui
						] > mpXin_Xe_p(?, ?, Xin(a, (cls x) => in(pair(successor(n), x), g)))
					} > cp
				} > cp
			} > Ui;

			[$base; $step] > induce((cls n) => Xin(a, (cls x) => in(pair(n, x), g)))
		}
	}
}

"[$\gamma]가 함수가 되기 위한 세 번째 조건의 base case."
theorem recursion_theorem_5_base($A$ cls a: @12, cls c: @11, cls f: @21) using define_recursively {
	in(c, a), is_fun(f, a, a) |- {
		with ($\gamma$ cls g = define_recursively(a, c, f)) {
			(cls d) => {
				in(pair(ord_zero, d), g) |- {
					Neq(d, c) |- {
						$c1 = [
							setminus_is_smaller(g, singleton(pair(ord_zero, d)));
							[@h1; @h2] > recursion_theorem_1 as subseteq(g, cartesian(omega, a))
						] > subseteq_subseteq;

						$c2 = [
							@h1 > recursion_theorem_2(a, c, f) as in(pair(ord_zero, c), g);
							in(pair(ord_zero, c), singleton(pair(ord_zero, d))) |- {
								[
									[
										ax_emptyset();
										@h1 > set_i;
										ax_emptyset();
										@h3 > set_i > pair_set_e2;
										[
											@h3 > set_i;
											@h5
										] > singleton_e
									] > pair_eq_e2 > eq_symmetric;
									@h4
								] > Fi
							} > Ni_alt
						] > setminus_i;

						$c3 = (cls n) => {
							in(n, omega) |- {
								(cls x) => {
									in(x, a) |- {
										in(pair(n, x), setminus(g, singleton(pair(ord_zero, d)))) |- {
											[
												[
													[@h7; setminus_is_smaller(g, singleton(pair(ord_zero, d)))] > in_subseteq;
													[
														@h6;
														[
															@h5;
															@h2 > recursion_theorem_3(a, c, f) as Uin(omega, (cls n) => {
																Uin(a, (cls x) => I(in(pair(n, x), g), in(pair(successor(n), funcall(f, x)), g)))
															}) > Ue(?, n)
														] > mp > Ue(?, x)
													] > mp
												] > mp;
												in(pair(successor(n), funcall(f, x)), singleton(pair(ord_zero, d))) |- {
													[
														[
															@h3 > set_i;
															[
																@h3 > set_i;
																@h8
															] > singleton_e
														] > pair_eq_e1_v2;
														@h5 > successor_is_not_zero
													] > Fi
												} > Ni_alt
											] > setminus_i
										} > cp
									} > cp
								} > Ui
							} > cp
						} > Ui;

						$gamma_is_smaller = [
							$c1;
							[$c2; $c3] > Ai
						] > Ai as is_recursive_supset(setminus(define_recursively(a, c, f), singleton(pair(ord_zero, d))), a, c, f) > bigcap3_is_smaller(?, ?, setminus(define_recursively(a, c, f), singleton(pair(ord_zero, d)))) as subseteq(define_recursively(a, c, f), setminus(define_recursively(a, c, f), singleton(pair(ord_zero, d))));

						[
							@h3 > set_i > self_in_singleton;
							[@h3; $gamma_is_smaller] > in_subseteq > setminus_e2
						] > Fi
					} > Ni_alt > NNe
				} > cp
			} > Ui > Qim((cls x) => in(pair(ord_zero, x), g), c)
		}
	}
}

"[$\gamma]가 함수가 되기 위한 세 번째 조건의 step case."
theorem recursion_theorem_5_step($A$ cls a: @12, cls c: @11, cls f: @21) using define_recursively {
	in(c, a), is_fun(f, a, a) |- {
		with ($\gamma$ cls g = define_recursively(a, c, f)) {
			(cls n) => {
				in(n, omega) |- {
					Q((cls x) => in(pair(n, x), g)) |- {
						[
							[
								@h3;
								[@h1; @h2] > recursion_theorem_4 as Uin(omega, (cls n) => Xin(a, (cls x) => in(pair(n, x), g))) > Ue(?, n)
							] > mp;
							(cls x) => {
								in(x, a) |- {
									in(pair(n, x), g) |- {
										(cls u) => {
											in(pair(successor(n), u), g) |- {
												Neq(u, funcall(f, x)) |- {
													$c1 = [
														setminus_is_smaller(g, singleton(pair(successor(n), u)));
														[@h1; @h2] > recursion_theorem_1 as subseteq(g, cartesian(omega, a))
													] > subseteq_subseteq;

													$c2 = [
														@h1 > recursion_theorem_2(a, c, f) as in(pair(ord_zero, c), g);
														in(pair(ord_zero, c), singleton(pair(successor(n), u))) |- {
															[
																[
																	@h7 > set_i;
																	[
																		@h7 > set_i;
																		@h9
																	] > singleton_e
																] > pair_eq_e1_v2 > eq_symmetric;
																@h3 > successor_is_not_zero
															] > Fi
														} > Ni_alt
													] > setminus_i;

													$c3 = (cls m) => {
														in(m, omega) |- {
															(cls v) => {
																in(v, a) |- {
																	in(pair(m, v), setminus(g, singleton(pair(successor(n), u)))) |- {
																		$bar = [@h11; setminus_is_smaller(g, singleton(pair(successor(n), u)))] > in_subseteq;

																		$foo = [
																			$bar;
																			[
																				@h10;
																				[
																					@h9;
																					@h2 > recursion_theorem_3(a, c, f) as Uin(omega, (cls n) => {
																						Uin(a, (cls x) => I(in(pair(n, x), g), in(pair(successor(n), funcall(f, x)), g)))
																					}) > Ue(?, m)
																				] > mp > Ue(?, v)
																			] > mp
																		] > mp;

																		$c3_c1 = Neq(successor(m), successor(n)) |- {
																			[
																				$foo;
																				in(pair(successor(m), funcall(f, v)), singleton(pair(successor(n), u))) |- {
																					[
																						[
																							@h7 > set_i;
																							[
																								@h7 > set_i;
																								@h13
																							] > singleton_e
																						] > pair_eq_e1_v2;
																						@h12
																					] > Fi
																				} > Ni_alt
																			] > setminus_i
																		};

																		$c3_c2 = eq(successor(m), successor(n)) |- {
																			[
																				[
																					[
																						@h6;
																						[
																							@h5;
																							[
																								@h3;
																								@h2 > recursion_theorem_3(a, c, f) as Uin(omega, (cls n) => {
																									Uin(a, (cls x) => I(in(pair(n, x), g), in(pair(successor(n), funcall(f, x)), g)))
																								}) > Ue(?, n)
																							] > mp > Ue(?, x)
																						] > mp
																					] > mp;
																					in(pair(successor(n), funcall(f, x)), singleton(pair(successor(n), u))) |- {
																						[
																							[
																								@h13 > set_i;
																								[
																									@h7 > set_i;
																									@h13
																								] > singleton_e
																							] > pair_eq_e2_v1 > eq_symmetric;
																							@h8
																						] > Fi
																					} > Ni_alt
																				] > setminus_i;
																				[
																					@h12;
																					[
																						[
																							[
																								$bar;
																								[
																									[@h9; @h3; @h12] > successor_eq_e;
																									eq_reflexive(v)
																								] > pair_eq_i
																							] > in_eq_left_1;
																							@h6
																						] > Ai;
																						@h4 > Ue2(?, v, x)
																					] > mp > funcall_eq_i(f, ?, ?)
																				] > pair_eq_i
																			] > in_eq_left_2
																		};

																		[lxm(eq(successor(m), successor(n))); $c3_c2; $c3_c1] > Oe_alt
																	} > cp
																} > cp
															} > Ui
														} > cp
													} > Ui;

													$gamma_is_smaller = [
														$c1;
														[$c2; $c3] > Ai
													] > Ai as is_recursive_supset(setminus(define_recursively(a, c, f), singleton(pair(successor(n), u))), a, c, f) > bigcap3_is_smaller(?, ?, setminus(define_recursively(a, c, f), singleton(pair(successor(n), u)))) as subseteq(define_recursively(a, c, f), setminus(define_recursively(a, c, f), singleton(pair(successor(n), u))));

													[
														@h7 > set_i > self_in_singleton;
														[@h7; $gamma_is_smaller] > in_subseteq > setminus_e2
													] > Fi
												} > Ni_alt > NNe
											} > cp
										} > Ui > Qim((cls x) => in(pair(successor(n), x), g), funcall(f, x))
									} > cp
								} > cp
							} > Ui
						] > mpXin_Xe_p(?, ?, Q((cls x) => in(pair(successor(n), x), g)))
					} > cp
				} > cp
			} > Ui as Uin(omega, (cls n) => I(Q((cls x) => in(pair(n, x), g)), Q((cls x) => in(pair(successor(n), x), g))))
		}
	}
}

"[$\gamma]가 함수가 되기 위한 세 번째 조건."
theorem recursion_theorem_5($A$ cls a: @12, cls c: @11, cls f: @21) {
	in(c, a), is_fun(f, a, a) |- {
		[
			[@h1; @h2] > recursion_theorem_5_base;
			[@h1; @h2] > recursion_theorem_5_step
		] > induce((cls n) => Q((cls x) => in(pair(n, x), define_recursively(a, c, f))))
	}
}

"[$\gamma:\omega\to A]가 함수이다."
theorem recursion_theorem_6($A$ cls a: @12, cls c: @11, cls f: @21) {
	in(c, a), is_fun(f, a, a) |- {
		[
			[@h1; @h2] > recursion_theorem_1;
			[
				[@h1; @h2] > recursion_theorem_4;
				[@h1; @h2] > recursion_theorem_5
			] > UinA_i
		] > Ai as is_fun(define_recursively(a, c, f), omega, a)
	}
}

"[$\gamma]가 함수이고 재귀적으로 정의된다."
theorem recursion_theorem_7($A$ cls a: @12, cls c: @11, cls f: @21) {
	in(c, a), is_fun(f, a, a) |- {
		with ($\gamma$ cls g = define_recursively(a, c, f)) {
			$c1 = [@h1; @h2] > recursion_theorem_6 as is_fun(g, omega, a);

			$c2 = [
				$c1;
				@h1 > recursion_theorem_2(a, c, f) as in(pair(ord_zero, c), g)
			] > funcall_i > eq_symmetric;

			$c3 = (cls n) => {
				in(n, omega) |- {
					[
						[
							@h3;
							[@h1; @h2] > recursion_theorem_4 as Uin(omega, (cls n) => Xin(a, (cls x) => in(pair(n, x), g))) > Ue(?, n)
						] > mp;
						(cls x) => {
							in(x, a) |- {
								in(pair(n, x), g) |- {
									[
										[
											$c1;
											[
												@h5;
												[
													@h4;
													[
														@h3;
														@h2 > recursion_theorem_3(a, c, f) as Uin(omega, (cls n) => {
															Uin(a, (cls x) => I(in(pair(n, x), g), in(pair(successor(n), funcall(f, x)), g)))
														}) > Ue(?, n)
													] > mp > Ue(?, x)
												] > mp
											] > mp
										] > funcall_i > eq_symmetric;
										[$c1; @h5] > funcall_i > funcall_eq_i(f, ?, ?)
									] > eq_transitive
								} > cp
							} > cp
						} > Ui
					] > mpXin_Xe_p(?, ?, eq(funcall(g, successor(n)), funcall(f, funcall(g, n))))
				} > cp
			} > Ui;

			[
				$c1;
				[$c2; $c3] > Ai
			] > Ai as is_recursively_defined(g, a, c, f)
		}
	}
}

theorem recursion_theorem_7m($A$ cls a: @12, cls c: @11, fun f: @r4) {
	in(c, a), Uin(a, ($\gamma$ cls g) => in(f(g), a)) |- {
		with ($\gamma$ cls g = define_recursively_m(a, c, f)) {
			$map_f_is_fun = @h2 > map_is_fun(f, a, a);

			$ird = [@h1; $map_f_is_fun] > recursion_theorem_7 as is_recursively_defined(g, a, c, map(f, a));

			$is_fun = $ird > Ae1;

			$rec = $ird > Ae2;

			$base = $rec > Ae1;

			$step = $rec > Ae2;

			$newstep = (cls n) => {
				in(n, omega) |- {
					[
						[
							@h3;
							$step > Ue(?, n)
						] > mp;
						[
							@h2;
							[$is_fun; @h3] > funcall_in_codomain
						] > map_funcall(f, a, a, ?)
					] > eq_transitive
				} > cp
			} > Ui;

			[
				$is_fun;
				[$base; $newstep] > Ai
			] > Ai as is_recursively_defined_m(g, a, c, f)
		}
	}
}

"[$\gamma]는 여러 개 있지 않다."
theorem recursion_theorem_8($A$ cls a: @12, cls c: @11, cls f: @21) {
	in(c, a), is_fun(f, a, a) |- {
		($\gamma_1$ cls g1, $\gamma_2$ cls g2) => {
			is_recursively_defined(g1, a, c, f), is_recursively_defined(g2, a, c, f) |- {
				$g1_is_fun = @h3 > Ae1;

				$g2_is_fun = @h4 > Ae1;

				$base = [
					@h3 > Ae2 > Ae1;
					@h4 > Ae2 > Ae1 > eq_symmetric
				] > eq_transitive;

				$step = (cls n) => {
					in(n, omega) |- {
						eq(funcall(g1, n), funcall(g2, n)) |- {
							[
								[
									[
										@h5;
										@h3 > Ae2 > Ae2 > Ue(?, n)
									] > mp;
									@h6 > funcall_eq_i(f, ?, ?)
								] > eq_transitive;
								[
									@h5;
									@h4 > Ae2 > Ae2 > Ue(?, n)
								] > mp > eq_symmetric
							] > eq_transitive
						} > cp
					} > cp
				} > Ui;

				[
					$g1_is_fun; $g2_is_fun;
					[$base; $step] > induce((cls n) => eq(funcall(g1, n), funcall(g2, n)))
				] > fun_eq_i
			} > cp2
		} > Ui2 as Q(($\gamma$ cls g) => is_recursively_defined(g, a, c, f))
	}
}

"재귀 정리(recursion theorem)."
theorem recursion_theorem($A$ cls a: @12, cls c: @11, cls f: @21) {
	in(c, a), is_fun(f, a, a) |- {
		[
			[@h1; @h2] > recursion_theorem_7(a, c, f) > Xi(($\gamma$ cls g) => is_recursively_defined(g, a, c, f), define_recursively(a, c, f));
			[@h1; @h2] > recursion_theorem_8(a, c, f)
		] > XQ_to_Xq
	}
}

"자연수를 더하는 연산. 단항연산이다."
$\left(#1<<+_\omega>>\cdot\right)$
cls omega_add_unary(cls n) {
	define_recursively_m(omega, n, ($\gamma$ cls g) => successor(g))
}

theorem successor_is_fun() {
	($\gamma$ cls g) => {
		in(g, omega) |- {
			@h1 > successor_in_omega
		} > cp
	} > Ui > map_is_fun(($\gamma$ cls g) => successor(g), omega, omega)
}

theorem successor_funcall(cls n: @11) {
	in(n, omega) |- {
		[
			($\gamma$ cls g) => {
				in(g, omega) |- {
					@h2 > successor_in_omega
				} > cp
			} > Ui;
			@h1
		] > map_funcall(($\gamma$ cls g) => successor(g), omega, omega, ?)
	}
}

theorem omega_add_unary_ird(cls n) {
	in(n, omega) |- {
		$foo = ($\gamma$ cls g) => {
			in(g, omega) |- {
				@h2 > successor_in_omega
			} > cp
		} > Ui as Uin(omega, ($\gamma$ cls g) => in(successor(g), omega));

		[@h1; $foo] > recursion_theorem_7m(?, ?, ($\gamma$ cls g) => successor(g)) as is_recursively_defined_m(omega_add_unary(n), omega, n, ($\gamma$ cls g) => successor(g))
	}
}

"자연수 덧셈."
$!<prec=300>#1<<+_\omega>>#2$
cls omega_add(cls n, cls m) {
	funcall(omega_add_unary(n), m)
}

theorem omega_add_in_omega(cls n: @11, cls m: @21) {
	in(n, omega), in(m, omega) |- {
		[
			@h1 > omega_add_unary_ird(n) > Ae1;
			@h2
		] > funcall_in_codomain as in(omega_add(n, m), omega)
	}
}

"`[Pinter]` 6.10의 1."
theorem omega_add_base(cls n: @11) {
	in(n, omega) |- {
		@h1 > omega_add_unary_ird(n) > Ae2 > Ae1 as eq(omega_add(n, ord_zero), n)
	}
}

"`[Pinter]` 6.10의 2."
theorem omega_add_step(cls n: @11, cls m: @21) {
	in(n, omega), in(m, omega) |- {
		[
			@h2;
			@h1 > omega_add_unary_ird(n) > Ae2 > Ae2 > Ue(?, m)
		] > mp as eq(omega_add(n, successor(m)), successor(omega_add(n, m)))
	}
}

theorem omega_add_one(cls n: @11) {
	in(n, omega) |- {
		[
			[@h1; zero_in_omega()] > omega_add_step;
			@h1 > omega_add_base > successor_eq_i
		] > eq_transitive as eq(omega_add(n, ord_one), successor(n))
	}
}

"[$1+1=2]이다."
theorem one_plus_one_is_two() {
	zero_in_omega() > successor_in_omega as in(ord_one, omega) > omega_add_one(ord_one) as eq(omega_add(ord_one, ord_one), ord_two)
}

"자연수를 곱하는 연산. 단항연산이다.

[$n\times 0 = 0] 및 [$n\times m^+ = n + n\times m]으로 재귀적으로 정의된다."
$\left(#1<<\times_\omega>>\cdot\right)$
cls omega_mul_unary(cls n) {
	define_recursively_m(omega, ord_zero, ($\gamma$ cls g) => omega_add(n, g))
}

"자연수 곱셈."
$!<prec=299>#1<<\times_\omega>>#2$
cls omega_mul(cls n, cls m) {
	funcall(omega_mul_unary(n), m)
}

$\left(n<<\mapsto>> {#1}^n{\left(#2\right)}\right)$
cls fun_iterated_(cls f, cls x) {
	define_recursively_m(rel_dom(f), x, ($\gamma$ cls g) => funcall(f, g))
}

theorem fun_iterated_ird(cls f: @11, cls x: @21, $A$ cls a: @12) {
	is_fun(f, a, a), in(x, a) |- {
		$dom_f_is_a = @h1 > fun_dom;

		[
			[@h2; $dom_f_is_a] > in_eq_right_2;
			(cls z) => {
				in(z, rel_dom(f)) |- {
					$z_in_a = [@h3; $dom_f_is_a] > in_eq_right_1;

					[
						[@h1; $z_in_a] > funcall_in_codomain;
						$dom_f_is_a
					] > in_eq_right_2
				} > cp
			} > Ui
		] > recursion_theorem_7m as is_recursively_defined_m(fun_iterated_(f, x), rel_dom(f), x, ($\gamma$ cls g) => funcall(f, g))
	}
}

${#1}^{#2}{\left(#3\right)}{}^{\scriptscriptstyle<<\dag\text{discouraged}>>}$
sealed cls fun_iterated_call(cls f, cls n, cls x) {
	funcall(fun_iterated_(f, x), n)
}

"반복합성함수(iterated function). 자기함수(endofunction) [$f]의 합성을 [$n]번 한 것이다. [$f]가 자기함수일 때만 제대로 정의된다."
${#1}^{#2}{}^{\scriptscriptstyle<<\dag>>}$
cls fun_iterated(cls f, cls n) {
	map((cls x) => fun_iterated_call(f, n, x), rel_dom(f))
}

theorem fun_iterated_def(cls f: @11, $A$ cls a: @12, cls n: @21, cls x: @31) using fun_iterated_call {
	is_fun(f, a, a), in(n, omega), in(x, a) |- {
		$fun_dom = @h1 > fun_dom;

		$dom_to_a = (cls x) => {
			in(x, rel_dom(f)) |- {
				$x_in_a = [@h4; $fun_dom] > in_eq_right_1;

				[
					[
						[@h1; $x_in_a] > fun_iterated_ird > Ae1;
						@h2
					] > funcall_in_codomain as in(fun_iterated_call(f, n, x), rel_dom(f));
					@h1 > fun_dom
				] > in_eq_right_1
			} > cp
		} > Ui;

		[
			$dom_to_a;
			[@h3; $fun_dom] > in_eq_right_2
		] > map_funcall(?, ?, a, ?) as eq(funcall(fun_iterated(f, n), x), fun_iterated_call(f, n, x))
	}
}

theorem fun_iterated_base(cls f: @11, cls x: @21, $A$ cls a: @12) using fun_iterated_call {
	is_fun(f, a, a), in(x, a) |- {
		[
			[@h1; zero_in_omega(); @h2] > fun_iterated_def;
			[@h1; @h2] > fun_iterated_ird(f, x, a) > Ae2 > Ae1 as eq(fun_iterated_call(f, ord_zero, x), x)
		] > eq_transitive
	}
}

theorem fun_iterated_is_fun(cls f: @11, $A$ cls a: @12, cls n: @21) using fun_iterated_call {
	is_fun(f, a, a), in(n, omega) |- {
		$fun_dom = @h1 > fun_dom;

		$dom_to_a = (cls x) => {
			in(x, rel_dom(f)) |- {
				$x_in_a = [@h3; $fun_dom] > in_eq_right_1;

				[
					[
						[@h1; $x_in_a] > fun_iterated_ird > Ae1;
						@h2
					] > funcall_in_codomain as in(fun_iterated_call(f, n, x), rel_dom(f));
					@h1 > fun_dom
				] > in_eq_right_1
			} > cp
		} > Ui > map_is_fun as is_fun(fun_iterated(f, n), rel_dom(f), a);

		[$fun_dom; $dom_to_a] > ax_indiscernible_m1(($B$ cls b) => is_fun(fun_iterated(f, n), b, a), ?, ?)
	}
}

theorem fun_iterated_im_base(cls f: @11, $A$ cls a: @12, $B$ cls b: @21) {
	is_fun(f, a, a), subseteq(b, a) |- {
		$f0_is_fun = [@h1; zero_in_omega()] > fun_iterated_is_fun;

		$foo = (cls y) => {
			$c1 = in(y, rel_im_set(fun_iterated(f, ord_zero), b)) |- {
				$xy_in_f0 = @h3 > setbuilder_e;

				$U = (cls x) => {
					in(x, b), in(pair(x, y), fun_iterated(f, ord_zero)) |- {
						$x_in_a = [@h4; @h2] > in_subseteq;

						$y_is_x = [
							[$f0_is_fun; @h5] > funcall_i;
							[
								@h1;
								[@h4; @h2] > in_subseteq
							] > fun_iterated_base
						] > eq_transitive;

						[@h4; $y_is_x] > in_eq_left_2
					} > cp2
				} > Ui;

				[$xy_in_f0; $U] > mpX_Xe_p(?, in(y, b))
			} > cp;

			$c2 = in(y, b) |- {
				$y_in_a = [@h3; @h2] > in_subseteq;

				$yy_in_f0 = [
					[$f0_is_fun; $y_in_a] > funcall_def;
					[
						eq_reflexive(y);
						[@h1; $y_in_a] > fun_iterated_base
					] > pair_eq_i
				] > in_eq_left_1;

				[
					@h3 > set_i;
					[@h3; $yy_in_f0] > Ai > Xi((cls x) => A(in(x, b), in(pair(x, y), fun_iterated(f, ord_zero))), y)
				] > setbuilder_i as in(y, rel_im_set(fun_iterated(f, ord_zero), b))
			} > cp;

			[$c1; $c2] > Ei
		} > Ui;

		$foo > eq_i(rel_im_set(fun_iterated(f, ord_zero), b), b)
	}
}

theorem schroeder_bernstein_1($A$ cls a: @12, $B$ cls b: @13, cls f: @11, cls g: @21) {
	is_injection(f, a, b), is_injection(g, b, a) |- {
		with ($A^\ast$ cls aa = bigcup2(omega, (cls n) => rel_im_set(fun_iterated(rel_composite(g, f), n), setminus(a, rel_im(g))))) {
			with ($\mathfrak h$ fun hh = (cls x) => if(in(x, aa), funcall(f, x), funcall(rel_inverse(g), x))) {
				with (cls h = map(hh, a)) {
					$f_is_fun = @h1 > Ae1;

					$g_is_fun = @h2 > Ae1;

					$y_in_b = (cls x) => {
						in(x, a) |- {
							$b = lxm(in(x, aa));

							$c1 = in(x, aa) |- {
								$y_is_fx = @h4 > if_def_1(?, funcall(f, x), funcall(rel_inverse(g), x));

								[
									[$f_is_fun; @h3] > funcall_in_codomain;
									$y_is_fx
								] > in_eq_left_2
							} > cp;

							$c2 = Nin(x, aa) |- {
								$x_in_a_minus_aa = [@h3; @h4] > setminus_i;

								$y_is_g_inv_x = @h4 > if_def_2(?, funcall(f, x), funcall(rel_inverse(g), x));

								$g_inv_is_bijection = @h2 > injection_to_bijection > bijection_inverse_is_bijection;

								$g_inv_is_function = $g_inv_is_bijection > Ae1;

								$gf_is_fun = [$f_is_fun; $g_is_fun] > fun_composite_is_fun;

								$f0_is_fun = [$gf_is_fun; zero_in_omega()] > fun_iterated_is_fun;

								$0 = [$gf_is_fun; setminus_is_smaller(a, rel_im(g))] > fun_iterated_im_base;

								$x_in_im_g = Nin(x, rel_im(g)) |- {
									[
										[
											zero_in_omega();
											[
												[@h3; @h5] > setminus_i;
												$0
											] > in_eq_right_2
										] > bigcup2_i as in(x, aa);
										@h4
									] > Fi
								} > Ni_alt > NNe;

								[
									[$g_inv_is_function; $x_in_im_g] > funcall_in_codomain;
									$y_is_g_inv_x
								] > in_eq_left_2
							} > cp;

							[$b; $c1; $c2] > Oe
						} > cp
					} > Ui;

					$y_in_b > map_is_fun as is_fun(h, a, b)
				}
			}
		}
	}
}

schema schroeder_bernstein_2($A$ cls a, $B$ cls b, cls f, cls g) {
	is_injection(f, a, b), is_injection(g, b, a) |- {
		with ($A^\ast$ cls aa = bigcup2(omega, (cls n) => rel_im_set(fun_iterated(rel_composite(g, f), n), setminus(a, rel_im(g))))) {
			with (cls h = map((cls x) => if(in(x, aa), funcall(f, x), funcall(rel_inverse(g), x)), a)) {
				is_bijection(h, a, b)
			}
		}
	}
}

"Schr[&ouml]der[&ndash]Bernstein 정리."
schema schroeder_bernstein($A$ cls a, $B$ cls b) {
	X((cls f) => is_injection(f, a, b)), X((cls g) => is_injection(g, b, a)) |- X((cls h) => is_bijection(h, a, b))
}